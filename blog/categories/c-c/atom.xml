<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C/C++ | 残剑]]></title>
  <link href="http://txgcwm.github.io/blog/categories/c-c/atom.xml" rel="self"/>
  <link href="http://txgcwm.github.io/"/>
  <updated>2013-08-02T00:35:08+08:00</updated>
  <id>http://txgcwm.github.io/</id>
  <author>
    <name><![CDATA[残剑]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux管道的实现机制]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/02/linuxguan-dao-de-shi-xian-ji-zhi/"/>
    <updated>2013-08-02T00:24:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/02/linuxguan-dao-de-shi-xian-ji-zhi</id>
    <content type="html"><![CDATA[<p>在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现为：</p>

<ul>
<li><p>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。</p></li>
<li><p>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</p></li>
</ul>


<p>注意：从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。</p>

<h1>管道的结构</h1>

<p>在Linux中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个file结构指向同一个临时的VFS索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。如图 7.1所示。</p>

<p><img src="/images/2013/8/pipe/struct.png" alt=" struct " /></p>

<p>图7.1中有两个 file 数据结构，但它们定义文件操作例程地址是不同的，其中一个是向管道中写入数据的例程地址，而另一个是从管道中读出数据的例程地址。这样，用户程序的系统调用仍然是通常的文件操作，而内核却利用这种抽象机制实现了管道这一特殊操作。</p>

<h1>管道的读写</h1>

<p>管道实现的源代码在fs/pipe.c中，在pipe.c中有很多函数，其中有两个函数比较重要，即管道读函数pipe_read()和管道写函数pipe_wrtie()。管道写函数通过将字节复制到 VFS 索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，内核必须利用一定的机制同步对管道的访问，为此，内核使用了锁、等待队列和信号。</p>

<p>当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的 file 结构。file结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p>

<ul>
<li>内存中有足够的空间可容纳所有要写入的数据；</li>
<li>内存没有被读程序锁定。</li>
</ul>


<p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p>

<p>管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。</p>

<h1>CU上的问题</h1>

<h2>popkart718的提问</h2>

<p><img src="/images/2013/8/pipe/sync.jpg" alt=" sync " /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下c语言获取网络接口IP地址]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/19/linuxxia-cyu-yan-huo-qu-wang-luo-jie-kou-ipdi-zhi/"/>
    <updated>2013-07-19T22:34:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/19/linuxxia-cyu-yan-huo-qu-wang-luo-jie-kou-ipdi-zhi</id>
    <content type="html"><![CDATA[<p>在Linux环境下，可以使用以下的代码获取网络的ip地址：
```</p>

<pre><code>if (gethostname(host, sizeof(host)) &lt; 0) {
    printf("Can't get hostname\n");
    return -1;
}
if ((hp = gethostbyname(host)) == NULL) {
    printf("Can't get host address\n");
    return -1;
}
memcpy((char *) &amp;intaddr, (char *) hp-&gt;h_addr_list[0],
        (size_t) hp-&gt;h_length);
</code></pre>

<p>```</p>

<!--more-->


<p>在嵌入式系统中，使用goahead的时候， 以上代码是获取不到正确ip地址的，我们可以结合以下两个接口函数去获取需要的ip地址：
```</p>

<pre><code>#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;net/if.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;


static int getIfaceName(char *iface_name, int len)
{
    int r = -1;
    int flgs, ref, use, metric, mtu, win, ir;
    unsigned long int d, g, m;    
    char devname[20];
    FILE *fp = NULL;

    if((fp = fopen("/proc/net/route", "r")) == NULL) {
        perror("fopen error!\n");
        return -1;
    }

    if (fscanf(fp, "%*[^\n]\n") &lt; 0) {
        fclose(fp);
        return -1;
    }

    while (1) {
        r = fscanf(fp, "%19s%lx%lx%X%d%d%d%lx%d%d%d\n",
                 devname, &amp;d, &amp;g, &amp;flgs, &amp;ref, &amp;use,
                 &amp;metric, &amp;m, &amp;mtu, &amp;win, &amp;ir);
        if (r != 11) {
            if ((r &lt; 0) &amp;&amp; feof(fp)) {
                break;
            }
            continue;
        }

        strncpy(iface_name, devname, len);
        fclose(fp);
        return 0;
    }

    fclose(fp);

    return -1;
}

static int getIpAddress(char *iface_name, char *ip_addr, int len)
{
    int sockfd = -1;
    struct ifreq ifr;
    struct sockaddr_in *addr = NULL;

    memset(&amp;ifr, 0, sizeof(struct ifreq));
    strcpy(ifr.ifr_name, iface_name);
    addr = (struct sockaddr_in *)&amp;ifr.ifr_addr;
    addr-&gt;sin_family = AF_INET;

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
        perror("create socket error!\n");
        return -1;
    }

    if (ioctl(sockfd, SIOCGIFADDR, &amp;ifr) == 0) {
        strncpy(ip_addr, inet_ntoa(addr-&gt;sin_addr), len);
        close(sockfd);
        return 0;
    }

    close(sockfd);

    return -1;
}

int main(int argc, char** argv)
{
    struct in_addr    intaddr;
    char iface_name[20];

    if(getIfaceName(iface_name, sizeof(iface_name)) &lt; 0) {
        printf("get interface name error!\n");
        return -1;
    }

    if(getIpAddress(iface_name, (char *) &amp;intaddr, 15) &lt; 0) {
        printf("get interface ip address error!\n");
        return -1;
    }

    printf("address:%s\n",(char *) &amp;intaddr);

    return 0;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用libevent编写Linux服务]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/18/shi-yong-libeventbian-xie-linuxfu-wu/"/>
    <updated>2013-07-18T19:01:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/18/shi-yong-libeventbian-xie-linuxfu-wu</id>
    <content type="html"><![CDATA[<p>libevent是一个事件触发的网络库，适用于windows、linux、bsd等多种平台，内部使用select、epoll、kqueue等系统调用管理事件机制，著名分布式缓存软件memcached也使用到了该库。</p>

<h1>初始化事件</h1>

<p>首先完成对libenvent的事件初始化和事件驱动模型的选择。在使用多线程的情况下，一般我们需获取所返回的事件根基。
<code>
main_base = event_init();
</code>
event_init函数返回的是一个event_base对象，该对象包括了事件处理过程中的一些全局变量，其结构为：
```
struct event_base {</p>

<pre><code>const struct eventop *evsel;
void *evbase;
int event_count;        /* counts number of total events */
int event_count_active; /* counts number of active events */
int event_gotterm;      /* Set to terminate loop */
int event_break;        /* Set to terminate loop immediately */
/* active event management */
struct event_list **activequeues;
int nactivequeues;
/* signal handling info */
struct evsignal_info sig;
struct event_list eventqueue;
struct timeval event_tv;
struct min_heap timeheap;
struct timeval tv_cache;
</code></pre>

<p>};
```</p>

<!--more-->


<h1>添加事件</h1>

<p>事件初始化完毕后，可以使用event_set设置事件，然后使用event_add将其加入。首先完成socket的监听，然后将其加入到事件队列中（这里对所有的异常都不做考虑）。</p>

<p>（1）socket监听
```
struct sockaddr_in listen_addr;</p>

<p>int port = 10000; //socket监听端口
int listen_fd = socket(AF_INET, SOCK_STREAM, 0);</p>

<p>memset(&amp;listen_addr, 0, sizeof(listen_addr));</p>

<p>listen_addr.sin_family = AF_INET;
listen_addr.sin_addr.s_addr = INADDR_ANY;
listen_addr.sin_port = htons(port)</p>

<p>reuseaddr_on = 1;</p>

<p>/<em>支持端口复用</em>/
setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr_on, sizeof(reuseaddr_on));</p>

<p>bind(listen_fd, (struct sockaddr *) &amp;listen_addr, sizeof(listen_addr));
listen(listen_fd, 1024);</p>

<p>/<em>将描述符设置为非阻塞</em>/
int flags = fcntl(listen_fd,F_GETFL);
flags |= O_NONBLOCK;
fcntl(listen_fd, F_SETFL, flags);
```
（2）事件设置</p>

<p>socket服务建立后，就可以进行事件设置。使用event_set来设置事件对象，其传入参数包括事件根基(event_base对象)，描述符，事件类型，事件发生时的回调函数，回调函数传入参数。其中事件类型包括EV_READ、EV_WRITE、EV_PERSIST，EV_PERSIST和前两者结合使用，表示该事件为持续事件。
```
struct event ev;</p>

<p>event_set(&amp;ev, listen_fd, EV_READ | EV_PERSIST, accept_handle, (void *)&amp;ev);
```
（3）事件添加与删除</p>

<p>事件设置好后，就可以将其加入事件队列。event_add用来将事件加入，它接受两个参数：要添加的事件和时间的超时值。如果需要将事件删除，可以使用event_del来完成。event_del函数会取消所指定的事件。
<code>
event_add(&amp;ev, NULL)
</code></p>

<h1>进入事件循环</h1>

<p>libevent提供了多种方式来进入事件循环，常用的是event_dispatch和event_base_loop，前者最后实际是使用当前事件根基来调用event_base_loop。
<code>
event_base_loop(main_base, 0);
</code></p>

<h1>处理连接</h1>

<p>已经完成了事件的设置、事件的添加并进入到了事件循环，但是当事件发生时又如何处理呢？ 当连接建立时回调函数accept_handle会自动的得到调用。对于缓冲区的读写在非阻塞式网络编程中是一个难以处理的问题，幸运的是libevent提供了bufferevent和evbuf来替我们完成该项工作。这里我们采用bufferevent来处理。</p>

<p>（1）生成bufferevent对象</p>

<p>使用bufferevent_new对象来生成bufferevent对象，并分别指定读、写、连接错误时的处理函数和函数传入参数。</p>

<p>（2）设置读取量</p>

<p>bufferevent的读事件激活以后，即使用户没有读取完bufferevent缓冲区中的数据, bufferevent读事件也不会再次被激活。因为bufferevent的读事件是由其所监控的描述符的读事件激活的，只有描述符可读，读事件才会被激活。可通过设置wm_read.high来控制bufferevent从描述符缓冲区中读取的数据量。</p>

<p>（3）将事件加入事件队列</p>

<p>和前面一样，在事件设置好后，需将事件加入到事件队列中， 不过bufferevent的有自己专门的加入函数bufferevent_base_set和激活函数bufferevent_enable。bufferevent接收两个参数事件根基和事件对象，前者用来指定事件将加入到哪个事件根基中，后者说明需将那个bufferevnet事件加入。在bufferevent初始化完毕后，可以使用bufferevent_enable和bufferevent_disable反复的激活与禁止事件，其接收参数为事件对象和事件标志。其中标志参数为EV_READ和EV_WRITE。
```
void accept_handle(const int sfd, const short event, void *arg)
{</p>

<pre><code>struct sockaddr_in addr;

socklen_t addrlen = sizeof(addr);

int fd = accept(sfd, (struct sockaddr *) &amp;addr, &amp;addrlen); //处理连接

buf_ev = bufferevent_new(fd,   buffered_on_read, NULL, NULL, fd)
buf_ev-&gt;wm_read.high = 4096
bufferevent_base_set(main_base, buf_ev);
bufferevent_enable(buf_ev, EV_READ);
</code></pre>

<p>}
```</p>

<h1>读取缓冲区</h1>

<p>当缓冲区读就绪时会自动激活前面注册的缓冲区读函数，我们可以使用bufferevent_read函数来读取缓冲区，bufferevent_read函数参数分别为:所需读取的事件缓冲区，读入数据的存放地，希望读取的字节数。函数返回实际读取的字节数。注意：即时缓冲区未读完，事件也不会再次被激活（除非再次有数据）。因此此处需反复读取直到全部读取完毕。</p>

<h1>写回客户端</h1>

<p>bufferevent系列函数不但支持读取缓冲区，而且支持写缓冲区（即将结果返回给客户端）。
```
void buffered_on_read(struct bufferevent *bev, void * arg){</p>

<pre><code>char buffer[4096]

ret = bufferevent_read(bev, &amp;buffer, 4096);
bufferevent_write(bef, (void *)&amp;buffer, 4096);
</code></pre>

<p>}
```</p>

<h1>异步事件处理示例</h1>

<p>利用libevent编写服务端程序，主要有4部分。
（1）创建主通知链base
<code>
base = event_base_new();
</code>
（2）创建要监听的事件，并将其加入到主通知链中。
<code>
listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void*)base);
event_add(listener_event, NULL);
event_free( listener_event ); //释放由event_new申请的结构体
</code>
（3）主循环
<code>
event_base_dispatch(base);
</code>
（4）释放
<code>
event_base_free(base);
</code>
以下程序中do_read, do_write是异步的，为了解决了异步之间的问题，程序使用了state这个结构体变量将do_read和do_write联系起来。
```</p>

<pre><code>#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;event2/event.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;

#define MAX_LINE 16384
#define PORT 9999

void do_read(evutil_socket_t fd, short events, void *arg);
void do_write(evutil_socket_t fd, short events, void *arg);

struct fd_state {
    char buffer[MAX_LINE];
    size_t buffer_used;

    size_t n_written;
    size_t write_upto;

    struct event *read_event;
    struct event *write_event;
};

struct fd_state *alloc_fd_state(struct event_base *base, evutil_socket_t fd)
{
    struct fd_state *state =
     (struct fd_state *)malloc(sizeof(struct fd_state));
    if (!state) {
        return NULL;
    }

    state-&gt;read_event =
     event_new(base, fd, EV_READ | EV_PERSIST, do_read, state);
    if (!state-&gt;read_event) {
        free(state);
        return NULL;
    }

    state-&gt;write_event =
     event_new(base, fd, EV_WRITE | EV_PERSIST, do_write, state);
    if (!state-&gt;write_event) {
        event_free(state-&gt;read_event);
        free(state);
        return NULL;
    }

    assert(state-&gt;write_event);

    return state;
}

void free_fd_state(struct fd_state *state)
{
    event_free(state-&gt;read_event);
    event_free(state-&gt;write_event);
    free(state);
}

void do_read(evutil_socket_t fd, short events, void *arg)
{
    struct fd_state *state = arg;
    char buf[1024];
    int i;
    ssize_t result;
    while (1) {
        // assert(state-&gt;write_event);
        result = recv(fd, buf, sizeof(buf), 0);
        if (result &lt;= 0)
            break;
        printf("[%s][%d]buf=[%s]len=[%d]\n", __FILE__, __LINE__, buf,
         result);
    }

    memcpy(state-&gt;buffer, "reply", sizeof("reply"));
    assert(state-&gt;write_event);
    event_add(state-&gt;write_event, NULL);
    state-&gt;write_upto = state-&gt;buffer_used;

    if (result == 0) {
        free_fd_state(state);
    } else if (result &lt; 0) {
        if (errno == EAGAIN)    // XXXX use evutil macro
            return;
        perror("recv");
        free_fd_state(state);
    }
}

void do_write(evutil_socket_t fd, short events, void *arg)
{
    struct fd_state *state = arg;

    //while (state-&gt;n_written &lt; state-&gt;write_upto)
    {
        //ssize_t result = send(fd, state-&gt;buffer + state-&gt;n_written,
        //state-&gt;write_upto - state-&gt;n_written, 0);
        ssize_t result =
         send(fd, state-&gt;buffer, strlen(state-&gt;buffer), 0);
        if (result &lt; 0) {
            if (errno == EAGAIN)    // XXX use evutil macro
                return;
            free_fd_state(state);
            return;
        }
        assert(result != 0);
        state-&gt;n_written += result;
    }

    //if (state-&gt;n_written == state-&gt;buffer_used)
    {
        state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = 1;
    }

    event_del(state-&gt;write_event);
}

void do_accept(evutil_socket_t listener, short event, void *arg)
{
    struct event_base *base = arg;
    struct sockaddr_storage ss;
    socklen_t slen = sizeof(ss);

    int fd = accept(listener, (struct sockaddr *)&amp;ss, &amp;slen);
    if (fd &lt; 0) {        // XXXX eagain??
        perror("accept");
    } else if (fd &gt; FD_SETSIZE) {
        close(fd);    // XXX replace all closes with EVUTIL_CLOSESOCKET */
    } else {
        struct fd_state *state;
        evutil_make_socket_nonblocking(fd);
        state = alloc_fd_state(base, fd);

        assert(state);    /*XXX err */
        assert(state-&gt;write_event);
        event_add(state-&gt;read_event, NULL);
    }
}

int main(int argc, char **argv)
{
    evutil_socket_t listener;
    struct sockaddr_in sin;
    struct event_base *base;
    struct event *listener_event;

    setvbuf(stdout, NULL, _IONBF, 0);

    base = event_base_new();
    if (!base)
        return -1;        /*XXXerr */

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(PORT);

    listener = socket(AF_INET, SOCK_STREAM, 0);
    evutil_make_socket_nonblocking(listener);

#ifndef WIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one,
             sizeof(one));
    }
#endif

    if (bind(listener, (struct sockaddr *)&amp;sin, sizeof(sin)) &lt; 0) {
        perror("bind");
        return -1;
    }

    if (listen(listener, 16) &lt; 0) {
        perror("listen");
        return -1;
    }

    listener_event =
     event_new(base, listener, EV_READ | EV_PERSIST, do_accept,
         (void *)base);
    /*XXX check it */
    event_add(listener_event, NULL);
    event_base_dispatch(base);
    event_base_free(base);

    return 0;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链栈]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/15/lian-zhan/"/>
    <updated>2013-07-15T21:49:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/15/lian-zhan</id>
    <content type="html"><![CDATA[<p>栈是限制在表的一端进行插入和删除运算的线性表。通常称插入、删除的这一端为栈顶，另一端称为栈底；当表中没有元素时称为空栈；栈为后进先出的线性表，简称为LIFO表；栈的修改是按后进先出的原则进行；每次删除的总是当前栈中最新的元素（即最后插入的元素），而最先插入的被放在栈的底部，要到最后才能删除。</p>

<h1>链栈结点</h1>

<p>出栈与入栈是栈的最主要操作，当无法预见栈所需大小时，往往需要采用链栈的方式。在链栈中，不需要像单链表一样需要头结点。链栈的结构如下图所示：</p>

<p><img src="/images/2013/7/lian-zhan/stacknode.png" alt=" stacknode " /></p>

<p>可将其结构定义为：
```</p>

<pre><code>typedef char SElemType

typedef struct StackNode
{
    SElemType data;//根据实际需要定义数据类型
    struct StackNode *next;
}StackNode,*LinkStackPtr;

typedef struct LinkStack
{
    LinkStackPtr top;//指向栈链顶部
    int count;//用以判断栈是否为空，可初始化为0
}LinkStack;
</code></pre>

<p>```</p>

<!--more-->


<h1>进栈</h1>

<p>能够进栈的前提是已成功建立栈空间。进栈函数所需的参数主要是指向栈顶的指针和入栈的内容，因此可定义为：
<code>
int Push(LinkStack *pS, SElemType e);
</code>
进栈操作的过程如下图所示:</p>

<p><img src="/images/2013/7/lian-zhan/stackpush.png" alt=" stackpush " /></p>

<p>Step1：开辟内存，将需要入栈的元素压入栈；
<code>
LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
s-&gt;data = e;
</code>
Step2：更改指针；
<code>
s-&gt;next = pS-&gt;top; //新结点的next指向原来栈顶
pS-&gt;top = s; //链栈新的top指针指向新建立的结点
</code>
Step3：更改栈状态（累计入栈元素个数）。
<code>
pS-&gt;count++;
</code></p>

<h1>出栈</h1>

<p>出栈之前需要判断当前栈的状态，如果栈元素个数为零，则是空栈，无法进行出栈操作。出栈操作函数同样需要两个参数，一是指向链栈的指针，二是弹出的栈元素，因此定义为：
<code>
int Pop(LinkStackPtr *pS, SElemType *e); //之所以是*e，是为了在函数结束后可以取得该弹出元素
</code>
出栈操作过程如下图所示：</p>

<p><img src="/images/2013/7/lian-zhan/stackpop.png" alt=" stackpop " /></p>

<p>Step1：获取弹出元素；
<code>
*e = pS-&gt;top-&gt;data;
</code>
Step2：top指针指向栈顶；
<code>
p = pS-&gt;top ;
pS-&gt;top = p-&gt;next;//LinkStackPtr p;
</code>
Step3：释放结点；
<code>
free(p);
</code>
Step4：更改栈状态。
<code>
pS-&gt;count--;
</code></p>

<h1>测试程序</h1>

<p>```</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

typedef char SElemType;

typedef struct StackNode {
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStackPtr;

typedef struct LinkStack {
    LinkStackPtr top;
    int count;
} LinkStack;

void InitialStack(LinkStack * L)
{
    L-&gt;top = NULL;
    L-&gt;count = 0;

    return;
}

int StackEmpty(LinkStack * pS)
{
    return (!pS-&gt;count);
}

int Push(LinkStack * pS, SElemType e)
{
    LinkStackPtr s = (LinkStackPtr) malloc(sizeof(StackNode));
    if(s == NULL) {
        printf("no enough memory!\n");
        return -1;
    }
    s-&gt;data = e;
    s-&gt;next = pS-&gt;top;
    pS-&gt;top = s;
    pS-&gt;count++;

    return 0;
}

int Pop(LinkStack * pS, SElemType * e)
{
    LinkStackPtr p = NULL;

    if (StackEmpty(pS)) {
        printf("stack is empty！\n");
        return 0;
    }

    *e = pS-&gt;top-&gt;data;
    p = pS-&gt;top;
    pS-&gt;top = p-&gt;next;
    free(p);
    pS-&gt;count--;

    return 0;
}

void PrintStackLink(LinkStack * pS)
{
    int i;
    LinkStackPtr L = NULL;

    L = pS-&gt;top;
    if (StackEmpty(pS)) {
        printf("stack is empty！\n");
        return;
    }

    for (i = 0; i &lt; (pS-&gt;count); i++) {
        printf("%c\n", L-&gt;data);
        L = L-&gt;next;
    }

    return;
}

int main(int argc, char **argv)
{
    char getch;
    char outch;
    LinkStack myStack;

    InitialStack(&amp;myStack);

    printf("请输入压入栈的数据（char型），输入#结束:\n");
    scanf("%c", &amp;getch);
    while (getch != '#') {
        Push(&amp;myStack, getch);
        scanf("%c", &amp;getch);
    }
    printf("栈链内容为：\n");
    PrintStackLink(&amp;myStack);

    while (!StackEmpty(&amp;myStack)) {
        Pop(&amp;myStack, &amp;outch);
        printf("弹出内容为：%c\n", outch);
    }
    PrintStackLink(&amp;myStack);

    return 0;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Base64编码解码算法]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/11/base64bian-ma-jie-ma-suan-fa/"/>
    <updated>2013-07-11T23:09:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/11/base64bian-ma-jie-ma-suan-fa</id>
    <content type="html"><![CDATA[<p>Base64使用ascii码子集的64个字符，即大小写的26个英文字母，0～9，＋，/。编码基于3个字符，每个字符用8位二进制表示，一共24位，再分为4四组，每组6位表示一个Base64值（例如0就是A，27就是b）。Base64值如下：
```</p>

<pre><code>'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
'w', 'x', 'y', 'z', '0', '1', '2', '3',
'4', '5', '6', '7', '8', '9', '+', '/',
</code></pre>

<p>```
如果被加密的字符串每3个一组，还剩1或2个字符，使用特殊字符"=&ldquo;补齐。例如编码只有2个字符“me”，m的ascii是109，e的是101，用二进制表示分别是01101101、01100101，连接起来就是0110110101100101，再按6位分为一组：011011、010110、010100（不足6位补0），ascii分别是27、22、 20，即Base64值为bWU，不足4字用＝补齐，因此bWU＝就me的Base64值。</p>

<!--more-->


<p>在<a href="https://github.com/dwjackson/basenc">这里</a>可以找到一个c语言的base32/base64开源库。以下是goahead中base64编码解码的实现：
```</p>

<pre><code>static char_t    map64[] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
    -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
    -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

static char_t    alphabet64[] = {
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1', '2', '3',
    '4', '5', '6', '7', '8', '9', '+', '/',
};

/*********************************** Code *************************************/
/*
 *    Decode a buffer from "string" and into "outbuf"
 */
int websDecode64(char_t *outbuf, char_t *string, int outlen)
{
    unsigned long    shiftbuf;
    char_t            *cp, *op;
    int                c, i, j, shift;

    op = outbuf;
    *op = '\0';
    cp = string;
    while (*cp &amp;&amp; *cp != '=') {
        /*
         *        Map 4 (6bit) input bytes and store in a single long (shiftbuf)
         */
        shiftbuf = 0;
        shift = 18;
        for (i = 0; i &lt; 4 &amp;&amp; *cp &amp;&amp; *cp != '='; i++, cp++) {
            c = map64[*cp &amp; 0xff];
            if (c == -1) {
                error(E_L, E_LOG, T("Bad string: %s at %c index %d"), string,
                      c, i);
                return -1;
            }
            shiftbuf = shiftbuf | (c &lt;&lt; shift);
            shift -= 6;
        }
        /*
         *        Interpret as 3 normal 8 bit bytes (fill in reverse order).
         *        Check for potential buffer overflow before filling.
         */
        --i;
        if ((op + i) &gt;= &amp;outbuf[outlen]) {
            gstrcpy(outbuf, T("String too big"));
            return -1;
        }
        for (j = 0; j &lt; i; j++) {
            *op++ = (char_t) ((shiftbuf &gt;&gt; (8 * (2 - j))) &amp; 0xff);
        }
        *op = '\0';
    }
    return 0;
}

/******************************************************************************/
/*
 *    Encode a buffer from "string" into "outbuf"
 */
void websEncode64(char_t *outbuf, char_t *string, int outlen)
{
    unsigned long    shiftbuf;
    char_t            *cp, *op;
    int                x, i, j, shift;

    op = outbuf;
    *op = '\0';
    cp = string;
    while (*cp) {
        /*
         *        Take three characters and create a 24 bit number in shiftbuf
         */
        shiftbuf = 0;
        for (j = 2; j &gt;= 0 &amp;&amp; *cp; j--, cp++) {
            shiftbuf |= ((*cp &amp; 0xff) &lt;&lt; (j * 8));
        }
        /*
         *        Now convert shiftbuf to 4 base64 letters. The i,j magic calculates
         *        how many letters need to be output.
         */
        shift = 18;
        for (i = ++j; i &lt; 4 &amp;&amp; op &lt; &amp;outbuf[outlen] ; i++) {
            x = (shiftbuf &gt;&gt; shift) &amp; 0x3f;
            *op++ = alphabet64[(shiftbuf &gt;&gt; shift) &amp; 0x3f];
            shift -= 6;
        }
        /*
         *        Pad at the end with '='
         */
        while (j-- &gt; 0) {
            *op++ = '=';
        }
        *op = '\0';
    }
}
</code></pre>

<p>```</p>

<p>Linux提供了命令行方式的base64编码和解码。</p>

<ul>
<li>将字符串str+换行 编码为base64字符串输出。
<code>
  $ echo "str" | base64
</code></li>
<li>将字符串str编码为base64字符串输出。
<code>
  $ echo -n "str" | base64
</code></li>
<li>从指定的文件file中读取数据，编码为base64字符串输出。
<code>
  $ base64 file
</code></li>
<li>从标准输入中读取已经进行base64编码的内容，解码输出。
<code>
  $ base64 -d
</code></li>
<li>从标准输入中读取已经进行base64编码的内容，解码输出。加上-i参数，忽略非字母表字符，比如换行符。
<code>
  $ base64 -d -i
</code></li>
<li>将base64编码的字符串str+换行 解码输出。
<code>
  $ echo "str" | base64 -d
</code></li>
<li>将base64编码的字符串str解码输出。
<code>
  $ echo -n "str" | base64 -d
</code></li>
<li>从指定的文件file中读取base64编码的内容，解码输出。
<code>
  $ base64 -d file
</code></li>
</ul>

]]></content>
  </entry>
  
</feed>

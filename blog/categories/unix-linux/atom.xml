<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Unix/Linux | 残剑]]></title>
  <link href="http://txgcwm.github.io/blog/categories/unix-linux/atom.xml" rel="self"/>
  <link href="http://txgcwm.github.io/"/>
  <updated>2013-08-02T01:07:35+08:00</updated>
  <id>http://txgcwm.github.io/</id>
  <author>
    <name><![CDATA[残剑]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux管道的实现机制]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/02/linuxguan-dao-de-shi-xian-ji-zhi/"/>
    <updated>2013-08-02T00:24:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/02/linuxguan-dao-de-shi-xian-ji-zhi</id>
    <content type="html"><![CDATA[<p>在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现为：</p>

<ul>
<li><p>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不像文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。</p></li>
<li><p>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</p></li>
</ul>


<p>注意：从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。</p>

<!--more-->


<h1>管道的结构</h1>

<p>在Linux中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个file结构指向同一个临时的VFS索引节点，而这个VFS索引节点又指向一个物理页面而实现的。如下图所示。</p>

<p><img src="/images/2013/8/pipe/struct.png" alt=" struct " /></p>

<p>图中有两个file数据结构，但它们定义文件操作例程地址是不同的，其中一个是向管道中写入数据的例程地址，而另一个是从管道中读出数据的例程地址。这样，用户程序的系统调用仍然是通常的文件操作，而内核却利用这种抽象机制实现了管道这一特殊操作。</p>

<h1>管道的读写</h1>

<p>管道实现的源代码在fs/pipe.c中，在pipe.c中有很多函数，其中有两个函数比较重要，即管道读函数pipe_read()和管道写函数pipe_wrtie()。管道写函数通过将字节复制到VFS索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，内核必须利用一定的机制同步对管道的访问，为此，内核使用了锁、等待队列和信号。</p>

<p>当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的file结构。file结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查VFS索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p>

<ul>
<li>内存中有足够的空间可容纳所有要写入的数据；</li>
<li>内存没有被读程序锁定。</li>
</ul>


<p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在VFS索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p>

<p>管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。</p>

<h1>CU上的问题</h1>

<h2>popkart718的提问</h2>

<p>《Unix环境高级编程》403页中部分描述如下：</p>

<p><img src="/images/2013/8/pipe/sync.jpg" alt=" sync " /></p>

<p>明明是两个管道，为什么read的时候会发生阻塞呢？</p>

<h2>解答</h2>

<p>read依赖于管道的打开模式，打开管道时可使用pipe2设定相应的flags。书上所写的阻塞是在管道中没有数据的情况下发生的。
```</p>

<pre><code>   int pipe2(int pipefd[2], int flags);
</code></pre>

<p>DESCRIPTION</p>

<pre><code>   pipe()  creates  a  pipe, a unidirectional data channel that can be used for interprocess communication.  The array pipefd is used to return
   two file descriptors referring to the ends of the pipe.  pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of
   the  pipe.  Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe.  For further
   details, see pipe(7).

   If flags is 0, then pipe2() is the same as pipe().  The following values can be bitwise ORed in flags to obtain different behavior:

   O_NONBLOCK  Set the O_NONBLOCK file status flag on the two new open file descriptions.  Using this flag saves extra  calls  to  fcntl(2)  to
               achieve the same result.

   O_CLOEXEC   Set  the  close-on-exec  (FD_CLOEXEC) flag on the two new file descriptors.  See the description of the same flag in open(2) for
               reasons why this may be useful.
</code></pre>

<p>```
同时也可以查看内核文件fs/pipe.c中的pipe_read函数实现。以下是简单的测试程序。</p>

<p>测试一：使用pipe2且传入参数的flags为0（相当于使用pipe）
```</p>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;signal.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int fd[2];</p>

<p>void handle(int sig)
{</p>

<pre><code>if (sig == SIGUSR1)
    write(fd[1], "p", 1);
</code></pre>

<p>}</p>

<p>int main(int argc, char **argv)
{</p>

<pre><code>char c;
pid_t pid;

if (pipe2(fd, 0) &lt; 0) {
    printf("can not creat pipe!\n");
    return -1;
}

if ((pid = fork()) &lt; 0) {
    printf("can not fork!\n");
    return -1;
} else if (pid &gt; 0) {
    close(fd[0]);
    signal(SIGUSR1, handle);
    for (;;) {
    }
} else {
    close(fd[1]);
    for (;;) {
        if (read(fd[0], &amp;c, 1) == 1)
            printf("c:%c\n", c);
        else
            printf("nothing to read!\n");

        sleep(2);
    }
}

return 0;
</code></pre>

<p>}
```
编译后，可以看到程序阻塞在那里，当使用“kill -10 进程号”时，才会从管道中读出数据。</p>

<p>测试二：使用pipe2时设置flags的参数为O_NONBLOCK
```</p>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;sys/stat.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;signal.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int fd[2];</p>

<p>void handle(int sig)
{</p>

<pre><code>if (sig == SIGUSR1)
    write(fd[1], "p", 1);
</code></pre>

<p>}</p>

<p>int main(int argc, char **argv)
{</p>

<pre><code>char c;
pid_t pid;

if (pipe2(fd, O_NONBLOCK) &lt; 0) {
    printf("can not creat pipe!\n");
    return -1;
}

if ((pid = fork()) &lt; 0) {
    printf("can not fork!\n");
    return -1;
} else if (pid &gt; 0) {
    close(fd[0]);
    signal(SIGUSR1, handle);
    for (;;) {
    }
} else {
    close(fd[1]);
    for (;;) {
        if (read(fd[0], &amp;c, 1) == 1)
            printf("c:%c\n", c);
        else
            printf("nothing to read!\n");

        sleep(2);
    }
}

return 0;
</code></pre>

<p>}
```
编译后，执行程序可以看到它不停的打印消息，若管道内没有数据的话，read就直接返回了。</p>

<h1>参考文章</h1>

<p><a href="http://oss.org.cn/kernel-book/ch07/7.1.1.htm">Linux管道的实现机制</a>
<a href="http://bbs.chinaunix.net/thread-4069374-1-1.html">进程通信管道问题</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux的硬链接与软链接]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/29/linuxde-ying-lian-jie-yu-ruan-lian-jie/"/>
    <updated>2013-07-29T23:37:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/29/linuxde-ying-lian-jie-yu-ruan-lian-jie</id>
    <content type="html"><![CDATA[<p>文件有文件名与数据，这在Linux上被分成两个部分：用户数据(user data)与元数据(metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在Linux中，元数据中的inode号（inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过inode号寻找正确的文件数据块。下图展示了程序通过文件名获取文件内容的过程。</p>

<p><img src="/images/2013/7/link/file.png" alt=" file " /></p>

<p>为解决文件的共享使用，Linux系统引入了两种链接：硬链接(hard link)与软链接（又称符号链接，即soft link或symbolic link）。链接为Linux系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名。</p>

<p><img src="/images/2013/7/link/access.png" alt=" access " /></p>

<!--more-->


<h1>硬链接</h1>

<p>硬链接可由命令link或ln创建。如下是对文件oldfile创建硬链接。
<code>
link oldfile newfile
ln oldfile newfile
</code>
由于硬链接是有着相同inode号仅文件名不同的文件，因此硬链接存在以下几点特性：</p>

<ul>
<li>文件有相同的inode及data block；</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能交叉文件系统进行硬链接的创建；</li>
<li>不能对目录进行创建，只可对文件创建；</li>
<li>删除一个硬链接文件并不影响其它有相同inode号的文件。
```
$ ls -li
total 0</li>
</ul>


<p>// 只能对已存在的文件创建硬连接
$ link old.file hard.link
link: cannot create link <code>hard.link' to</code>old.file': No such file or directory</p>

<p>$ echo &ldquo;This is an original file&rdquo; > old.file
$ cat old.file
This is an original file
$ stat old.file
  File: `old.file'
  Size: 25          Blocks: 8          IO Block: 4096   regular file
Device: 807h/2055d  Inode: 796901      Links: 1
Access: (0664/-rw-rw-r&mdash;)  Uid: ( 1000/  txgcwm)   Gid: ( 1000/  txgcwm)
Access: 2013-07-29 23:57:49.435157205 +0800
Modify: 2013-07-29 23:57:27.295157688 +0800
Change: 2013-07-29 23:57:27.295157688 +0800
 Birth: &ndash;</p>

<p>// 文件有相同的inode号以及data block
$ link old.file hard.link | ls -li
total 8
796901 -rw-rw-r&mdash; 2 txgcwm txgcwm 25 Jul 29 23:57 hard.link
796901 -rw-rw-r&mdash; 2 txgcwm txgcwm 25 Jul 29 23:57 old.file</p>

<p>// 不能交叉文件系统
$ sudo ln /dev/input/event5 /root/bfile.txt
[sudo] password for txgcwm:
ln: failed to create hard link <code>/root/bfile.txt' =&gt;</code>/dev/input/event5': Invalid cross-device link</p>

<p>// 不能对目录进行创建硬连接
$ mkdir -p old.dir/test
$ ln old.dir/ hardlink.dir
ln: `old.dir/&lsquo;: hard link not allowed for directory
<code>
文件old.file与hard.link有着相同的inode号（796901）及文件权限，inode是随着文件的存在而存在，因此只有当文件存在时才可创建硬链接，即当inode存在且链接计数器（link count）不为0时。inode号仅在各文件系统下是唯一的，当Linux挂载多个文件系统后将出现inode号重复的现象，因此硬链接创建时不可跨文件系统。设备文件目录/dev使用的文件系统是devtmpfs，而/home（与根目录/一致）使用的是磁盘文件系统ext4。以下使用命令df查看当前系统中挂载的文件系统类型、各文件系统inode使用情况及文件系统挂载点。
</code>
$ sudo df -i &mdash;print-type
Filesystem     Type      Inodes  IUsed   IFree IUse% Mounted on
/dev/sda5      ext4     1250928  63404 1187524    6% /
udev           devtmpfs  211313    603  210710    1% /dev
tmpfs          tmpfs     215180    566  214614    1% /run
none           tmpfs     215180      3  215177    1% /run/lock
none           tmpfs     215180      9  215171    1% /run/shm
none           tmpfs     215180     23  215157    1% /run/user
/dev/sda6      ext4       62464    355   62109    1% /boot
/dev/sda7      ext4     1250928  91579 1159349    8% /home
/dev/sda11     ext4     2501856 336584 2165272   14% /srv
/dev/sda12     ext4     1875968 144226 1731742    8% /opt
/dev/sda8      ext4      249984    132  249852    1% /tmp
/dev/sda9      ext4     1250928 584616  666312   47% /usr
/dev/sda10     ext4      249984  24565  225419   10% /var</p>

<p>$ sudo find / -inum 1114
/lib/modules/3.5.0-25-generic/kernel/drivers/hwmon/mcp3021.ko
/sys/devices/LNXSYSTM:00/device:00/PNP0A08:00/device:02/PNP0C02:00/power/autosuspend_delay_ms
<code>
值得一提的是，Linux系统存在inode号被用完但磁盘空间还有剩余的情况。硬链接不能对目录创建是受限于文件系统的设计。现Linux文件系统中的目录均隐藏了两个特殊的目录：当前目录（.）与父目录（..）。查看这两个特殊目录的inode号可知其实这两目录就是两个硬链接（注意目录/lost+found/的inode号）。若系统允许对目录创建硬链接，则会产生目录环。
</code>
$ sudo ls -aliF /lost+found
total 20
11 drwx&mdash;&mdash;&mdash;  2 root root 16384 Nov 11  2012 ./
 2 drwxr-xr-x 23 root root  4096 Jul  7 13:47 ../</p>

<p>$ sudo stat /lost+found/
  File: `/lost+found/&lsquo;
  Size: 16384       Blocks: 32         IO Block: 4096   directory
Device: 805h/2053d  Inode: 11          Links: 2
Access: (0700/drwx&mdash;&mdash;&mdash;)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2013-07-30 00:10:47.479140197 +0800
Modify: 2012-11-11 00:50:27.000000000 +0800
Change: 2012-11-11 00:50:27.000000000 +0800
 Birth: &ndash;
```</p>

<h1>软链接</h1>

<p>软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的inode号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：</p>

<ul>
<li>软链接有自己的文件属性及权限等；</li>
<li>可对不存在的文件或目录创建软链接；</li>
<li>软链接可交叉文件系统；</li>
<li>软链接可对文件或目录创建；</li>
<li>创建软链接时，链接计数 i_nlink 不会增加；</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。
```
$ ls -li
total 0</li>
</ul>


<p>// 可对不存在的文件创建软链接
$ ln -s old.file soft.link
$ ls -liF
total 0
796810 lrwxrwxrwx 1 txgcwm txgcwm 8 Jul 30 00:25 soft.link &ndash;> old.file</p>

<p>// 由于被指向的文件不存在，此时的软链接 soft.link 就是死链接
$ cat soft.link
cat: soft.link: No such file or directory</p>

<p>// 创建被指向的文件 old.file，soft.link 恢复成正常的软链接
$ echo &ldquo;This is an original file_A&rdquo; >> old.file
$ cat soft.link
This is an original file_A</p>

<p>// 对不存在的目录创建软链接
$ ln -s old.dir soft.link.dir
$ mkdir -p old.dir/test
$ tree . -F &mdash;inodes
.
├── [ 796834]  old.dir/
│   └── [ 796851]  test/
├── [ 796830]  old.file
├── [ 796830]  soft.link &ndash;> old.file
└── [ 796834]  soft.link.dir &ndash;> old.dir/</p>

<p>3 directories, 2 files
```</p>

<h1>参考文章</h1>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">理解Linux的硬链接与软链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux操作系统下的MAN命令]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/27/linuxcao-zuo-xi-tong-xia-de-manming-ling/"/>
    <updated>2013-07-27T13:27:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/27/linuxcao-zuo-xi-tong-xia-de-manming-ling</id>
    <content type="html"><![CDATA[<p>Unix/Linux下的man命令可以查询常用的命令和函数。可是只知道用“man 函数名”来查询会遇到很多问题，比如<code>man read</code>，想看的是ANSI C中stdio的read函数原型和说明，出来的却是BASH命令的说明。这是怎么回事呢？原来read本身是man命令的一个参数，这样就会以为你要使用read的功能，而不是查看read函数。那么要怎样查看read函数呢?可以使用<code>man 2 read</code>或者是<code>man 3 read</code>查看。</p>

<h1>分卷号</h1>

<p>以上指令的中间数字是什么意思呢？是man的分卷号，所有的手册页都属于一个特定的分卷号，用一个字符来表示。Linux下最通用的分卷号及其名称和说明如下表所示。</p>

<table>
<thead>
<tr>
<th>分卷号         </th>
<th>名称 </th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td> 用户命令     </td>
<td> 可由任何人启动  </td>
</tr>
<tr>
<td>2</td>
<td> 系统调用     </td>
<td> 由内核提供的函数  </td>
</tr>
<tr>
<td>3</td>
<td> 例程        </td>
<td> 库函数    </td>
</tr>
<tr>
<td>4</td>
<td> 设备        </td>
<td> /dev目录下的特殊文件   </td>
</tr>
<tr>
<td>5</td>
<td> 文件格式描述  </td>
<td> 例如/etc/passwd   </td>
</tr>
<tr>
<td>6</td>
<td> 游戏        </td>
<td> 略  </td>
</tr>
<tr>
<td>7</td>
<td> 杂项        </td>
<td> 例如宏命令包、惯例等  </td>
</tr>
<tr>
<td>8</td>
<td> 系统管理员工具</td>
<td> 只能由root启动  </td>
</tr>
<tr>
<td>9</td>
<td> 其他（Linux特定的）</td>
<td> 用来存放内核例行程序的文档  </td>
</tr>
<tr>
<td>n</td>
<td> 新文档           </td>
<td> 可能要移到更适合的领域  </td>
</tr>
<tr>
<td>o</td>
<td> 老文档           </td>
<td> 可能会在一段期限内保留  </td>
</tr>
<tr>
<td>l</td>
<td> 本地文档          </td>
<td> 与特定系统有关的  </td>
</tr>
</tbody>
</table>


<!--more-->


<br></br>


<h1>常用参数和用法</h1>

<ul>
<li>打开所有领域内的同名帮助，例如man fam，首先会进入一个fam(1M)的命令版fam帮助，再按q键就会进入FAM(3X)，库函数版的帮助。
<code>
$ man -a cmd
</code></li>
<li>显示所有cmd的所有手册文件的路径，如<code>man -aw fam</code>指令。
<code>
$ man -aw cmd
</code></li>
<li>直接指定特定领域内搜索手册页，如<code>man 3 fam</code>直接进入库函数版的帮助。
<code>
$ man 领域代号 cmd
</code></li>
<li>指定手册文件的搜索路径，如<code>man -M /home/mysql/man mysql</code>显示的就是你安装的mysql的帮助，而不是系统自带的旧版mysql的帮助。
<code>
$ man -M cmd
</code></li>
<li>把man手册信息输出到文本文件。
<code>
$ man cmd | col -b &gt; cmd.txt
</code></li>
<li>查看特定语言版本的手册页，显示特定语言manpage文件的路径。
<code>
$ LANG=语言代号
$ man -w cmd
</code></li>
</ul>


<p>例如要查看mplayer的中文man路径：
<code>
$ LANG=en_US.UTF-8
$ man -w mplayer
/usr/share/man/zh/man1/mplayer.1.gz
</code></p>

<h1>配置文件/etc/man.config</h1>

<p>如果不想每次<code>man cmd</code>都要用<code>-M</code>指定路径，那么可以通过修改配置文件，添加内容如：</p>

<pre><code>MANPATH /home/mysql/man
</code></pre>

<p>man在各领域的搜索次序可以通过修改以下设置：</p>

<pre><code>MANSECT 1:8:2:3:4:5:6:7:9:tcl:n:l:p:o
</code></pre>

<p>不过，一般不推荐修改man的配置文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下iptables防火墙原理及使用]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/25/linuxxia-iptablesfang-huo-qiang-yuan-li-ji-shi-yong/"/>
    <updated>2013-07-25T23:36:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/25/linuxxia-iptablesfang-huo-qiang-yuan-li-ji-shi-yong</id>
    <content type="html"><![CDATA[<p>netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。iptables和netfilter的关系是一个很容易让人搞不清的问题：很多人知道iptables却不知道netfilter，其实iptables（位于/sbin目录下）只是Linux防火墙的管理工具而已，真正实现防火墙功能的是netfilter（它是Linux内核中实现包过滤的内部结构）。</p>

<h1>iptables传输数据包的过程</h1>

<p><img src="/images/2013/7/iptables/flow.png" alt=" flow " /></p>

<!--more-->


<ol>
<li>当一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的ip地址判断是否需要转送出去。</li>
<li>如果数据包就是进入本机的，它就会沿着上图所指方向向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过OUTPUT链，然后到达POSTROUTING链输出。</li>
<li>如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过FORWARD链，然后到达POSTROUTING链输出。</li>
</ol>


<h1>规则表和规则链</h1>

<p>iptables采用“表”和“链”的分层结构。表（tables）提供特定的功能，iptables内置了4个表，即Filter表、Nat表、Mangle表和Raw表，分别用于实现包过滤、网络地址转换、包重构(修改)和数据跟踪处理。链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包，否则iptables将继续检查下一条规则。如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。</p>

<p><img src="/images/2013/7/iptables/table.png" alt=" table " /></p>

<h2>规则表</h2>

<p>iptables有4个规则表，其之间的优先顺序为Raw&mdash;-Mangle&mdash;-Nat&mdash;-Filter。</p>

<ol>
<li><p>Filter表有三个链：INPUT、FORWARD、OUTPUT</p>

<p> 作用：过滤数据包<br/>
 内核模块：iptables_filter</p></li>
<li><p>Nat表有三个链：PREROUTING、POSTROUTING、OUTPUT</p>

<p> 作用：用于网络地址转换（IP、端口） <br/>
 内核模块：iptable_nat</p></li>
<li><p>Mangle表有五个链：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD</p>

<p> 作用：修改数据包的服务类型、TTL、并且可以配置路由实现QOS   <br/>
 内核模块：iptable_mangle</p></li>
<li><p>Raw表有两个链：OUTPUT、PREROUTING</p>

<p> 作用：决定数据包是否被状态跟踪机制处理<br/>
 内核模块：iptable_raw</p></li>
</ol>


<h2>规则链</h2>

<ol>
<li>INPUT——进来的数据包应用此规则链中的策略。</li>
<li>OUTPUT——外出的数据包应用此规则链中的策略。</li>
<li>FORWARD——转发数据包时应用此规则链中的策略。</li>
<li>PREROUTING——对数据包作路由选择前应用此链中的规则，所有的数据包进来的时侯都先由这个链处理。</li>
<li>POSTROUTING——对数据包作路由选择后应用此链中的规则，所有的数据包出来的时侯都先由这个链处理。</li>
</ol>


<p>规则链之间的优先顺序分三种情况：</p>

<ol>
<li><p>入站数据流向</p>

<p> 从外界到达防火墙的数据包，先被PREROUTING规则链处理（是否修改数据包地址等），之后会进行路由选择（判断该数据包应该发往何处），如果数据包的目标主机是防火墙本机（比如说Internet用户访问防火墙主机中的web服务器的数据包），那么内核将其传给INPUT链进行处理（决定是否允许通过等），通过以后再交给系统上层的应用程序（比如Apache服务器）进行响应。</p></li>
<li><p>转发数据流向</p>

<p> 来自外界的数据包到达防火墙后，首先被PREROUTING规则链处理，之后会进行路由选择，如果数据包的目标地址是其它外部地址（比如局域网用户通过网关访问QQ站点的数据包），则内核将其传递给FORWARD链进行处理（是否转发或拦截），然后再交给POSTROUTING规则链（是否修改数据包的地址等）进行处理。</p></li>
<li><p>出站数据流向</p>

<p> 防火墙本机向外部地址发送的数据包（比如在防火墙主机中测试公网DNS服务器时），首先被OUTPUT规则链处理，之后进行路由选择，然后传递给POSTROUTING规则链（是否修改数据包的地址等）进行处理。</p></li>
</ol>


<h1>管理和设置iptables规则</h1>

<p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p>

<p><img src="/images/2013/7/iptables/cmd.png" alt=" cmd " /></p>

<p><img src="/images/2013/7/iptables/filter.png" alt=" filter " /></p>

<h2>iptables的基本语法格式</h2>

<p>iptables [-t 表名] 命令选项 ［链名］ ［条件匹配］ ［-j 目标动作或跳转］</p>

<p>说明：表名、链名用于指定iptables命令所操作的表和链，命令选项用于指定管理iptables规则的方式（比如插入、增加、删除、查看等）；条件匹配用于指定对符合什么样条件的数据包进行处理；目标动作或跳转用于指定数据包的处理方式（比如允许通过、拒绝、丢弃、跳转给其它链处理）。</p>

<p>iptables命令的管理控制选项：
<code>
-A 在指定链的末尾添加（append）一条新的规则
-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除
-I 在指定链中插入（insert）一条新的规则，默认在第一行添加
-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换
-L 列出（list）指定链中所有的规则进行查看
-E 重命名用户定义的链，不改变链本身
-F 清空（flush）
-N 新建（new-chain）一条用户自己定义的规则链
-X 删除指定表中用户自定义的规则链（delete-chain）
-P 设置指定链的默认策略（policy）
-Z 将所有表的所有链的字节和数据包计数器清零
-n 使用数字形式（numeric）显示输出结果
-v 查看规则表详细信息（verbose）的信息
-V 查看版本(version)
-h 获取帮助（help）
</code></p>

<h2>防火墙处理数据包的四种方式</h2>

<ol>
<li>ACCEPT：允许数据包通过。</li>
<li>DROP：直接丢弃数据包，不给任何回应信息</li>
<li>REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息。</li>
<li>LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则。</li>
</ol>


<h2>防火墙规则的保存与恢复</h2>

<p>iptables-save把规则保存到文件中（生成保存规则的文件名为/etc/sysconfig/iptables），再由rc.d目录下的脚本（/etc/rc.d/init.d/iptables）自动装载。使用<code>iptables-save &gt; /etc/sysconfig/iptables</code>命令来保存规则，也可以用<code>service iptables save</code>指令把规则自动保存起来。当计算机启动时，rc.d下的脚本将用命令<code>iptables-restore</code>调用这个文件，从而就自动恢复了规则。</p>

<h2>防火墙常用策略</h2>

<ul>
<li><p>拒绝进入防火墙的所有ICMP协议数据包
<code>
  $ iptables -I INPUT -p icmp -j REJECT
</code></p></li>
<li><p>允许防火墙转发除ICMP协议以外的所有数据包，使用“！”可以将条件取反。
<code>
  $ iptables -A FORWARD -p ! icmp -j ACCEPT
</code></p></li>
<li><p>拒绝转发来自192.168.1.10主机的数据，允许转发来自192.168.0.0/24网段的数据。要把拒绝的放在前面，不然就不起作用了。
<code>
  $ iptables -A FORWARD -s 192.168.1.11 -j REJECT
  $ iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT
</code></p></li>
<li><p>丢弃从外网接口（eth1）进入防火墙本机的源地址为私网地址的数据包。
<code>
  $ iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP
  $ iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP
  $ iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP
</code></p></li>
<li><p>封堵网段（192.168.1.0/24），两小时后解封。这个策略可以借助crond计划任务来完成。
```
  $ iptables -I INPUT -s 10.20.30.0/24 -j DROP
  $ iptables -I FORWARD -s 10.20.30.0/24 -j DROP
  $ at now 2 hours at> iptables -D INPUT 1 at> iptables -D FORWARD 1</p>

<p>  [1]   Stopped     at now 2 hours
```</p></li>
<li><p>只允许管理员从202.13.0.0/16网段使用SSH远程登录防火墙主机。比较适合对设备进行远程管理时使用，比如位于分公司中的SQL服务器需要被总公司的管理员管理时。
<code>
  $ iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPT
  $ iptables -A INPUT -p tcp --dport 22 -j DROP
</code></p></li>
<li><p>允许本机开放从TCP端口20-1024提供的应用服务。
<code>
  $ iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPT
  $ iptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT
</code></p></li>
<li><p>允许转发来自192.168.0.0/24局域网段的DNS解析请求数据包。
<code>
  $ iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT
  $ iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT
</code></p></li>
<li><p>禁止其他主机ping防火墙主机，但是允许从防火墙上ping其他主机
<code>
  $ iptables -I INPUT -p icmp --icmp-type Echo-Request -j DROP
  $ iptables -I INPUT -p icmp --icmp-type Echo-Reply -j ACCEPT
  $ iptables -I INPUT -p icmp --icmp-type destination-Unreachable -j ACCEPT
</code></p></li>
<li><p>禁止转发来自MAC地址为00：0C：29：27：55：3F的主机的数据包。iptables中使用“-m 模块关键字”的形式调用显示匹配。这里用“-m mac &mdash;mac-source”来表示数据包的源MAC地址。
<code>
  $ iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP
</code></p></li>
<li><p>允许防火墙本机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-1280，这里用“-m multiport &mdash;dport”来指定目的端口及范围。
<code>
  $ iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT
</code></p></li>
<li><p>禁止转发源IP地址为192.168.1.20-192.168.1.99的TCP数据包。此处用“-m iprange &mdash;src-range”指定IP范围。
<code>
  $ iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP
</code></p></li>
<li><p>禁止转发与正常TCP连接无关的非&mdash;syn请求数据包。“-m state”表示数据包的连接状态，“NEW”表示与任何连接无关。
<code>
  $ iptables -A FORWARD -m state --state NEW -p tcp ! --syn -j DROP
</code></p></li>
<li><p>拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包。“ESTABLISHED”表示已经响应请求或者已经建立连接的数据包，“RELATED”表示与已建立的连接有相关性的，比如FTP数据连接等。
<code>
  $ iptables -A INPUT -p tcp -m state --state NEW -j DROP
  $ iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
</code></p></li>
<li><p>只开放本机的web服务（80）、FTP(20、21、20450-20480)，放行外部主机发住服务器其它端口的应答数据包，将其他入站数据包均予以丢弃处理。
<code>
  $ iptables -I INPUT -p tcp -m multiport --dport 20,21,80 -j ACCEPT
  $ iptables -I INPUT -p tcp --dport 20450:20480 -j ACCEPT
  $ iptables -I INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
  $ iptables -P INPUT DROP
</code></p></li>
</ul>


<h1>参考文章</h1>

<ul>
<li><a href="http://netfilter.org/">netfilter</a></li>
<li><a href="http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html">Iptables 指南 1.1.19</a>　</li>
<li><a href="http://blog.csdn.net/thmono/archive/2010/04/08/5462043.aspx">iptable 笔记</a></li>
<li><a href="http://netsecurity.51cto.com/art/200512/14457.htm">网络安全频道</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_40ba724c0100jz12.html">iptables_2</a></li>
<li><a href="http://qiliuping.blog.163.com/blog/static/1023829320105245337799/">netfilter/iptables全攻略</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[astyle格式化代码]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/24/astylege-shi-hua-dai-ma/"/>
    <updated>2013-07-24T18:36:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/24/astylege-shi-hua-dai-ma</id>
    <content type="html"><![CDATA[<p>astyle是一个开源工具，它可以方便的将代码格式化成自己想要的样式而不必人工修改。可以在终端下输入指令<code>sudo apt-get install astyle</code>安装，也可以到 <a href="http://astyle.sourceforge.net/">这里</a> 下载源码后自己编译安装。</p>

<p>下面介绍一下astyle的简单使用。例如有以下的源码：
```</p>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char **argv)
{int i;printf(&ldquo;Just a test!\n&rdquo;);for(i=0;i&lt;10;++i)printf(&ldquo;%d\n&rdquo;,i);}return 0;}
```</p>

<!--more-->


<p>然后在终端下输入以下指令：
<code>
$ astyle test1.c
</code>
效果如下：
```</p>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char **argv)
{</p>

<pre><code>int i;
printf("Just a test!\n");
for(i=0; i&lt;10; ++i) {
    printf("%d\n",i);
}
return 0;
</code></pre>

<p>}
```</p>

<p>当然也可以加上一些选项，例如“astyle &mdash;style=bsd test1.c”，“ astyle &mdash;style=gnu test1.c”等等。</p>

<p>在vim中的命令模式下，可以使用下面的某一种方式来格式化代码。
<code>
%!astyle (simple case - astyle default mode is C/C++)
</code>
或者
<code>
%!astyle --mode=c --style=ansi -s2 (ansi C++ style, use two spaces per indent level)
</code>
或者
<code>
1,40!astyle --mode=c --style=ansi (ansi C++ style, filter only lines 1-40)
</code></p>

<p>在格式化完代码后，会生成一个后缀为orig的文件，格式化完成之后将它们删除。为方便使用，可以把它写成一个脚本，代码如下：
```</p>

<h1>! /bin/bash</h1>

<p>for f in $(find . -name &lsquo;<em>.c&rsquo; -or -name &lsquo;</em>.cpp&rsquo; -or -name &lsquo;*.h&rsquo; -type f)
do</p>

<pre><code>astyle $f
</code></pre>

<p>done</p>

<h1>after formate the code,we need to rm &lsquo;*.orig&rsquo; files</h1>

<p>for f in $(find . -name &lsquo;*.orig&rsquo; -type f)
do</p>

<pre><code>rm $f
</code></pre>

<p>done
```</p>
]]></content>
  </entry>
  
</feed>

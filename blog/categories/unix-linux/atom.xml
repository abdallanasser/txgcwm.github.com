<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Unix/Linux | 残剑]]></title>
  <link href="http://txgcwm.github.io/blog/categories/unix-linux/atom.xml" rel="self"/>
  <link href="http://txgcwm.github.io/"/>
  <updated>2014-06-29T17:42:19+08:00</updated>
  <id>http://txgcwm.github.io/</id>
  <author>
    <name><![CDATA[残剑]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CentOS安装SVN]]></title>
    <link href="http://txgcwm.github.io/blog/2014/06/20/centosan-zhuang-svn/"/>
    <updated>2014-06-20T22:07:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2014/06/20/centosan-zhuang-svn</id>
    <content type="html"><![CDATA[<h1>安装ssh服务器和subversion服务器</h1>

<p>```</p>

<h1>yum update</h1>

<h1>yum install openssh-server</h1>

<h1>yum install subversion</h1>

<p>```</p>

<h1>创建登陆svn的用户</h1>

<p>```</p>

<h1>useradd test // 添加test用户</h1>

<h1>groupadd svn // 添加svn用户组</h1>

<h1>usermod -a -G svn test // 将test用户添加到svn用户组</h1>

<p>```
另外，如果test用户不存在，则可以用以下语句完成：</p>

<p>```</p>

<h1>useradd -g svn test</h1>

<p>```</p>

<h1>建立用户存储</h1>

<p>```</p>

<h1>mkdir -p /home/test/svn/trunk</h1>

<h1>svnadmin create /home/test/svn/trunk</h1>

<p>```</p>

<h1>为svn用户组赋予权限</h1>

<p>```</p>

<h1>chown -R root:svn /home/test/svn/trunk</h1>

<h1>chmod -R g+rws /home/test/svn/trunk    /<em>给svn组赋予读写权限，可以根据需要更改相应权限</em>/</h1>

<h1>chmod -R o-rwx /home/test/svn/trunk    /<em>删除其他无关人员的读、写、执行权限，默认情况下可能其他人有读权限</em>/</h1>

<p>```</p>

<!--more-->


<h1>为成员生成密钥</h1>

<p>生成密钥对：
```</p>

<h1>ssh-keygen -b 1024 -t rsa -N passwd -f testkey</h1>

<p>```
其中，passwd为密钥关键字（相当于密码），由用户自定义；testkey为密钥文件名，生成之后会产生两个文件（testkey和testkey.pub，前者为密钥，后者为公钥）；rsa指定使用rsa进行加密，如果改成dsa，则使用dsa加密。</p>

<p>创建/home/test/.ssh目录，拷贝公钥并重命名成authorized_keys：
```</p>

<h1>cp testkey.pub /home/test/.ssh/authorized_keys</h1>

<p>```
注意：文件名称必须为authorized_keys。</p>

<h1>更改资源访问权限</h1>

<p>修改/home/test/svn/trunk/conf/svnserve.conf文件，在general中加入以下几行：</p>

<p>```
[general]</p>

<p>anon-access = none // 未认证的用户没有任何访问权限   <br/>
auth-access = write // 认证的用户有写权限        <br/>
authz-db = authz // 认证文件为conf目录下的authz文件    <br/>
```</p>

<p>修改/home/test/svn/trunk/conf/authz文件（如果没有则创建），在其中加入：</p>

<p><code>
[/]       // 访问权限为本资源的根目录以及以下目录      
test = rw // test用户的访问权限为“读+写”      
</code>
还可以采用以下方法进行认证：</p>

<p>```
[groups]    <br/>
svn = test,sam // 定义用户组svn包含两个用户：test和sam</p>

<p>[/]   <br/>
@svn = rw // svn用户组的成员访问权限为“读+写”    <br/>
```</p>

<h1>启动svnserve</h1>

<p>```</p>

<h1>svnserve -d -r /home/test/svn/</h1>

<p>```</p>

<br></br>


<p><big>参考文章</big></p>

<p><a href="http://blog.csdn.net/wangjingfei/article/details/5424338">CentOS中安装subversion，并使用svn+ssh访问</a><br/>
<a href="http://blog.163.com/longsu2010@yeah/blog/static/173612348201202114212933/">linux（centos）搭建SVN服务器</a><br/>
<a href="http://zhumeng8337797.blog.163.com/blog/static/100768914201292641420400/">CentOS Linux搭建SVN Server配置详解</a><br/>
<a href="http://www.cnblogs.com/ayanmw/archive/2011/12/19/2294054.html">CentOS Linux下配置svn HTTP server</a><br/>
<a href="http://stackoverflow.com/search?q=svn%3A+E170001+%3A+Authorization+failed">svn: E170001 : Authorization failed</a><br/>
<a href="http://blog.sina.com.cn/s/blog_4b93170a0100leb2.html">解决svn Authorization failed错误</a><br/>
<a href="http://blog.csdn.net/laverock/article/details/2195290">ubuntu下架设svn服务器及在windows建立svn+ssh客户端</a><br/>
<a href="http://bbs.csdn.net/topics/310115750">svn登陆时它出现：Authorization failed</a><br/>
<a href="http://www.cyberciti.biz/faq/howto-linux-add-user-to-group/">Howto: Linux Add User To Group</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu下安装c-ares库]]></title>
    <link href="http://txgcwm.github.io/blog/2014/03/26/ubuntuxia-an-zhuang-c-aresku/"/>
    <updated>2014-03-26T22:59:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2014/03/26/ubuntuxia-an-zhuang-c-aresku</id>
    <content type="html"><![CDATA[<p>安装c-ares库的三种方法：</p>

<h1>源码安装</h1>

<p>到<a href="http://c-ares.haxx.se/">这里</a>下载源码，然后执行以下指令编译和安装。
<code>
$ cd c-ares-1.10.0
$ ./buildconf
$ autoconf configure.ac
$ ./configure
$ make
$ sudo make install
</code></p>

<h1>第三方软件安装</h1>

<p>在新得立搜索c-ares，然后安装相应的库。</p>

<h1>终端安装</h1>

<p><code>
$ sudo apt-get install libc-ares2 libc-ares-dev
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu上安装LaTeX]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/07/ubuntushang-an-zhuang-latex/"/>
    <updated>2013-08-07T00:53:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/07/ubuntushang-an-zhuang-latex</id>
    <content type="html"><![CDATA[<p>LaTeX（音译“拉泰赫”）是一种基于TeX的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天甚至几小时内生成很多具有书籍质量的印刷品。</p>

<p>可以在Ubuntu安装很多LaTeX的分发版，其中一个是TeX Live，使用下面的命令可以在Ubuntu上安装Tex Live（软件有好几百M，需要慢慢等待）。
<code>
$ sudo apt-get install texlive-full
</code>
要编辑LaTeX文档需要一个编辑器，你可以找到很多编辑器，这里推荐使用Texmaker。
<code>   
$ sudo apt-get install texmaker
</code></p>

<!--more-->


<p><code>apt-cache search cjk</code>找到相关宏包安装：
<code>
sudo apt-get install cjk-latex latex-cjk-chinese
</code>
安装喜欢的中文字体：
<code>
sudo apt-get install xfonts-wqy ttf-wqy-microhei ttf-wqy-zenhei
</code>
安装英文字体：
```
$ apt-cache search &lsquo;courier new&rsquo;
ttf-mscorefonts-installer &ndash; Installer for Microsoft TrueType core fonts</p>

<p>$ sudo apt-get install ttf-mscorefonts-installer
<code>
需要更新字体缓存：
</code>
$ fc-cache
<code>
为了使整个系统下的用户的字体列缓存都更新，建议使用root权限执行:
</code>
$ sudo fc-cache -f -s -v
<code>
使用fc-list查看可用的字体：
</code>
$ fc-list
<code>
或者只查看中文的字体：
</code>
$ fc-list ：lang=zh
```
如果能看到想要的中文字体，就可以了。</p>

<p>新增一个test.tex名字的文件，内容如下：
```
% dependencies: xelatex, xecjk package，Courier New字体，wenquanyi中文字体，也可以设置其他的中英文字体
% Usage: xelatex filename[.tex]</p>

<p>\documentclass[11pt]{article}
\usepackage{xeCJK}
\setmainfont{Courier New} % 设置英文衬线字体
% \setmonofont{} % 设置英文等宽字体，等宽英文字体大全：<a href="http://zh.wikipedia.org/wiki/%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93">http://zh.wikipedia.org/wiki/%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93</a>
% \setsansfont{} % 设置英文无衬线字体
\setCJKmainfont{WenQuanYi Micro Hei} % 设置缺省中文字体
%\setCJKfamilyfont{WenQuanYi Micro Hei} % 与setCJKmainfon t等同，<a href="http://bbs.ctex.org/forum.php?mod=viewthread&amp;tid=51057">http://bbs.ctex.org/forum.php?mod=viewthread&amp;tid=51057</a>
\parindent 2em   %段首缩进</p>

<p>\begin{document}
\section{举例}
\begin{verbatim}
标点。
\end{verbatim}</p>

<p>汉字Chinese数学$x=y$空格
\end{document}
<code>
再用xelatex编译，就可以生成pdf文档了。
</code>
$ xelatex filename.tex
```</p>

<p><big>参考文章</big></p>

<p><a href="http://forum.ubuntu.org.cn/viewtopic.php?t=274400">ku10.04下 tevlive-xetex 、texmaker 、ctex宏包 安装成功</a> <br/>
<a href="http://forum.ubuntu.com.cn/viewtopic.php?f=35&amp;t=331555">natty narwahl 源安装 texlive2009 及 中文配置教程总结</a> <br/>
<a href="http://blog.sina.com.cn/s/blog_5e16f1770100lgs5.html">LaTeX技巧345：modernCV-xelatex中文支持简历</a> <br/>
<a href="http://linuxandfriends.com/latex-resume-templates/">LaTeX Resume Templates</a> <br/>
<a href="http://www.cnblogs.com/bamboo-talking/archive/2013/01/07/2848914.html">xelatex+xeCJK在ubuntu Linux中显示中文</a> <br/>
<a href="http://linux-wiki.cn/wiki/zh-hans/LaTeX%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%EF%BC%88%E4%BD%BF%E7%94%A8XeTeX%EF%BC%89">LaTeX中文排版（使用XeTeX）</a> <br/>
<a href="http://mathslinux.org/?p=58">用 org-mode 写 LaTeX</a> <br/>
<a href="http://www.oschina.net/question/12_63776">在 Ubuntu 上安装 LaTeX</a> <br/>
<a href="http://blog.csdn.net/yming0221/article/details/7616846">LaTeX使用&mdash;XeLaTeX入门基础（一）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[popen和pclose函数]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/popenhe-pclosehan-shu/"/>
    <updated>2013-08-03T22:07:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/popenhe-pclosehan-shu</id>
    <content type="html"><![CDATA[<p>标准I/O函数库提供了popen函数，它启动一个子进程去执行一个shell命令行。popen函数还创建一个管道用于父子进程间通信。父进程要么从管道读信息，要么向管道写信息，至于是读还是写取决于父进程调用popen时传递的参数。以下给出popen、pclose的定义：
<code>
FILE *popen( const char* command, const char* mode )
</code>
参数说明</p>

<p>command： 是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。<br/>
mode： 只能是读或者写中的一种，得到的返回值(标准I/O流)也具有和type相应的只读或只写类型。如果type是“r”则文件指针连接到command的标准输出;如果type是“w”则文件指针连接到command的标准输入。</p>

<!--more-->


<p>返回值</p>

<p>如果调用成功，则返回一个读或者写打开文件的指针；如果失败，返回NULL，具体错误要根据errno判断。</p>

<p><code>
int pclose (FILE* stream)
</code>
参数说明</p>

<p>stream： popen返回的文件指针。</p>

<p>返回值</p>

<p>如果调用失败，返回-1。</p>

<p>由于平时接触到usb插拔的事情比较多，现以列举系统中usb设备vid/pid为例。本想从<code>/proc/bus/usb/devices</code>中获取到usb设备的相关信息，可Ubuntu系统下没有<code>/proc/bus/usb/</code>这个目录。至于为什么没有这个目录和如何重新找回这个目录，可以查看 <a href="http://ubuntuforums.org/showthread.php?t=1432598">这里</a> 。所以这里我们使用<code>lsusb</code>去获取usb设备的基本信息。构建<code>int get_device_info(void)</code>函数获取系统中usb设备的vid/pid信息：
```
int get_device_info(void)
{</p>

<pre><code>FILE *fp = NULL;
char buffer[128];
char *ptr = NULL;
int vid, pid;

fp = popen("lsusb", "r");
if (fp == NULL)
    return -1;

while (NULL != fgets(buffer, sizeof(buffer), fp)) {
    ptr = strstr(buffer, "ID");
    if (ptr) {
        sscanf(ptr, "ID %04x:%04x", &amp;vid, &amp;pid);
        printf("%04x:%04x\n", vid, pid);
    }
}
pclose(fp);

return 0;
</code></pre>

<p>}
<code>
编写主函数调用以上的接口，使用`lsusb`查看usb设备及执行测试程序：
</code>
$ lsusb
Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 003: ID 1532:0016 Razer USA, Ltd DeathAdder Mouse
Bus 001 Device 004: ID 058f:b002 Alcor Micro Corp.</p>

<p>$ ./a.out
8087:0024
8087:0024
1d6b:0002
1d6b:0002
1532:0016
058f:b002</p>

<p>```</p>

<p><big>参考文章</big></p>

<p><a href="http://my.oschina.net/renhc/blog/35116">基于管道的popen和pclose函数</a><br/>
<a href="http://networking.ctocio.com.cn/tips/137/9412137.shtml">Linux popen函数的使用总结</a><br/>
<a href="http://bbs.chinaunix.net/thread-4087539-1-1.html">关于/proc/iomem中信息解释</a>  <br/>
<a href="http://tech.watchstor.com/storage-systems-117859.htm">proc文件系统功能总览</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[log10的实现]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/log10de-shi-xian/"/>
    <updated>2013-08-03T01:46:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/log10de-shi-xian</id>
    <content type="html"><![CDATA[<p>在项目中要使用到log10计算，可所用系统的标准库里并没有移植该功能，需要自己实现。请问，采用什么算法实现该功能？</p>

<p>在网上找了一个例子，但不确定能否在嵌入式的一些平台使用。
```</p>

<pre><code>double my_log10(double x)
{
    register double ret;

 __asm__(
    "fldlg2\n\t" 
    "fxch\n\t" 
    "fyl2x"
    :"=t"(ret)
    :"0"(x)
        );
   return ret;
}
</code></pre>

<p>```</p>

<!--more-->


<p>也查看了glibc的源码，可调用了其它的一些API，对库的依赖比较大，逐步移植的话比较麻烦。代码如下：
```</p>

<pre><code>double __log10 (double x)
{
    if (__builtin_expect (islessequal (x, 0.0), 0) &amp;&amp; _LIB_VERSION != _IEEE_)
    {
        if (x == 0.0)
        {
             feraiseexcept (FE_DIVBYZERO);
             return __kernel_standard (x, x, 18); /* log10(0) */
        }
        else
        {
            feraiseexcept (FE_INVALID);
            return __kernel_standard (x, x, 19); /* log10(x&lt;0) */
        }
     }

   return  __ieee754_log10 (x);
}
</code></pre>

<p>```</p>

<p>参考 <a href="http://www.cnblogs.com/skyivben/archive/2013/02/15/2912914.html">这里</a> 实现了一个c语言版本的log10快速算法，还不是很完善。
```</p>

<h1>include &lt;math.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<p>static double Sqrt(double x)
{</p>

<pre><code>if (x &lt; 0)
    return -1;
if (x == 0)
    return 0;
double y = (double)sqrt((double)x);

return (y + x / y) / 2;
</code></pre>

<p>}</p>

<p>static double NegativeLog(double q)
{</p>

<pre><code>int p;
double pi2 = 6.283185307179586476925286766559;
double eps2 = 0.00000000000001; // 1e-14
double eps1;    // 1e-28
double r = q, s = q, n = q, q2 = q * q, q1 = q2 * q;

eps1 = eps2 * eps2;

for (p = 1; (n *= q1) &gt; eps1; s += n, q1 *= q2)
    r += (p = !p) ? n : -n;

double u = 1 - 2 * r, v = 1 + 2 * s, t = u / v;
double a = 1, b = Sqrt(1 - t * t * t * t);

for (; a - b &gt; eps2; b = Sqrt(a * b), a = t)
    t = (a + b) / 2;

return pi2 / (a + b) / v / v;
</code></pre>

<p>}</p>

<p>static double Log(double x)
{</p>

<pre><code>int k = 0;
double ln10 = 2.30258509299404568401799145468;

if (x &lt;= 0)
    return -1;
if (x == 1)
    return 0;

for (; x &gt; 0.1; k++)
    x /= 10;
for (; x &lt;= 0.01; k--)
    x *= 10;

return k * ln10 - NegativeLog(x);
</code></pre>

<p>}</p>

<p>double Log10(double x)
{</p>

<pre><code>double ln10 = 2.30258509299404568401799145468;

return Log(x) / ln10;
</code></pre>

<p>}</p>

<p>int main(int argc, char **argv)
{</p>

<pre><code>printf(" self Log10: %f\n math log10: %f\n\n", Log10(1000), log10(1000));
printf(" self Log10: %f\n math log10: %f\n\n", Log10(1), log10(1));
printf(" self Log10: %f\n math log10: %f\n\n", Log10(8192.1024), log10(8192.1024));
printf(" self Log10: %f\n math log10: %f\n\n", Log10(0.3), log10(0.3));
printf(" self Log10: %f\n math log10: %f\n\n", Log10(33.8), log10(33.8));

return 0;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Unix/Linux | 残剑]]></title>
  <link href="http://txgcwm.github.io/blog/categories/unix-linux/atom.xml" rel="self"/>
  <link href="http://txgcwm.github.io/"/>
  <updated>2013-07-26T22:43:09+08:00</updated>
  <id>http://txgcwm.github.io/</id>
  <author>
    <name><![CDATA[残剑]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux下iptables防火墙原理及使用]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/25/linuxxia-iptablesfang-huo-qiang-yuan-li-ji-shi-yong/"/>
    <updated>2013-07-25T23:36:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/25/linuxxia-iptablesfang-huo-qiang-yuan-li-ji-shi-yong</id>
    <content type="html"><![CDATA[<p>netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。iptables和netfilter的关系是一个很容易让人搞不清的问题：很多人知道iptables却不知道netfilter，其实iptables（位于/sbin目录下）只是Linux防火墙的管理工具而已，真正实现防火墙功能的是netfilter（它是Linux内核中实现包过滤的内部结构）。</p>

<h1>iptables传输数据包的过程</h1>

<p><img src="/images/2013/7/iptables/flow.png" alt=" flow " /></p>

<!--more-->


<ol>
<li>当一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的ip地址判断是否需要转送出去。</li>
<li>如果数据包就是进入本机的，它就会沿着上图所指方向向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过OUTPUT链，然后到达POSTROUTING链输出。</li>
<li>如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过FORWARD链，然后到达POSTROUTING链输出。</li>
</ol>


<h1>规则表和规则链</h1>

<p>iptables采用“表”和“链”的分层结构。表（tables）提供特定的功能，iptables内置了4个表，即Filter表、Nat表、Mangle表和Raw表，分别用于实现包过滤、网络地址转换、包重构(修改)和数据跟踪处理。链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包，否则iptables将继续检查下一条规则。如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。</p>

<p><img src="/images/2013/7/iptables/table.png" alt=" table " /></p>

<h2>规则表</h2>

<p>iptables有4个规则表，其之间的优先顺序为Raw&mdash;-Mangle&mdash;-Nat&mdash;-Filter。</p>

<ol>
<li><p>Filter表有三个链：INPUT、FORWARD、OUTPUT</p>

<p> 作用：过滤数据包<br/>
 内核模块：iptables_filter</p></li>
<li><p>Nat表有三个链：PREROUTING、POSTROUTING、OUTPUT</p>

<p> 作用：用于网络地址转换（IP、端口） <br/>
 内核模块：iptable_nat</p></li>
<li><p>Mangle表有五个链：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD</p>

<p> 作用：修改数据包的服务类型、TTL、并且可以配置路由实现QOS   <br/>
 内核模块：iptable_mangle</p></li>
<li><p>Raw表有两个链：OUTPUT、PREROUTING</p>

<p> 作用：决定数据包是否被状态跟踪机制处理<br/>
 内核模块：iptable_raw</p></li>
</ol>


<h2>规则链</h2>

<ol>
<li>INPUT——进来的数据包应用此规则链中的策略。</li>
<li>OUTPUT——外出的数据包应用此规则链中的策略。</li>
<li>FORWARD——转发数据包时应用此规则链中的策略。</li>
<li>PREROUTING——对数据包作路由选择前应用此链中的规则，所有的数据包进来的时侯都先由这个链处理。</li>
<li>POSTROUTING——对数据包作路由选择后应用此链中的规则，所有的数据包出来的时侯都先由这个链处理。</li>
</ol>


<p>规则链之间的优先顺序分三种情况：</p>

<ol>
<li><p>入站数据流向</p>

<p> 从外界到达防火墙的数据包，先被PREROUTING规则链处理（是否修改数据包地址等），之后会进行路由选择（判断该数据包应该发往何处），如果数据包的目标主机是防火墙本机（比如说Internet用户访问防火墙主机中的web服务器的数据包），那么内核将其传给INPUT链进行处理（决定是否允许通过等），通过以后再交给系统上层的应用程序（比如Apache服务器）进行响应。</p></li>
<li><p>转发数据流向</p>

<p> 来自外界的数据包到达防火墙后，首先被PREROUTING规则链处理，之后会进行路由选择，如果数据包的目标地址是其它外部地址（比如局域网用户通过网关访问QQ站点的数据包），则内核将其传递给FORWARD链进行处理（是否转发或拦截），然后再交给POSTROUTING规则链（是否修改数据包的地址等）进行处理。</p></li>
<li><p>出站数据流向</p>

<p> 防火墙本机向外部地址发送的数据包（比如在防火墙主机中测试公网DNS服务器时），首先被OUTPUT规则链处理，之后进行路由选择，然后传递给POSTROUTING规则链（是否修改数据包的地址等）进行处理。</p></li>
</ol>


<h1>管理和设置iptables规则</h1>

<p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p>

<p><img src="/images/2013/7/iptables/cmd.png" alt=" cmd " /></p>

<p><img src="/images/2013/7/iptables/filter.png" alt=" filter " /></p>

<h2>iptables的基本语法格式</h2>

<p>iptables [-t 表名] 命令选项 ［链名］ ［条件匹配］ ［-j 目标动作或跳转］</p>

<p>说明：表名、链名用于指定iptables命令所操作的表和链，命令选项用于指定管理iptables规则的方式（比如插入、增加、删除、查看等）；条件匹配用于指定对符合什么样条件的数据包进行处理；目标动作或跳转用于指定数据包的处理方式（比如允许通过、拒绝、丢弃、跳转给其它链处理）。</p>

<p>iptables命令的管理控制选项：
<code>
-A 在指定链的末尾添加（append）一条新的规则
-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除
-I 在指定链中插入（insert）一条新的规则，默认在第一行添加
-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换
-L 列出（list）指定链中所有的规则进行查看
-E 重命名用户定义的链，不改变链本身
-F 清空（flush）
-N 新建（new-chain）一条用户自己定义的规则链
-X 删除指定表中用户自定义的规则链（delete-chain）
-P 设置指定链的默认策略（policy）
-Z 将所有表的所有链的字节和数据包计数器清零
-n 使用数字形式（numeric）显示输出结果
-v 查看规则表详细信息（verbose）的信息
-V 查看版本(version)
-h 获取帮助（help）
</code></p>

<h2>防火墙处理数据包的四种方式</h2>

<ol>
<li>ACCEPT：允许数据包通过。</li>
<li>DROP：直接丢弃数据包，不给任何回应信息</li>
<li>REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息。</li>
<li>LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则。</li>
</ol>


<h2>防火墙规则的保存与恢复</h2>

<p>iptables-save把规则保存到文件中（生成保存规则的文件名为/etc/sysconfig/iptables），再由rc.d目录下的脚本（/etc/rc.d/init.d/iptables）自动装载。使用<code>iptables-save &gt; /etc/sysconfig/iptables</code>命令来保存规则，也可以用<code>service iptables save</code>指令把规则自动保存起来。当计算机启动时，rc.d下的脚本将用命令<code>iptables-restore</code>调用这个文件，从而就自动恢复了规则。</p>

<h2>防火墙常用策略</h2>

<ul>
<li><p>拒绝进入防火墙的所有ICMP协议数据包
<code>
  $ iptables -I INPUT -p icmp -j REJECT
</code></p></li>
<li><p>允许防火墙转发除ICMP协议以外的所有数据包，使用“！”可以将条件取反。
<code>
  $ iptables -A FORWARD -p ! icmp -j ACCEPT
</code></p></li>
<li><p>拒绝转发来自192.168.1.10主机的数据，允许转发来自192.168.0.0/24网段的数据。要把拒绝的放在前面，不然就不起作用了。
<code>
  $ iptables -A FORWARD -s 192.168.1.11 -j REJECT
  $ iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT
</code></p></li>
<li><p>丢弃从外网接口（eth1）进入防火墙本机的源地址为私网地址的数据包。
<code>
  $ iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP
  $ iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP
  $ iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP
</code></p></li>
<li><p>封堵网段（192.168.1.0/24），两小时后解封。这个策略可以借助crond计划任务来完成。
```
  $ iptables -I INPUT -s 10.20.30.0/24 -j DROP
  $ iptables -I FORWARD -s 10.20.30.0/24 -j DROP
  $ at now 2 hours at> iptables -D INPUT 1 at> iptables -D FORWARD 1</p>

<p>  [1]   Stopped     at now 2 hours
```</p></li>
<li><p>只允许管理员从202.13.0.0/16网段使用SSH远程登录防火墙主机。比较适合对设备进行远程管理时使用，比如位于分公司中的SQL服务器需要被总公司的管理员管理时。
<code>
  $ iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPT
  $ iptables -A INPUT -p tcp --dport 22 -j DROP
</code></p></li>
<li><p>允许本机开放从TCP端口20-1024提供的应用服务。
<code>
  $ iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPT
  $ iptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT
</code></p></li>
<li><p>允许转发来自192.168.0.0/24局域网段的DNS解析请求数据包。
<code>
  $ iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT
  $ iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT
</code></p></li>
<li><p>禁止其他主机ping防火墙主机，但是允许从防火墙上ping其他主机
<code>
  $ iptables -I INPUT -p icmp --icmp-type Echo-Request -j DROP
  $ iptables -I INPUT -p icmp --icmp-type Echo-Reply -j ACCEPT
  $ iptables -I INPUT -p icmp --icmp-type destination-Unreachable -j ACCEPT
</code></p></li>
<li><p>禁止转发来自MAC地址为00：0C：29：27：55：3F的主机的数据包。iptables中使用“-m 模块关键字”的形式调用显示匹配。这里用“-m mac &mdash;mac-source”来表示数据包的源MAC地址。
<code>
  $ iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP
</code></p></li>
<li><p>允许防火墙本机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-1280，这里用“-m multiport &mdash;dport”来指定目的端口及范围。
<code>
  $ iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT
</code></p></li>
<li><p>禁止转发源IP地址为192.168.1.20-192.168.1.99的TCP数据包。此处用“-m iprange &mdash;src-range”指定IP范围。
<code>
  $ iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP
</code></p></li>
<li><p>禁止转发与正常TCP连接无关的非&mdash;syn请求数据包。“-m state”表示数据包的连接状态，“NEW”表示与任何连接无关。
<code>
  $ iptables -A FORWARD -m state --state NEW -p tcp ! --syn -j DROP
</code></p></li>
<li><p>拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包。“ESTABLISHED”表示已经响应请求或者已经建立连接的数据包，“RELATED”表示与已建立的连接有相关性的，比如FTP数据连接等。
<code>
  $ iptables -A INPUT -p tcp -m state --state NEW -j DROP
  $ iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
</code></p></li>
<li><p>只开放本机的web服务（80）、FTP(20、21、20450-20480)，放行外部主机发住服务器其它端口的应答数据包，将其他入站数据包均予以丢弃处理。
<code>
  $ iptables -I INPUT -p tcp -m multiport --dport 20,21,80 -j ACCEPT
  $ iptables -I INPUT -p tcp --dport 20450:20480 -j ACCEPT
  $ iptables -I INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
  $ iptables -P INPUT DROP
</code></p></li>
</ul>


<h1>参考文章</h1>

<ul>
<li><a href="http://netfilter.org/">netfilter</a></li>
<li><a href="http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html">Iptables 指南 1.1.19</a>　</li>
<li><a href="http://blog.csdn.net/thmono/archive/2010/04/08/5462043.aspx">iptable 笔记</a></li>
<li><a href="http://netsecurity.51cto.com/art/200512/14457.htm">网络安全频道</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_40ba724c0100jz12.html">iptables_2</a></li>
<li><a href="http://qiliuping.blog.163.com/blog/static/1023829320105245337799/">netfilter/iptables全攻略</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[astyle格式化代码]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/24/astylege-shi-hua-dai-ma/"/>
    <updated>2013-07-24T18:36:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/24/astylege-shi-hua-dai-ma</id>
    <content type="html"><![CDATA[<p>astyle是一个开源工具，它可以方便的将代码格式化成自己想要的样式而不必人工修改。可以在终端下输入指令<code>sudo apt-get install astyle</code>安装，也可以到 <a href="http://astyle.sourceforge.net/">这里</a> 下载源码后自己编译安装。</p>

<p>下面介绍一下astyle的简单使用。例如有以下的源码：
```</p>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char **argv)
{int i;printf(&ldquo;Just a test!\n&rdquo;);for(i=0;i&lt;10;++i)printf(&ldquo;%d\n&rdquo;,i);}return 0;}
```</p>

<!--more-->


<p>然后在终端下输入以下指令：
<code>
$ astyle test1.c
</code>
效果如下：
```</p>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char **argv)
{</p>

<pre><code>int i;
printf("Just a test!\n");
for(i=0; i&lt;10; ++i) {
    printf("%d\n",i);
}
return 0;
</code></pre>

<p>}
```</p>

<p>当然也可以加上一些选项，例如“astyle &mdash;style=bsd test1.c”，“ astyle &mdash;style=gnu test1.c”等等。</p>

<p>在vim中的命令模式下，可以使用下面的某一种方式来格式化代码。
<code>
%!astyle (simple case - astyle default mode is C/C++)
</code>
或者
<code>
%!astyle --mode=c --style=ansi -s2 (ansi C++ style, use two spaces per indent level)
</code>
或者
<code>
1,40!astyle --mode=c --style=ansi (ansi C++ style, filter only lines 1-40)
</code></p>

<p>在格式化完代码后，会生成一个后缀为orig的文件，格式化完成之后将它们删除。为方便使用，可以把它写成一个脚本，代码如下：
```</p>

<h1>! /bin/bash</h1>

<p>for f in $(find . -name &lsquo;<em>.c&rsquo; -or -name &lsquo;</em>.cpp&rsquo; -or -name &lsquo;*.h&rsquo; -type f)
do</p>

<pre><code>astyle $f
</code></pre>

<p>done</p>

<h1>after formate the code,we need to rm &lsquo;*.orig&rsquo; files</h1>

<p>for f in $(find . -name &lsquo;*.orig&rsquo; -type f)
do</p>

<pre><code>rm $f
</code></pre>

<p>done
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to resolve "error opening terminal Linux"]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/24/how-to-resolve-error-opening-terminal-linux/"/>
    <updated>2013-07-24T18:33:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/24/how-to-resolve-error-opening-terminal-linux</id>
    <content type="html"><![CDATA[<p>Linux环境下，编译嵌入式系统时会用到<code>make menuconfig</code>或<code>make config</code>命令，这些命令通常会使用ncurses库，如果ncurses库没有安装设置正确，可能出现如下的错误信息：
<code>
error opening terminal Linux
error opening terminal xterm
error opening terminal vt100
error opening terminal vt102
error opening terminal unknown
error opening terminal cgywin
...
</code></p>

<!--more-->


<p>可以按照以下两步解决问题：</p>

<ol>
<li>首先要确定ncurses库是否已经正确安装。在Debian或Ubuntu上，可以用<code>dpkg -l | grep ncurses</code>查看ncurses库是否已安装。</li>
<li>如果ncurses已经安装了，需要查看TERM和TERMINFO两个环境变量是否已经设置正确。如果没有设置正确，需要设置为正确的值。
<code>
 $ echo $TERM
 $ echo $TERMINFO
</code></li>
</ol>


<p>关于TERMINFO, 应设置为terminfo的路径，比如/usr/share/terminfo或者/lib/terminfo。查看terminfo的存储位置用以下指令：
<code>
$ whereis terminfo
terminfo: /etc/terminfo /lib/terminfo /usr/share/terminfo /usr/share/man/man5/terminfo.5.gz
</code></p>

<p>查看terminfo目录下是否保存了终端信息文件：其中通常分为a, b, c, d&hellip;z这些字母目录，每个目录中包含了以该字母开头的term信息。比如vt100放在"v"目录中。我们需要的term必须在对应的目录中存在term信息。确定这些信息后，就可以设置TERM和TERMINFO信息：
<code>
$ export TERM=vt100
$ export TERMINFO=/usr/share/terminfo
</code></p>

<p>上面的设置必须保证/usr/share/terminfo中存在term信息，且/usr/share/terminfo/v/vt100是存在的。关于TERM的设置，有可能需要设置成Linux，vt100-putty等不同的TERM。Linux通常用于Linux控制台，vt100-putty顾名思义是使用putty远程登录的vt100终端。</p>

<p>以下是在Ubuntu12.10环境下，解决了此问题后TERM和TERMINFO两个环境变量的值。
<code>
$ echo $TERM
xterm
$ echo $TERMINFO
/lib/terminfo/
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu下安装SublimeText2及其插件]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/23/ubuntuxia-an-zhuang-sublimetext2ji-qi-cha-jian/"/>
    <updated>2013-07-23T22:33:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/23/ubuntuxia-an-zhuang-sublimetext2ji-qi-cha-jian</id>
    <content type="html"><![CDATA[<p>Sublime Text 2是一个轻量、简洁、高效、跨平台的编辑器，方便的配色以及兼容vim快捷键等各种优点博得了很多前端开发人员的喜爱。Sublime Text 2基本上是共享软件，免费版和收费版基本无区别，只是偶尔会弹框让你去购买，这个基本不影响使用。</p>

<h1>软件安装</h1>

<p>Ubuntu下安装Sublime Text 2有两种方式：指令安装和直接下载安装。</p>

<h2>指令安装</h2>

<p><code>
$ sudo add-apt-repository ppa:webupd8team/sublime-text-2
$ sudo apt-get update
$ sudo apt-get install sublime-text-2
</code></p>

<!--more-->


<h2>直接下载安装</h2>

<p>从 <a href="http://www.sublimetext.com/2">这里</a>下载所需要的版本，然后解压文件到安装目录。
<code>
$ sudo tar -jxvf Sublime\ Text\ 2.0.1.tar.bz2 -C /usr/local/
</code></p>

<h1>在applications菜单中创建快捷方式</h1>

<p>```
$ sudo gedit /usr/share/applications/sublimetext.desktop</p>

<p>[Desktop Entry]
Encoding=UTF-8
Name=Sublime Text
Comment=Sublime Text
Exec=/usr/local/SublimeText/sublime_text
Icon=/usr/local/SublimeText/Icon/48x48/sublime_text.png
Terminal=false
StartupNotify=true
Type=Application
Categories=Application;Development;
```</p>

<h1>安装插件</h1>

<p>安装Sublime text 2插件也有两种方法：直接安装和使用Package Control组件安装。</p>

<h2>直接安装</h2>

<p>可以直接下载安装包解压缩到Packages目录（菜单->preferences->packages）。</p>

<h2>使用Package Control组件安装</h2>

<p>也可以先安装package control组件，然后直接在线安装：</p>

<ul>
<li>按Ctrl + `调出console ，其中`是键盘左上角那个符号。</li>
<li>粘贴以下代码到底部命令行并回车。
<code>
import urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print 'Please restart Sublime Text to finish installation'
</code></li>
<li>重启Sublime Text 2。</li>
<li>如果在Perferences->package settings中看到package control这一项，则安装成功。 如果这种方法不能安装成功，可以到 <a href="http://wbond.net/sublime_packages/package_control/installation">这里</a> 下载文件手动安装。</li>
</ul>


<p>用Package Control安装插件的方法：a、按下<code>Ctrl+Shift+P</code>调出命令面板；b、输入<code>install</code>调出Install Package选项并回车，然后在列表中选中要安装的插件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress添加中文标签功能]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/21/octopresstian-jia-zhong-wen-biao-qian-gong-neng/"/>
    <updated>2013-07-21T11:02:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/21/octopresstian-jia-zhong-wen-biao-qian-gong-neng</id>
    <content type="html"><![CDATA[<p>Octopress有自带的分类，详情请见 <a href="http://octopress.org/docs/plugins/category-generator/">官方文档</a> 。<code>_config.yml</code>中配置项如下：
<code>
category_dir: blog/categories
category_title_prefix: "Category: "
</code>
然后添加类似<code>categories: [Ruby&amp;Rails]</code>或<code>categories: [Ruby&amp;Rails，C/C++]</code>的分类标签配置到每个<code>_posts/*.markdown</code>文件头中，示例如下:</p>

<h2>```</h2>

<p>layout: post
title: &ldquo;Octopress添加中文标签功能&rdquo;
date: 2013-07-21 11:02
comments: true</p>

<h2>categories: [Ruby&amp;Rails,Octopress]</h2>

<p>```</p>

<!--more-->


<h1>添加分类侧边栏并支持中文</h1>

<p>尽管Octopress有自带的分类，但它并不支持中文，如果你在文章中定义了中文分类，那么点击的时候会链接到404页面。事实上，这个分类功能是通过plugins/category_generator.rb来实现，所以只要对该文件进行适当的修改和作一些其它的配置就可以提供中文分类的支持。</p>

<ul>
<li>category_generator.rb的修改我直接使用 <a href="https://github.com/denjones/denjones.github.com/blob/source/plugins/category_generator.rb">这个</a> 文件作了替换，然后作一些细微的修改。</li>
</ul>


<p>SPRabbit(超科学兔耳中队)的 <a href="http://blog.sprabbit.com/blog/2012/03/23/octopress/">修改方法</a> 是重新定义分类标签在文章中的格式，例如用<code>中文分类标签名{英文别名}</code>这样的格式来定义标签。于是在文章中显示的是中文分类，但实际链接到英文别名上。这种方法虽然定义标签麻烦些，但可定制性强。</p>

<p>由于书写很麻烦，所以很不喜欢以上重新定义标签的方式，在 <a href="http://khaos.github.io/blog/2012/12/06/using-chinese-category-tags-in-octopress/">这里</a> 找到了另外一种更改方式。它同样是修改category_generator.rb文件来达到目的，利用了stringex包的to_url函数将中文分类标签的链接名和category_dir下的目录名都转换成相应的拼音，这样无论在本地还是GitHub上都没有问题。事实上，Octopress系统在利用rake new_[post|page]命令创建含有中文名的文章时也采用了这样的技巧。</p>

<p>找到<code>def write_category_indexes</code>中定义category目录的部分：
<code>
self.write_category_index(File.join(dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').downcase), category)
</code>
将其修改为：
<code>
self.write_category_index(File.join(dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').to_url.downcase), category)
</code>
再找到<code>def category_links(categories)</code>中定义中文分类网页标签的部分：
<code>
"&lt;a class='category' href='http://txgcwm.github.io/#{dir}/#{item.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').downcase}/'&gt;#{item}&lt;/a&gt;"
</code>
将其修改为：
<code>
"&lt;a class='category' href='http://txgcwm.github.io/#{dir}/#{item.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').to_url.downcase}/'&gt;#{item}&lt;/a&gt;"
</code>
注意，上面两处的修改就是在相应的地方加上to_url函数进行地址的转换。如果不想折腾的话，你也可以直接到 <a href="https://github.com/txgcwm/txgcwm.github.com/blob/source/plugins/category_generator.rb">这里</a> 下载我更改后的category_generator.rb插件。</p>

<ul>
<li>在plugins目录中创建category_list_tag.rb文件，文件内容如下：
```
require &lsquo;stringex&rsquo;</li>
</ul>


<p>module Jekyll
  class CategoryListTag &lt; Liquid::Tag</p>

<pre><code>def render(context)
  html = ""
  categories = context.registers[:site].categories.keys
  category_dir = context.registers[:site].config['category_dir']
  categories.sort.each do |category|
    posts_in_category = context.registers[:site].categories[category].size  
    category_url = File.join(category_dir, category.gsub(/_|\P{Word}/u, '-').gsub(/-{2,}/u, '-').to_url.downcase)
    html &lt;&lt; "&lt;li class='category'&gt;&lt;a href='http://txgcwm.github.io/#{category_url}/'&gt;#{category} (#{posts_in_category})&lt;/a&gt;&lt;/li&gt;\n"
  end
  html
end
</code></pre>

<p>  end
end</p>

<p>Liquid::Template.register_tag(&lsquo;category_list&rsquo;, Jekyll::CategoryListTag)
<code>
在实际使用（rake generate/rake preview）的时候，若blog整体采用了非ascii码的编码格式（比如utf-8）就会出现类似这样的错误：
</code>
Liquid error: incompatible encoding regexp match (ascii-8bit regexp with utf-8 string)
<code>
其实是由于插件文件plugins/category_list_tag.rb本身是ascii编码所致:
</code>
$ chardet category_list_tag.rb
category_list_tag.rb: ascii (confidence: 1.00)
```
category_list_tag.rb中很多地方用到了ruby的正则表达式，而ruby的正则表达式在匹配的时候，默认是按照“代码源文件”的编码格式(在这里是ascii)进行匹配的，而如果blog是utf-8编码的话就会出现上述错误。有两种解决办法：</p>

<ol>
<li>将category_list_tag.rb转成utf-8格式。</li>
<li>更改category_list_tag.rb中所有的正则表达式声明，加上<code>u</code>选项（<code>u</code>的意思就是以utf-8编码格式来进行匹配）。例如，若原正则表达式是<code>/regexp/</code>, 则改成<code>/regexp/u</code>。</li>
</ol>


<p>在我实际处理问题的时候采用了第二种方法，category_list_tag.rb文件中的更改网上大多采用以下的方式：
<code>
category_url = File.join(category_dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').to_url.downcase)
</code>
更改成如下形式（只是简单增加了<code>u</code>选项）：
<code>
category_url = File.join(category_dir, category.gsub(/_|\P{Word}/u, '-').gsub(/-{2,}/u, '-').to_url.downcase)
</code></p>

<ul>
<li><p>添加source/_includes/custom/asides/category_list.html文件，内容可到 <a href="https://github.com/txgcwm/txgcwm.github.com/blob/source/source/_includes/custom/asides/category_list.html">这里</a> 查看。</p></li>
<li><p>修改_config.yml文件，在default_asides项中添加custom/asides/category_list.html，值之间以逗号隔开。
<code>
default_asides: [asides/recent_posts.html, custom/asides/category_list.html]
</code></p></li>
</ul>


<p><code>_posts/*.markdown</code>文件头中添加categories标签示例：</p>

<h2>```</h2>

<p>layout: post
title: &ldquo;使用libevent编写Linux服务&rdquo;
date: 2013-07-18 19:01
comments: true</p>

<h2>categories: [C/C++, 开源库, Unix/Linux]</h2>

<p>```</p>

<p>到此为止，Octopress中添加分类侧边栏并使其支持中文的修改设置已经完毕。</p>

<h1>参考文章</h1>

<ul>
<li><a href="http://www.cnblogs.com/oec2003/archive/2013/05/31/3109577.html">Octopress博客设置</a></li>
<li><a href="http://ikeepu.com/bar/10393365">Octopress博客分类添加中文支持</a></li>
<li><a href="http://khaos.github.io/blog/2012/12/06/using-chinese-category-tags-in-octopress/">Octopress易筋经，中文分类标签</a></li>
<li><a href="http://blog.sprabbit.com/blog/2012/03/23/octopress/">关于在64位 Windows 7 中部署中文化的Octopress</a></li>
<li><a href="http://pfmiles.github.io/blog/liquid-error-about-regexp-match-when-using-octopress-tagcloud/">Liquid Error About Regexp Match When Using Octopress-tagcloud</a></li>
</ul>

]]></content>
  </entry>
  
</feed>

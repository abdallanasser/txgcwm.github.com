<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Unix/Linux | 残剑]]></title>
  <link href="http://txgcwm.github.io/blog/categories/unix-linux/atom.xml" rel="self"/>
  <link href="http://txgcwm.github.io/"/>
  <updated>2013-07-21T01:41:38+08:00</updated>
  <id>http://txgcwm.github.io/</id>
  <author>
    <name><![CDATA[残剑]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[将Emacs配置成一个C/C++的IDE编程环境]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/20/jiang-emacspei-zhi-cheng-%5B%3F%5D-ge-c-slash-c-plus-plus-de-idebian-cheng-huan-jing/"/>
    <updated>2013-07-20T14:47:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/20/jiang-emacspei-zhi-cheng-[?]-ge-c-slash-c-plus-plus-de-idebian-cheng-huan-jing</id>
    <content type="html"><![CDATA[<p>在Linux环境下编程，首先要选择开发工具，大部分程序员都是使用VIM和EMACS这两大神器。虽说它们只是编辑器，但由于其超强的可定制性，已成为广大linux工作者的首选。使用<code>sudo apt-get install emacs</code>来安装Emaces。</p>

<h1>Emacs的基本操作和组合键</h1>

<h2>模式键定义</h2>

<p>四个模式键：C&mdash;-Ctrl；M&mdash;-Alt；s&mdash;-Super(Win)；S&mdash;-Shift</p>

<p>比如：</p>

<p>C-x：表示按下ctrl键，然后按下x键。</p>

<p>C-x c C-c：表示按下ctrl，然后按下x键，松开后再按下c键。</p>

<p>C-x k：表示按下ctrl，同时按下x和k键。</p>

<!--more-->


<h2>基本组合键</h2>

<p>C-x C-c：退出Emacs。</p>

<p>C-x C-s：保存当前buffer。</p>

<p>C-x C-f：打开和新建文件。</p>

<p>C-n：光标移到下一行。</p>

<p>C-p：光标移到上一行。</p>

<p>C-k：删除一行。</p>

<p>M-x：执行命令。</p>

<h1>启动时的大小和屏幕中的位置</h1>

<p>关于修改Emacs启动大小和屏幕中的位置有两种方法：1、修该~/.Xdefault文件，然后运行<code>xrdb ~/.Xdefault</code>；2、在~/.emacs文件中进行修改。按照第二种方法作如下设置：
```
;;设置启动的大小和屏幕中的位置
(setq default-frame-alist</p>

<pre><code>'((height . 35)(width . 100)(menubar-lines . 20)(tool-bar-lines . 0)))
</code></pre>

<p>```
以上语句表示Emacs在启动后其高度为35，宽度为100，显示在屏幕的x=20，y=0处。</p>

<h1>Emacs的基本常规设定</h1>

<p>按照一般的习惯，.emacs文件中一般不会放太多的设置信息，一般放一些emacs的搜索路径信息。这里将emacs的配置文件（即lisp脚本）都放在~/.emacs.d/emacs的文件夹中。因此首先添加一个emacs的搜索路径：
<code>
;;;; 添加Emacs搜索路径
(add-to-list 'load-path "~/.emacs.d/emacs")
(add-to-list 'load-path "~/.emacs.d/emacs/ecb-2.40")
(add-to-list 'load-path "~/.emacs.d/emacs/codepilot")
(add-to-list 'load-path "~/.emacs.d/emacs/emacs-eclim")
(add-to-list 'load-path "~/.emacs.d/emacs/icicles")
(add-to-list 'load-path "~/.emacs.d/emacs/gnuserv")
</code>
然后加载我们对emacs的设置脚本，在.emacs中添加如下语句：
```
;;;;读取脚本
(load &ldquo;base.el&rdquo;)
(load &ldquo;cyexpand.el&rdquo;)
(load &ldquo;cykbd.el&rdquo;)
(load &ldquo;addon.el&rdquo;)</p>

<p>;;编程的配置
(load &ldquo;cycode.el&rdquo;)
<code>
对emacs的基本设置，即base.el文件（在~/.emacs.d/emacs中），base.el文件中的部分内容如下：
</code>
;;显示时间
;;(display-time)
(display-time-mode 1);;启用时间显示设置，在minibuffer上面的那个杠上
(setq display-time-24hr-format t);;时间使用24小时制
(setq display-time-day-and-date t);;时间显示包括日期和具体时间
;;(setq display-time-use-mail-icon t);;时间栏旁边启用邮件设置
;;(setq display-time-interval 10);;时间的变化频率，单位多少来着？</p>

<p>;;显示列号
(setq column-number-mode t)
;;没列左边显示行号,按f3显示/隐藏行号
(require &lsquo;setnu)
(setnu-mode t)
;;(global-set-key[f3] (quote setnu-mode))</p>

<p>;;显示标题栏 %f 缓冲区完整路径 %p 页面百分数 %l 行号
(setq frame-title-format &ldquo;%f&rdquo;)</p>

<p>;;=======================================================================
;;缓冲区
;;=====================================================================
;;设定行距
(setq default-line-spaceing 4)
;;页宽
(setq default-fill-column 60)
;;缺省模式 text-mode
;;(setq default-major-mode &lsquo;text-mode)
;;设置删除记录
(setq kill-ring-max 200)
;;以空行结束
;;(setq require-final-newline t)
;;开启语法高亮。
(global-font-lock-mode 1)
;;高亮显示区域选择
(transient-mark-mode t)
;;页面平滑滚动,scroll-margin 3 靠近屏幕边沿3行开始滚动，正好可以看到上下文
;;(setq scroll-margin 3 scroll-consrvatively 10000)
;;高亮显示成对括号
(show-paren-mode t)
(setq show-paren-style 'parentheses)
;;鼠标指针避光标
(mouse-avoidance-mode 'animate)
;;粘贴于光标处,而不是鼠标指针处
(setq mouse-yank-at-point t)
<code>
设置默认工作目录，即启动emacs后所在的目录，在base.el中加上下面一句：
</code>
;;设置默认工作目录
(setq default-directory &ldquo;/srv&rdquo;)
```</p>

<h1>C/C++的配置</h1>

<p>C/C++的配置主要是cycode.el文件。开发时很重要的一步就是调试，所以首先就是增加图形化调试界面：
<code>
;;==============================================================
;;gdb-UI配置
;;==============================================================
(setq gdb-many-windows t)
(load-library "multi-gud.el")
(load-library "multi-gdb-ui.el")
</code>
上面加载了两个lisp的脚本文件，这两个文件是直接在网上下载的图形化调试文件。</p>

<p>为了能高效的浏览和编辑代码，需要安装cedet插件。从官网下载cedet后，在~/.emacs.d/emacs目录中解压，根据解压出来文件夹中的INSTALL文件说明的方法安装cedet即可。有一点需要注意就是安装完成后不能删除安装后的文件，也就是需要保留解压后的文件夹。安装完成后，用下面的语句将我们需要的一些东西包含进来。
<code>
;;==================================================
;;cedet插件设置
;;==================================================
(add-to-list 'load-path "~/.emacs.d/emacs/cedet-1.1/speedbar")
(add-to-list 'load-path "~/.emacs.d/emacs/cedet-1.1/eieio")
(add-to-list 'load-path "~/.emacs.d/emacs/cedet-1.1/semantic")
</code>
然后就可进行有关cedet的设置，这里仅以一个代码折叠和展开为例：
<code>
;;代码折叠
;;(require 'semantic-tag-folding nil 'noerror)
(global-semantic-tag-folding-mode 1)
;;折叠和打开整个buffer的所有代码
(define-key semantic-tag-folding-mode-map (kbd "C--") 'semantic-tag-folding-fold-all)
(define-key semantic-tag-folding-mode-map (kbd "C-=") 'semantic-tag-folding-show-all)
;;折叠和打开单个buffer的所有代码
(define-key semantic-tag-folding-mode-map (kbd "C-_") 'semantic-tag-folding-fold-block)
(define-key semantic-tag-folding-mode-map (kbd "C-+") 'semantic-tag-folding-show-block)
</code></p>

<p>为了使用更方便（即对上面cedet插件的一个补充），需要再安装一个ecb插件。下载ecb后解压到~/.emacs.d/emacs目录中即可，然后加上下面两句：
<code>
;;==============================================================
;;ecb配置
;;==============================================================
;;(require 'ecb)
;;开启ecb用,M-x:ecb-activate
(require 'ecb-autoloads)
;;自动启动ecb并且不显示每日提示
;;(require 'ecb)
;;(setq ecb-auto-activate t)
(setq ecb-tip-of-the-day nil)
</code>
为了实现自动补全功能，需要安装auto-complete和yasnippet这两个插件。auto-complete下载后放到~/.emacs.d/emacs目录中解压，然后进入解压后的目录输入make命令即可；yasnippet下载后解压到~/.emacs.d/emacs目录中即可。下面是关于这两个插件的配置：
<code>
;;==========================================================
;;YASnippet的配置
;;==========================================================
(require 'yasnippet)    ;;not yasnippet-bundle
(yas/initialize)
(yas/load-directory "~/.emacs.d/emacs/yasnippet-0.6.1c/snippets")
</code>
装完插件后，作一些综合的配置：
```
;;配置Semantic搜索范围
(setq semanticdb-project-roots</p>

<pre><code>  (list
   (expand-file-name "/")))
</code></pre>

<p>;;自定义补全命令，如果单词在中间就补全，否则就tab
(defun my-indent-or-complete()
  (interactive)
  (if (looking-at &ldquo;\>&rdquo;)</p>

<pre><code>  (hippie-expand nil)
  (indent-for-tab-command))
</code></pre>

<p>  )
;;补全快捷键，ctrl+tab用senator补全，不显示列表
;;alt+/补全，显示列表让选择
(global-set-key [(control tab)] &lsquo;my-indent-or-complete)
(define-key c-mode-base-map [(meta ?/)] 'semantic-ia-complete-symbol-menu)
(autoload 'senator-try-expand-semantic &ldquo;senator&rdquo;)
(setq hippie-expand-try-functions-list</p>

<pre><code>  '(
    senator-try-expand-semantic
    try-expand-dabbrev
    try-expand-dabbrev-visible
    try-expand-dabbrev-all-buffers
    try-expand-dabbrev-from-kill
    try-expand-list
    try-expand-list-all-buffers
    try-expand-line
    try-expand-line-all-buffers
    try-complete-file-name-partially
    try-complete-file-name
    try-expand-whole-kill
    )
  )
</code></pre>

<p>```</p>

<h1>键绑定</h1>

<p>为了使用emacs更方便，需要一些键绑定（即自己定义一些组合键），这也是emacs配置中必不可少的一步。自定义组合键放在cykbd.el文件中。根据一般的习惯用f1来表示帮助，即man命令：
<code>
(global-set-key [f1] 'manual-entry)
(global-set-key [C-f1] 'info )
</code>
f3-f5的一些绑定：
```
;;f3为查找字符串,alt+f3关闭当前缓冲区
(global-set-key [f3] &lsquo;grep-find)
(global-set-key [M-f3] 'kill-this-buffer)</p>

<p>;;.emacs中设一个speedbar的快捷键
(global-set-key [(f4)] &lsquo;speedbar-get-focus)
;;ctrl-f4,激活,ecb
(global-set-key [C-f4] 'ecb-activate)</p>

<p>;;F5显示/隐藏工具栏 方便调试
(global-set-key [f5] &lsquo;tool-bar-mode)
;;ctrl-F5显示/隐藏菜单栏 ;; M-x menu-bar-open
(global-set-key [C-f5] 'menu-bar-mode)
<code>
f6为gdb调试，f7调用make来对原文件进行编译：
</code>
(global-set-key [f6] 'gdb)</p>

<p>;;  C-f7, 设置编译命令; f7, 保存所有文件然后编译当前窗口文件
(defun du-onekey-compile ()
  &ldquo;Save buffers and start compile&rdquo;
  (interactive)
  (save-some-buffers t)
  (switch-to-buffer-other-window &ldquo;<em>compilation</em>&rdquo;)
  (compile compile-command))</p>

<p>(setq-default compile-command &ldquo;make&rdquo;)  <br/>
(global-set-key [C-f7] &lsquo;compile)
 (global-set-key [f7] 'du-onekey-compile)
```</p>

<p>将f8为对buffer的一些常用操作：
```
;;目的是开一个shell的小buffer，用于更方便地测试程序(也就是运行程序了)，我经常会用到。
;;f8就是另开一个buffer然后打开shell，C-f8则是在当前的buffer打开shell,shift+f8清空eshell
(defun open-eshell-other-buffer ()
  &ldquo;Open eshell in other buffer&rdquo;
  (interactive)
  (split-window-vertically)
  (eshell))
(defun my-eshell-clear-buffer ()
  &ldquo;Eshell clear buffer.&rdquo;
  (interactive)
  (let ((eshell-buffer-maximum-lines 0))</p>

<pre><code>(eshell-truncate-buffer)))
</code></pre>

<p>(global-set-key [(f8)] &lsquo;open-eshell-other-buffer)
(global-set-key [C-f8] 'eshell)
(global-set-key [S-f8] 'my-eshell-clear-buffer)
<code>
f9-f11的一些绑定：
</code>
;;设置[C-f9]为调用dired命令
(global-set-key [C-f9] 'dired)
(global-set-key [f9] 'other-window);f9在其他窗口之间旋转</p>

<p>;;设置F10为撤销
(global-set-key [C-f10] &lsquo;undo)</p>

<p>;;设置F11快捷键指定Emacs 的日历系统
(global-set-key [C-f11] &lsquo;calendar)
<code>
用f12查看函数定义：
</code>
;;设置C-F12 快速察看日程安排
;;F12调到函数定义
(global-set-key [f12] 'semantic-ia-fast-jump)
(global-set-key [C-f12] 'list-bookmarks)
;;shift-f12跳回去
(global-set-key [S-f12]</p>

<pre><code>(lambda ()
(interactive)
(if (ring-empty-p (oref semantic-mru-bookmark-ring ring))
(error "Semantic Bookmark ring is currently empty"))
(let* ((ring (oref semantic-mru-bookmark-ring ring))
(alist (semantic-mrub-ring-to-assoc-list ring))
(first (cdr (car alist))))
(if (semantic-equivalent-tag-p (oref first tag)
(semantic-current-tag))
(setq frist (cdr (car (cdr alist)))))
(semantic-mrub-switch-tags first))))
</code></pre>

<p><code>
对ecb的键绑定：
</code>
;;==================ecb的配置=================================
;;为了ecb窗口的切换
(global-set-key [M-left] &lsquo;windmove-left)
(global-set-key [M-right] 'windmove-right)
(global-set-key [M-up] 'windmove-up)
(global-set-key [M-down] 'windmove-down)
;;隐藏和显示ecb窗口
(global-set-key [f11] 'ecb-hide-ecb-windows)
(global-set-key [S-f11] 'ecb-show-ecb-windows)
<code>
对窗口的一些键绑定：
</code>
;;关闭当前窗口,alt+4
(global-set-key (kbd &ldquo;M-4&rdquo;) 'delete-window)
;;(global-set-key (kbd &ldquo;M-4&rdquo;) 'kill-this-buffer)
;;关闭其他窗口,alt+1
(global-set-key (kbd &ldquo;M-1&rdquo;) 'delete-other-windows)
;;水平分割窗口,alt+2
(global-set-key (kbd &ldquo;M-2&rdquo;) 'split-window-vertically)
;;垂直分割窗口,alt+3
(global-set-key (kbd &ldquo;M-3&rdquo;) 'split-window-horizontally)
;;切换到其他窗口，alt+0
(global-set-key (kbd &ldquo;M-0&rdquo;) 'other-window)
;;显示缓冲区完整名称
(global-set-key (kbd &ldquo;M-5&rdquo;) 'display-buffer-name)
```</p>

<h1>Emacs的扩展配置</h1>

<p>为了使emacs更符合个人的习惯，增加了一个cyexpand.el配置文件，其部分设置如下：
```
;; 编码设置
(require &lsquo;coding-settings)</p>

<p>;; `mode-line'显示格式
(require &lsquo;mode-line-settings)</p>

<p>;; 各种语言开发方面的设置,这个设置牵涉到太多配置&hellip;.
(require &lsquo;dev-settings)</p>

<p>;; 显示行号
(require &lsquo;linum-settings)</p>

<p>;; color theme Emacs主题,很多face文件
(require &lsquo;color-theme-settings)</p>

<p>(require &lsquo;ahei-face)
(require 'color-theme-ahei)
(require 'face-settings)</p>

<p>;; 高亮当前行
(require &lsquo;hl-line-settings)</p>

<p>;; 字体配置
(require &lsquo;font-settings)
;; diff
(require 'diff-settings)
;; Emacs的diff: ediff,有个my-fontest-win的文件很关键
(require 'ediff-settings)</p>

<p>;; 在buffer中方便的查找字符串: color-moccur
(require &lsquo;moccur-settings)
;; Emacs超强的增量搜索Isearch配置
(require 'isearch-settings)</p>

<p>;; 增加更丰富的高亮
(require &lsquo;generic-x)</p>

<p>;; spell check
(setq-default ispell-program-name &ldquo;aspell&rdquo;)</p>

<p>;; Emacs中的包管理器
(require &lsquo;package)
(package-initialize)</p>

<p>;; 在Emacs里面使用shell
(require &lsquo;term-settings)
(require 'multi-term-settings)</p>

<p>;; 可以把光标由方块变成一个小长条
(require &lsquo;bar-cursor)
```</p>

<p>到此为止，已经将emacs打造成了开发C/C++的简易IDE。在使用过程中只需要会配置base.el、cycode.el、cykbd.el、cyexpand.el这四个文件即可，相关配置文件和插件可以到 <a href="https://github.com/txgcwm/emacs.d">这里</a> 下载。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Uboot中TFTP解释]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/19/ubootzhong-tftpjie-shi/"/>
    <updated>2013-07-19T22:45:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/19/ubootzhong-tftpjie-shi</id>
    <content type="html"><![CDATA[<p>TFTP在Uboot中用于发送较小的文件，使用UDP协议，发送使用69端口，每次发送的最大分组为512 bytes，发送双方采用超时重传机制，数据传输模式为octet模式（二进制模式）。发送文件时使用<code>tftp MemoryAddress FileName</code>命令即可，其中MemoryAddress为放入文件的内存首地址，FileName为传送文件的文件名。</p>

<p>使用TFTP传送文件的步骤：</p>

<ol>
<li>使用时已经初始化以下变量：NetOurIP（本机IP地址，定义在Net.c文件）、NetServerIP（TFTP服务器的IP地址，定义在Net.c文件）、BootFile（需要传送文件的文件名，定于在tftp.c）、NetOurGatewayIP（本机的网关地址）、NetOurSubnetMask（本机子网掩码）。</li>
<li>调用TftpStart 函数开始文件传送。</li>
</ol>


<!--more-->


<h1>客户端状态</h1>

<p>TFTP使用一个变量TftpState来描述TFTP客户端可能的5种状态：</p>

<p><img src="/images/2013/7/tftp/states.png" alt=" states " /></p>

<h1>包类型</h1>

<p>使用TFTP传送的包分为6种类型：</p>

<p><img src="/images/2013/7/tftp/types.png" alt=" types " /></p>

<h1>各种包结构</h1>

<p>TFTP协议中各种包的结构：</p>

<p><img src="/images/2013/7/tftp/pack_struct.png" alt=" pack_struct " /></p>

<p>Uboot中客户端发送的包的包括RRQ和ACK。RRQ（请求读的包）包的结构:</p>

<p><img src="/images/2013/7/tftp/rrq.png" alt=" rrq " /></p>

<p>ACK（确认帧）结构：</p>

<p><img src="/images/2013/7/tftp/ack.png" alt=" ack " /></p>

<h1>主要函数及作用</h1>

<p>Uboot中与tftp协议有关的文件有tftp.c与tftp.h文件，主要函数包括：
```
/<em> 根据预先设定的地址load_addr决定将首地址为src，长度为len的block个数据块写入flash 或写入内存</em>/
static <strong>inline</strong> void store_block (unsigned block, uchar * src, unsigned len);</p>

<p>/<em> 根据TftpState变量的不同值发送不同的 Tftp包 （使用UDP协议发送） </em>/
static void TftpSend (void) ;</p>

<p>/<em> 处理收到的Tftp包 </em>/
static void TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len) ;</p>

<p>/<em> 超时处理函数 </em>/
static void TftpTimeout (void);</p>

<p>/<em> 初始化各个需要的数据 然后开始发送TFTP读请求 </em>/
void TftpStart (void);
```</p>

<h1>流程</h1>

<p>TFTP总体流程：首先客户端发出读写请求，如果服务器批准此请求，则打开连接并接收第一个数据包。客户端收到数据包后发回确认，而服务器发出下一个数据包以前必须得到客户对上一个数据包的确认。如果数据包在传输过程中丢失，服务器方会在超时后重新传输最后一个未被确认的数据包。发送的数据包一般为512字节，如果一个数据包小于 512 字节，则表示这个包是最后一个包，如果发送的数据正好是 512 的整数倍，发送完后再发一个空包。</p>

<p>以下是客户端和服务器端通信的流程图：</p>

<p><img src="/images/2013/7/tftp/flow.png" alt=" flow " /></p>

<p>客户端程序流程：</p>

<ol>
<li>客户端设定NetOurIP 、NetServerIP、BootFile 变量的值。</li>
<li>调用TftpStart函数完成如下6步工作：（1）若BootFile为空则使用默认文件名，否则使用BootFile为传送的文件名。（2）比较客户端和服务器的子网地址，判断两者是否在同一个子网内。（3）设定超时处理函数为TftpTimeout 。（4）设置处理接收到的TFTP包的函数为TftpHandler。（5）初始化服务器端口、本机端口、超时次数为0、初始状态为RRQ。（6）调用TftpSend函数发送TFTP读取请求。</li>
<li>TftpSend函数根据TftpState发送不同的包，同时根据包的类型和当前客户端的状态（TftpState）处理接收到的包。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下c语言获取网络接口IP地址]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/19/linuxxia-cyu-yan-huo-qu-wang-luo-jie-kou-ipdi-zhi/"/>
    <updated>2013-07-19T22:34:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/19/linuxxia-cyu-yan-huo-qu-wang-luo-jie-kou-ipdi-zhi</id>
    <content type="html"><![CDATA[<p>在Linux环境下，可以使用以下的代码获取网络的ip地址：
```</p>

<pre><code>if (gethostname(host, sizeof(host)) &lt; 0) {
    printf("Can't get hostname\n");
    return -1;
}
if ((hp = gethostbyname(host)) == NULL) {
    printf("Can't get host address\n");
    return -1;
}
memcpy((char *) &amp;intaddr, (char *) hp-&gt;h_addr_list[0],
        (size_t) hp-&gt;h_length);
</code></pre>

<p>```</p>

<!--more-->


<p>在嵌入式系统中，使用goahead的时候， 以上代码是获取不到正确ip地址的，我们可以结合以下两个接口函数去获取需要的ip地址：
```</p>

<pre><code>#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;net/if.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;


static int getIfaceName(char *iface_name, int len)
{
    int r = -1;
    int flgs, ref, use, metric, mtu, win, ir;
    unsigned long int d, g, m;    
    char devname[20];
    FILE *fp = NULL;

    if((fp = fopen("/proc/net/route", "r")) == NULL) {
        perror("fopen error!\n");
        return -1;
    }

    if (fscanf(fp, "%*[^\n]\n") &lt; 0) {
        fclose(fp);
        return -1;
    }

    while (1) {
        r = fscanf(fp, "%19s%lx%lx%X%d%d%d%lx%d%d%d\n",
                 devname, &amp;d, &amp;g, &amp;flgs, &amp;ref, &amp;use,
                 &amp;metric, &amp;m, &amp;mtu, &amp;win, &amp;ir);
        if (r != 11) {
            if ((r &lt; 0) &amp;&amp; feof(fp)) {
                break;
            }
            continue;
        }

        strncpy(iface_name, devname, len);
        fclose(fp);
        return 0;
    }

    fclose(fp);

    return -1;
}

static int getIpAddress(char *iface_name, char *ip_addr, int len)
{
    int sockfd = -1;
    struct ifreq ifr;
    struct sockaddr_in *addr = NULL;

    memset(&amp;ifr, 0, sizeof(struct ifreq));
    strcpy(ifr.ifr_name, iface_name);
    addr = (struct sockaddr_in *)&amp;ifr.ifr_addr;
    addr-&gt;sin_family = AF_INET;

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
        perror("create socket error!\n");
        return -1;
    }

    if (ioctl(sockfd, SIOCGIFADDR, &amp;ifr) == 0) {
        strncpy(ip_addr, inet_ntoa(addr-&gt;sin_addr), len);
        close(sockfd);
        return 0;
    }

    close(sockfd);

    return -1;
}

int main(int argc, char** argv)
{
    struct in_addr    intaddr;
    char iface_name[20];

    if(getIfaceName(iface_name, sizeof(iface_name)) &lt; 0) {
        printf("get interface name error!\n");
        return -1;
    }

    if(getIpAddress(iface_name, (char *) &amp;intaddr, 15) &lt; 0) {
        printf("get interface ip address error!\n");
        return -1;
    }

    printf("address:%s\n",(char *) &amp;intaddr);

    return 0;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu下编译vlc-android源代码]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/19/ubuntuxia-bian-yi-vlc-androidyuan-dai-ma/"/>
    <updated>2013-07-19T21:18:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/19/ubuntuxia-bian-yi-vlc-androidyuan-dai-ma</id>
    <content type="html"><![CDATA[<p>在编译源码前，需要先安装Android的SDK、NDK以及一些必需的软件，具体安装方法这里就不再详述了，网上可以找到很多相应的文章。安装软件可以执行以下指令：
<code>
$ apt-get install  apache-ant(or ant)  autoconf automake autopoint  libtool  gawk (or nawk)
gcc  g++  pkg-config  cmake  patch subversion git
</code>
ant工具在最后编译android源码生成apk文件会用到，所以需要安装。如果手动安装了ant，需要在环境变量中配置好ant的 path，或者在编译前执行命令<code>export PATH=$PATH:/xxx/ant/bin</code>，保证可以在执行编译的命令行中执行ant命令即可。</p>

<!--more-->


<h1>环境变量配置</h1>

<p>配置ANDROID_SDK（请把path改为自己的路径）
<code>
$ export ANDROID_SDK=/path/to/android-sdk
</code>
配置ANDROID_NDK
<code>
$ export ANDROID_NDK=/path/to/android-ndk
</code>
配置PATH变量
<code>
$ export PATH=$PATH:$ANDROID_SDK/tools:$ANDROID_SDK/platform-tools
</code>
配置NEON相关信息（一般编译的时候，会编译NO_NEON和支持NEON两种包出来）
<code>
$ export NO_NEON=1
</code>
如果设备不支持NEON技术，请务必配置此项；如果机器支持NEON技术，可以不用配置此项。关于NEON的简单信息：根据维基百科英文版ARM架构中的介绍，Cortex-A8架构的设备均支持NEON技术，而在Cortex-A9架构的设备中则是可选的，更多信息请参考 <a href="http://www.arm.com/zh/products/processors/technologies/neon.php">NEON</a> 和 <a href="http://en.wikipedia.org/wiki/ARM_architecture#Advanced_SIMD_.28NEON.29">ARM architecture</a> 。</p>

<p>配置ABI
<code>
$ export ANDROID_ABI=armeabi-v7a
</code></p>

<h1>获取源码</h1>

<p><code>
$ git clone git://git.videolan.org/vlc-ports/android.git
</code></p>

<h1>编译源码</h1>

<p>下载完成后，进入android文件夹执行<code>sh compile.sh</code>，开始自动编译。如果编译过程中遇到错误：
<code>
checking host system type… Invalid configuration `arm-linux-androideabi’: system
`androideabi’ not recognized
</code>
请在重新编译之前执行以下操作：1. 到 <a href="http://git.savannah.gnu.org/gitweb/?p=config.git;a=tree">这里</a>下载最新的config.guess和config.sub文件；2. 将下载的文件拷贝到/usr/share/misc目录下；3. 重新启动编译。</p>

<p>最后提示BUILD SUCESSFUL，说明编译成功了，在android/vlc-android/bin目录下会生成一个apk文件，可以直接拿来安装。如果想自己调整界面部分，或者添加、修改其它功能，可以直接把项目导入eclipse进行开发。</p>

<h1>出错处理</h1>

<p>如果编译过程中提示缺少某一软件的错误，请根据错误提示安装对应的工具，或者在执行编译之前就把之前提到的工具全部安装好。</p>

<p>出错信息：
```
 CC     posix/plugin.lo
../../src/posix/plugin.c: In function &lsquo;module_Load&rsquo;:
../../src/posix/plugin.c:50:50: warning: unused parameter &lsquo;lazy&rsquo; [-Wunused-parameter]
  CC     posix/thread.lo
../../src/posix/thread.c:85:5: warning: #warning Monotonic clock not available. Expect timing issues. [-Wcpp]
../../src/posix/thread.c: In function &lsquo;vlc_cancel&rsquo;:
../../src/posix/thread.c:830:5: error: implicit declaration of function &lsquo;pthread_cancel&rsquo; [-Werror=implicit-function-declaration]
../../src/posix/thread.c: In function &lsquo;vlc_savecancel&rsquo;:
../../src/posix/thread.c:847:5: error: implicit declaration of function &lsquo;pthread_setcancelstate&rsquo; [-Werror=implicit-function-declaration]
../../src/posix/thread.c:847:39: error: &lsquo;PTHREAD_CANCEL_DISABLE&rsquo; undeclared (first use in this function)
../../src/posix/thread.c:847:39: note: each undeclared identifier is reported only once for each function it appears in
../../src/posix/thread.c: In function &lsquo;vlc_restorecancel&rsquo;:
../../src/posix/thread.c:867:9: error: &lsquo;PTHREAD_CANCEL_DISABLE&rsquo; undeclared (first use in this function)
../../src/posix/thread.c: In function &lsquo;vlc_testcancel&rsquo;:
../../src/posix/thread.c:884:5: error: implicit declaration of function &lsquo;pthread_testcancel&rsquo; [-Werror=implicit-function-declaration]
cc1: some warnings being treated as errors</p>

<p>make[3]: <strong><em> [posix/thread.lo] Error 1
make[3]: Leaving directory <code>/srv/android/vlc/android/src'
make[2]: *** [all] Error 2
make[2]: Leaving directory</code>/srv/android/vlc/android/src'
make[1]: </em></strong> [all-recursive] Error 1
make[1]: Leaving directory `/srv/android/vlc/android'
make: *** [all] Error 2
```</p>

<p>解决方法：
进入下载的android vlc目录，执行以下指令。
<code>
$ cd vlc
$ git reset --hard origin
$ git pull origin master
$ git checkout -b android ${TESTED_HASH}
$ git am ../patches/*
</code></p>

<p>注：在老的git版本中git checkout并没有-B的选项，所以一开始执行的时候并没有下载android版本的vlc代码，故使用<code>git checkout -b android ${TESTED_HASH}</code>。</p>

<p>出错信息：
```
BUILD FAILED
/usr/local/android-sdk-linux/tools/ant/build.xml:517: Unable to resolve project target &lsquo;android-15&rsquo;</p>

<p>Total time: 3 seconds
make: *** [vlc-android/bin/VLC-debug.apk] Error 1
rm android-libs/libmedia.c android-libs/libutils.c android-libs/libstagefright.c android-libs/libbinder.c
```</p>

<p>解决方法：
进入到android-sdk-linux/tools目录，执行<code>./android</code>下载Android 4.0.3（API15）的相关文件。</p>

<p>出错信息：
```
curl -f -L &mdash; &ldquo;<a href="http://git.xiph.org/?p=speex.git;a=snapshot;h=HEAD;sf=tgz">http://git.xiph.org/?p=speex.git;a=snapshot;h=HEAD;sf=tgz</a>&rdquo; > &ldquo;../../contrib/tarballs/speex-git.tar.gz&rdquo;
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>

<pre><code>                             Dload  Upload   Total   Spent    Left  Speed
</code></pre>

<p>100   814  100   814    0     0    226      0  0:00:03  0:00:03 &mdash;:&mdash;:&mdash; 23941
../../contrib/src/speex/rules.mak:20: .sum-speex not implemented
touch .sum-speex
touch -r .sum-speex .sum-speexdsp
rm -Rf speex-git
mkdir -p speex-git
zcat &ldquo;../../contrib/tarballs/speex-git.tar.gz&rdquo; | (cd speex-git &amp;&amp; tar xv &mdash;strip-components=1)</p>

<p>gzip: ../../contrib/tarballs/speex-git.tar.gz: not in gzip format
tar: This does not look like a tar archive
tar: Exiting with failure status due to previous errors
make: *** [speex] Error 2
```</p>

<p>解决方法：
将<code>http://git.xiph.org/?p=speex.git;a=snapshot;h=HEAD;sf=tgz</code>输入到浏览器地址栏中就会开始下载你所需要的文件，然后将相应下载的压缩文件存放于contrib/tarballs/目录下，将名字改成speex-git.tar.gz。若碰到其它的库文件有类似的错误，可采用该办法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用libevent编写Linux服务]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/18/shi-yong-libeventbian-xie-linuxfu-wu/"/>
    <updated>2013-07-18T19:01:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/18/shi-yong-libeventbian-xie-linuxfu-wu</id>
    <content type="html"><![CDATA[<p>libevent是一个事件触发的网络库，适用于windows、linux、bsd等多种平台，内部使用select、epoll、kqueue等系统调用管理事件机制，著名分布式缓存软件memcached也使用到了该库。</p>

<h1>初始化事件</h1>

<p>首先完成对libenvent的事件初始化和事件驱动模型的选择。在使用多线程的情况下，一般我们需获取所返回的事件根基。
<code>
main_base = event_init();
</code>
event_init函数返回的是一个event_base对象，该对象包括了事件处理过程中的一些全局变量，其结构为：
```
struct event_base {</p>

<pre><code>const struct eventop *evsel;
void *evbase;
int event_count;        /* counts number of total events */
int event_count_active; /* counts number of active events */
int event_gotterm;      /* Set to terminate loop */
int event_break;        /* Set to terminate loop immediately */
/* active event management */
struct event_list **activequeues;
int nactivequeues;
/* signal handling info */
struct evsignal_info sig;
struct event_list eventqueue;
struct timeval event_tv;
struct min_heap timeheap;
struct timeval tv_cache;
</code></pre>

<p>};
```</p>

<!--more-->


<h1>添加事件</h1>

<p>事件初始化完毕后，可以使用event_set设置事件，然后使用event_add将其加入。首先完成socket的监听，然后将其加入到事件队列中（这里对所有的异常都不做考虑）。</p>

<p>（1）socket监听
```
struct sockaddr_in listen_addr;</p>

<p>int port = 10000; //socket监听端口
int listen_fd = socket(AF_INET, SOCK_STREAM, 0);</p>

<p>memset(&amp;listen_addr, 0, sizeof(listen_addr));</p>

<p>listen_addr.sin_family = AF_INET;
listen_addr.sin_addr.s_addr = INADDR_ANY;
listen_addr.sin_port = htons(port)</p>

<p>reuseaddr_on = 1;</p>

<p>/<em>支持端口复用</em>/
setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr_on, sizeof(reuseaddr_on));</p>

<p>bind(listen_fd, (struct sockaddr *) &amp;listen_addr, sizeof(listen_addr));
listen(listen_fd, 1024);</p>

<p>/<em>将描述符设置为非阻塞</em>/
int flags = fcntl(listen_fd,F_GETFL);
flags |= O_NONBLOCK;
fcntl(listen_fd, F_SETFL, flags);
```
（2）事件设置</p>

<p>socket服务建立后，就可以进行事件设置。使用event_set来设置事件对象，其传入参数包括事件根基(event_base对象)，描述符，事件类型，事件发生时的回调函数，回调函数传入参数。其中事件类型包括EV_READ、EV_WRITE、EV_PERSIST，EV_PERSIST和前两者结合使用，表示该事件为持续事件。
```
struct event ev;</p>

<p>event_set(&amp;ev, listen_fd, EV_READ | EV_PERSIST, accept_handle, (void *)&amp;ev);
```
（3）事件添加与删除</p>

<p>事件设置好后，就可以将其加入事件队列。event_add用来将事件加入，它接受两个参数：要添加的事件和时间的超时值。如果需要将事件删除，可以使用event_del来完成。event_del函数会取消所指定的事件。
<code>
event_add(&amp;ev, NULL)
</code></p>

<h1>进入事件循环</h1>

<p>libevent提供了多种方式来进入事件循环，常用的是event_dispatch和event_base_loop，前者最后实际是使用当前事件根基来调用event_base_loop。
<code>
event_base_loop(main_base, 0);
</code></p>

<h1>处理连接</h1>

<p>已经完成了事件的设置、事件的添加并进入到了事件循环，但是当事件发生时又如何处理呢？ 当连接建立时回调函数accept_handle会自动的得到调用。对于缓冲区的读写在非阻塞式网络编程中是一个难以处理的问题，幸运的是libevent提供了bufferevent和evbuf来替我们完成该项工作。这里我们采用bufferevent来处理。</p>

<p>（1）生成bufferevent对象</p>

<p>使用bufferevent_new对象来生成bufferevent对象，并分别指定读、写、连接错误时的处理函数和函数传入参数。</p>

<p>（2）设置读取量</p>

<p>bufferevent的读事件激活以后，即使用户没有读取完bufferevent缓冲区中的数据, bufferevent读事件也不会再次被激活。因为bufferevent的读事件是由其所监控的描述符的读事件激活的，只有描述符可读，读事件才会被激活。可通过设置wm_read.high来控制bufferevent从描述符缓冲区中读取的数据量。</p>

<p>（3）将事件加入事件队列</p>

<p>和前面一样，在事件设置好后，需将事件加入到事件队列中， 不过bufferevent的有自己专门的加入函数bufferevent_base_set和激活函数bufferevent_enable。bufferevent接收两个参数事件根基和事件对象，前者用来指定事件将加入到哪个事件根基中，后者说明需将那个bufferevnet事件加入。在bufferevent初始化完毕后，可以使用bufferevent_enable和bufferevent_disable反复的激活与禁止事件，其接收参数为事件对象和事件标志。其中标志参数为EV_READ和EV_WRITE。
```
void accept_handle(const int sfd, const short event, void *arg)
{</p>

<pre><code>struct sockaddr_in addr;

socklen_t addrlen = sizeof(addr);

int fd = accept(sfd, (struct sockaddr *) &amp;addr, &amp;addrlen); //处理连接

buf_ev = bufferevent_new(fd,   buffered_on_read, NULL, NULL, fd)
buf_ev-&gt;wm_read.high = 4096
bufferevent_base_set(main_base, buf_ev);
bufferevent_enable(buf_ev, EV_READ);
</code></pre>

<p>}
```</p>

<h1>读取缓冲区</h1>

<p>当缓冲区读就绪时会自动激活前面注册的缓冲区读函数，我们可以使用bufferevent_read函数来读取缓冲区，bufferevent_read函数参数分别为:所需读取的事件缓冲区，读入数据的存放地，希望读取的字节数。函数返回实际读取的字节数。注意：即时缓冲区未读完，事件也不会再次被激活（除非再次有数据）。因此此处需反复读取直到全部读取完毕。</p>

<h1>写回客户端</h1>

<p>bufferevent系列函数不但支持读取缓冲区，而且支持写缓冲区（即将结果返回给客户端）。
```
void buffered_on_read(struct bufferevent *bev, void * arg){</p>

<pre><code>char buffer[4096]

ret = bufferevent_read(bev, &amp;buffer, 4096);
bufferevent_write(bef, (void *)&amp;buffer, 4096);
</code></pre>

<p>}
```</p>

<h1>异步事件处理示例</h1>

<p>利用libevent编写服务端程序，主要有4部分。
（1）创建主通知链base
<code>
base = event_base_new();
</code>
（2）创建要监听的事件，并将其加入到主通知链中。
<code>
listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void*)base);
event_add(listener_event, NULL);
event_free( listener_event ); //释放由event_new申请的结构体
</code>
（3）主循环
<code>
event_base_dispatch(base);
</code>
（4）释放
<code>
event_base_free(base);
</code>
以下程序中do_read, do_write是异步的，为了解决了异步之间的问题，程序使用了state这个结构体变量将do_read和do_write联系起来。
```</p>

<pre><code>#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;event2/event.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;

#define MAX_LINE 16384
#define PORT 9999

void do_read(evutil_socket_t fd, short events, void *arg);
void do_write(evutil_socket_t fd, short events, void *arg);

struct fd_state {
    char buffer[MAX_LINE];
    size_t buffer_used;

    size_t n_written;
    size_t write_upto;

    struct event *read_event;
    struct event *write_event;
};

struct fd_state *alloc_fd_state(struct event_base *base, evutil_socket_t fd)
{
    struct fd_state *state =
     (struct fd_state *)malloc(sizeof(struct fd_state));
    if (!state) {
        return NULL;
    }

    state-&gt;read_event =
     event_new(base, fd, EV_READ | EV_PERSIST, do_read, state);
    if (!state-&gt;read_event) {
        free(state);
        return NULL;
    }

    state-&gt;write_event =
     event_new(base, fd, EV_WRITE | EV_PERSIST, do_write, state);
    if (!state-&gt;write_event) {
        event_free(state-&gt;read_event);
        free(state);
        return NULL;
    }

    assert(state-&gt;write_event);

    return state;
}

void free_fd_state(struct fd_state *state)
{
    event_free(state-&gt;read_event);
    event_free(state-&gt;write_event);
    free(state);
}

void do_read(evutil_socket_t fd, short events, void *arg)
{
    struct fd_state *state = arg;
    char buf[1024];
    int i;
    ssize_t result;
    while (1) {
        // assert(state-&gt;write_event);
        result = recv(fd, buf, sizeof(buf), 0);
        if (result &lt;= 0)
            break;
        printf("[%s][%d]buf=[%s]len=[%d]\n", __FILE__, __LINE__, buf,
         result);
    }

    memcpy(state-&gt;buffer, "reply", sizeof("reply"));
    assert(state-&gt;write_event);
    event_add(state-&gt;write_event, NULL);
    state-&gt;write_upto = state-&gt;buffer_used;

    if (result == 0) {
        free_fd_state(state);
    } else if (result &lt; 0) {
        if (errno == EAGAIN)    // XXXX use evutil macro
            return;
        perror("recv");
        free_fd_state(state);
    }
}

void do_write(evutil_socket_t fd, short events, void *arg)
{
    struct fd_state *state = arg;

    //while (state-&gt;n_written &lt; state-&gt;write_upto)
    {
        //ssize_t result = send(fd, state-&gt;buffer + state-&gt;n_written,
        //state-&gt;write_upto - state-&gt;n_written, 0);
        ssize_t result =
         send(fd, state-&gt;buffer, strlen(state-&gt;buffer), 0);
        if (result &lt; 0) {
            if (errno == EAGAIN)    // XXX use evutil macro
                return;
            free_fd_state(state);
            return;
        }
        assert(result != 0);
        state-&gt;n_written += result;
    }

    //if (state-&gt;n_written == state-&gt;buffer_used)
    {
        state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = 1;
    }

    event_del(state-&gt;write_event);
}

void do_accept(evutil_socket_t listener, short event, void *arg)
{
    struct event_base *base = arg;
    struct sockaddr_storage ss;
    socklen_t slen = sizeof(ss);

    int fd = accept(listener, (struct sockaddr *)&amp;ss, &amp;slen);
    if (fd &lt; 0) {        // XXXX eagain??
        perror("accept");
    } else if (fd &gt; FD_SETSIZE) {
        close(fd);    // XXX replace all closes with EVUTIL_CLOSESOCKET */
    } else {
        struct fd_state *state;
        evutil_make_socket_nonblocking(fd);
        state = alloc_fd_state(base, fd);

        assert(state);    /*XXX err */
        assert(state-&gt;write_event);
        event_add(state-&gt;read_event, NULL);
    }
}

int main(int argc, char **argv)
{
    evutil_socket_t listener;
    struct sockaddr_in sin;
    struct event_base *base;
    struct event *listener_event;

    setvbuf(stdout, NULL, _IONBF, 0);

    base = event_base_new();
    if (!base)
        return -1;        /*XXXerr */

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(PORT);

    listener = socket(AF_INET, SOCK_STREAM, 0);
    evutil_make_socket_nonblocking(listener);

#ifndef WIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one,
             sizeof(one));
    }
#endif

    if (bind(listener, (struct sockaddr *)&amp;sin, sizeof(sin)) &lt; 0) {
        perror("bind");
        return -1;
    }

    if (listen(listener, 16) &lt; 0) {
        perror("listen");
        return -1;
    }

    listener_event =
     event_new(base, listener, EV_READ | EV_PERSIST, do_accept,
         (void *)base);
    /*XXX check it */
    event_add(listener_event, NULL);
    event_base_dispatch(base);
    event_base_free(base);

    return 0;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>

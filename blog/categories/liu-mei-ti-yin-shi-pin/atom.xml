<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 流媒体/音视频 | 残剑]]></title>
  <link href="http://txgcwm.github.io/blog/categories/liu-mei-ti-yin-shi-pin/atom.xml" rel="self"/>
  <link href="http://txgcwm.github.io/"/>
  <updated>2014-02-17T21:30:39+08:00</updated>
  <id>http://txgcwm.github.io/</id>
  <author>
    <name><![CDATA[残剑]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[wav文件格式解析]]></title>
    <link href="http://txgcwm.github.io/blog/2014/02/16/wavwen-jian-ge-shi-jie-xi/"/>
    <updated>2014-02-16T21:54:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2014/02/16/wavwen-jian-ge-shi-jie-xi</id>
    <content type="html"><![CDATA[<p>WAVE文件是多媒体中使用的声波文件格式之一，以RIFF格式为标准。RIFF是英文Resource Interchange File Format的缩写，每个WAVE文件的头四个字节便是<code>RIFF</code>。WAVE文件是由若干个Chunk组成的，按照在文件中的出现位置包括：RIFF WAVE Chunk, Format Chunk, Fact Chunk(可选), Data Chunk。具体见下图：</p>

<pre><code>------------------------------------------------
|             RIFF WAVE Chunk                  |
|             ID  = 'RIFF'                     |
|             RiffType = 'WAVE'                |
------------------------------------------------
|             Format Chunk                     |
|             ID = 'fmt '                      |
------------------------------------------------
|             Fact Chunk(optional)             |
|             ID = 'fact'                      |
------------------------------------------------
|             Data Chunk                       |
|             ID = 'data'                      |
------------------------------------------------
</code></pre>

<p>其中除了Fact Chunk外，其它三个Chunk是必须的。每个Chunk有各自的ID，位于Chunk最开始位置，作为标示（均为4个字节），并且紧跟在ID后面的是Chunk大小（去除ID和Size所占的字节数后剩下的其它字节数目），4个字节表示，低字节表示数值低位，高字节表示数值高位。</p>

<p>RIFF WAVE Chunk</p>

<pre><code>----------------------------------
|       | 所占字节数 |  具体内容    |
----------------------------------
| ID    |  4 Bytes |   'RIFF'    |
----------------------------------
| Size  |  4 Bytes |             |
----------------------------------
| Type  |  4 Bytes |   'WAVE'    |
----------------------------------
</code></pre>

<!--more-->


<p>以<code>FIFF</code>作为标示，然后紧跟着为size字段，该size是整个wav文件大小减去ID和Size所占用的字节数，即FileLen &ndash; 8 = Size。然后是Type字段，为<code>WAVE</code>，表示是wav文件。结构定义如下：
```
struct RIFF_HEADER
{</p>

<pre><code>char szRiffID[4];  // 'R','I','F','F'
DWORD dwRiffSize;
char szRiffFormat[4]; // 'W','A','V','E'
</code></pre>

<p>};
```</p>

<p>Format Chunk</p>

<pre><code>--------------------------------------------------------------------
|               |   字节数   |              具体内容                 |
--------------------------------------------------------------------
| ID            |  4 Bytes  |   'fmt '                             |
--------------------------------------------------------------------
| Size          |  4 Bytes  | 数值为16或18，18则最后有附加信息         |
--------------------------------------------------------------------
| FormatTag     |  2 Bytes  | 编码方式，一般为0x0001                  |
--------------------------------------------------------------------
| Channels      |  2 Bytes  | 声道数目，1--单声道；2--双声道           |
--------------------------------------------------------------------
| SamplesPerSec |  4 Bytes  | 采样频率                               |
--------------------------------------------------------------------
| AvgBytesPerSec|  4 Bytes  | 每秒所需字节数                          |
-------------------------------------------------------------------- 
| BlockAlign    |  2 Bytes  | 数据块对齐单位(每个采样需要的字节数)       |
--------------------------------------------------------------------  
| BitsPerSample |  2 Bytes  | 每个采样需要的bit数                     |
--------------------------------------------------------------------
|               |  2 Bytes  | 附加信息（可选，通过Size来判断有无）       |
-------------------------------------------------------------------- 
</code></pre>

<p>以<code>fmt</code>作为标示。一般情况下Size为16，此时最后附加信息没有；如果为18，则最后多了2个字节的附加信息。主要由一些软件制成的wav格式中含有该2个字节的附加信息。结构定义如下：
```
struct WAVE_FORMAT
{</p>

<pre><code>WORD wFormatTag;
WORD wChannels;
DWORD dwSamplesPerSec;
DWORD dwAvgBytesPerSec;
WORD wBlockAlign;
WORD wBitsPerSample;
</code></pre>

<p>};
<code>
</code>
struct FMT_BLOCK
{</p>

<pre><code>char  szFmtID[4]; // 'f','m','t',' '
DWORD  dwFmtSize;
WAVE_FORMAT wavFormat;
</code></pre>

<p>};
```</p>

<p>Fact Chunk</p>

<pre><code>----------------------------------
|       | 所占字节数 |  具体内容    |
----------------------------------
| ID    |  4 Bytes |   'fact'    |
----------------------------------
| Size  |  4 Bytes |   数值为4    |
----------------------------------
| data  |  4 Bytes |             |
----------------------------------
</code></pre>

<p>Fact Chunk是可选字段，一般当wav文件由某些软件转化而成，则包含该Chunk。结构定义如下：
```
struct FACT_BLOCK
{</p>

<pre><code>char  szFactID[4]; // 'f','a','c','t'
DWORD  dwFactSize;
</code></pre>

<p>};
```</p>

<p>Data Chunk</p>

<pre><code>----------------------------------
|       | 所占字节数 |   具体内容   |
----------------------------------
| ID    |  4 Bytes |   'data'    |
----------------------------------
| Size  |  4 Bytes |             |
----------------------------------
| data  |          |             |
----------------------------------
</code></pre>

<p>Data Chunk是真正保存wav数据的地方，以<code>data</code>作为该Chunk的标示。然后是数据的大小。紧接着就是wav数据。根据Format Chunk中的声道数以及采样bit数，wav数据的bit位置可以分成以下几种形式：</p>

<pre><code>---------------------------------------------------------------------
|   单声道   |    取样1    |    取样2    |    取样3    |    取样4       |
|           |--------------------------------------------------------
|  8bit量化 |    声道0    |    声道0    |    声道0    |    声道0        |
---------------------------------------------------------------------
|   双声道  |          取样1            |           取样2              |
|           |--------------------------------------------------------
|  8bit量化 |  声道0(左)  |  声道1(右)  |  声道0(左)  |  声道1(右)       |
---------------------------------------------------------------------
|           |          取样1            |           取样2             |
|   单声道  |---------------------------------------------------------
| 16bit量化 |    声道0    |  声道0      |    声道0    |  声道0          |
|           | (低位字节)  | (高位字节)  | (低位字节)   |  (高位字节)      |
---------------------------------------------------------------------
|           |                         取样1                          |
|   双声道  |---------------------------------------------------------
| 16bit量化 |  声道0(左)  |  声道0(左)  |  声道1(右)  |  声道1(右)       |
|           | (低位字节)  | (高位字节)  | (低位字节)  | (高位字节)        |
---------------------------------------------------------------------
</code></pre>

<p>Data Chunk头结构定义如下：
```
struct DATA_BLOCK
{</p>

<pre><code>char szDataID[4]; // 'd','a','t','a'
DWORD dwDataSize;
</code></pre>

<p>};
```
wave文件解析及头部格式添加的参考代码请查阅<a href="https://github.com/txgcwm/Linux-C-Examples/tree/master/audio-video/wave">这里</a> 。</p>

<p><big>参考文章</big></p>

<p><a href="http://blog.csdn.net/bluesoal/article/details/932395">wav文件格式分析详解</a><br/>
<a href="http://ikinglai.blog.51cto.com/6220785/1224616">PCM录音数据转Wav格式（c语言版）</a><br/>
<a href="http://blog.sina.com.cn/s/blog_717f471b0100uw98.html">wav文件格式分析详解和解析代码</a><br/>
<a href="http://www.cnblogs.com/cheney23reg/archive/2010/08/08/1795067.html">wave文件(*.wav)格式、PCM数据格式</a><br/>
<a href="http://blog.csdn.net/xiahouzuoxin/article/details/7875406">读取*.wav音频文件</a><br/>
<a href="http://hmilyyang.bokee.com/3757847.html">使用Wav文件来封装G.726格式的原始音频数据</a></p>
]]></content>
  </entry>
  
</feed>

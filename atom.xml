<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[残剑]]></title>
  <link href="http://txgcwm.github.io/atom.xml" rel="self"/>
  <link href="http://txgcwm.github.io/"/>
  <updated>2013-07-14T11:33:01+08:00</updated>
  <id>http://txgcwm.github.io/</id>
  <author>
    <name><![CDATA[残剑]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[pkg-config的使用]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/14/pkg-configde-shi-yong/"/>
    <updated>2013-07-14T11:22:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/14/pkg-configde-shi-yong</id>
    <content type="html"><![CDATA[<p>pkg-config是向用户和应用程序提供相应库的路径、版本号等信息的程序。比如使用pkg-config查看gcc的CFLAGS参数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pkg-config --libs --cflags opencv
</span><span class='line'>-I/usr/include/opencv  -lopencv_core -lopencv_imgproc -lopencv_highgui -lopencv_ml -lopencv_video -lopencv_features2d -lopencv_calib3d -lopencv_objdetect -lopencv_contrib -lopencv_legacy -lopencv_flann</span></code></pre></td></tr></table></div></figure>


<p>以上就是我们用gcc编译连接时CFLAGS的参数。因此当我们需要编译连接某个库时，只需要把上面那行加入gcc的参数里面即可。这也是configure的作用，它会检查你需要的包，产生相应的信息。</p>

<p>那pkg-config从哪儿知道这些信息的呢？它是从包名为xxx.pc这个文件中查找到的。缺省情况下，pkg-config首先在prefix/lib/pkgconfig/中查找相关包（譬如opencv）对应的相应的文件（opencv.pc）。在linux上上述路径名为/usr/lib/pkconfig/。若是没有找到，它也会到PKG_CONFIG_PATH这个环境变量所指定的路径下去找。若是还没有找到，它就会报错，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Package opencv was not found in the pkg-config search path.
</span><span class='line'>Perhaps you should add the directory containing `opencv.pc'
</span><span class='line'>to the PKG_CONFIG_PATH environment variable
</span><span class='line'>No package 'opencv' found</span></code></pre></td></tr></table></div></figure>


<p>设置环境变量PKG_CONFIG_PATH方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export PKG_CONFIG_PATH=/cv/lib:$PKG_CONFIG_PATH</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下删除文本文件中的所有空行]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/13/linuxxia-shan-chu-wen-ben-wen-jian-zhong-de-suo-you-kong-xing/"/>
    <updated>2013-07-13T22:20:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/13/linuxxia-shan-chu-wen-ben-wen-jian-zhong-de-suo-you-kong-xing</id>
    <content type="html"><![CDATA[<p>很多情况下文本文件中会出现许多空行，这些都是我们不想要的。大多时候我们会选择手工删除，这样显然太麻烦，况且当文件行数很多的时候，其麻烦程度是不能忍受的。所以需要一个工具，可以达到删除所有空行的目的，并且最好还能一次处理多个文件。以下是Linux下的一个脚本文件，支持一次处理多个文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>TEMP_F="del.lines.$$"
</span><span class='line'>
</span><span class='line'>usage()
</span><span class='line'>{
</span><span class='line'>  echo "Usage: $0 filename [filename...]"
</span><span class='line'>  exit -1
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>if [ $# -eq 0 ] ; then
</span><span class='line'>  usage
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>while [ $# -gt 0 ]
</span><span class='line'>do
</span><span class='line'>  FILE_NAME=$1
</span><span class='line'>
</span><span class='line'>  case $1 in 
</span><span class='line'>      --help)
</span><span class='line'>          usage
</span><span class='line'>      ;;
</span><span class='line'>
</span><span class='line'>      *)
</span><span class='line'>          if [ -f $1 ] ; then
</span><span class='line'>              sed '/^$/d' $FILE_NAME &gt; $TEMP_F
</span><span class='line'>              mv $TEMP_F $FILE_NAME
</span><span class='line'>          else
</span><span class='line'>              echo "$0 can not find this file: $1"
</span><span class='line'>          fi      
</span><span class='line'>      ;;
</span><span class='line'>  esac
</span><span class='line'>
</span><span class='line'>  shift
</span><span class='line'>done</span></code></pre></td></tr></table></div></figure>


<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Base64编码解码算法]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/11/base64bian-ma-jie-ma-suan-fa/"/>
    <updated>2013-07-11T23:09:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/11/base64bian-ma-jie-ma-suan-fa</id>
    <content type="html"><![CDATA[<p>Base64使用ascii码子集的64个字符，即大小写的26个英文字母，0～9，＋，/。编码基于3个字符，每个字符用8位二进制表示，一共24位，再分为4四组，每组6位表示一个Base64值（例如0就是A，27就是b）。Base64值如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
</span><span class='line'>'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
</span><span class='line'>'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
</span><span class='line'>'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
</span><span class='line'>'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
</span><span class='line'>'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
</span><span class='line'>'w', 'x', 'y', 'z', '0', '1', '2', '3',
</span><span class='line'>'4', '5', '6', '7', '8', '9', '+', '/',</span></code></pre></td></tr></table></div></figure>


<p>如果被加密的字符串每3个一组，还剩1或2个字符，使用特殊字符&#8221;=&ldquo;补齐。例如编码只有2个字符“me”，m的ascii是109，e的是101，用二进制表示分别是01101101、01100101，连接起来就是0110110101100101，再按6位分为一组：011011、010110、010100（不足6位补0），ascii分别是27、22、 20，即Base64值为bWU，不足4字用＝补齐，因此bWU＝就me的Base64值。</p>

<!--more-->


<p>在<a href="https://github.com/dwjackson/basenc">这里</a>可以找到一个c语言的base32/base64开源库。以下是goahead中base64编码解码的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static char_t    map64[] = {
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
</span><span class='line'>    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
</span><span class='line'>    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
</span><span class='line'>    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static char_t    alphabet64[] = {
</span><span class='line'>    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
</span><span class='line'>    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
</span><span class='line'>    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
</span><span class='line'>    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
</span><span class='line'>    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
</span><span class='line'>    'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
</span><span class='line'>    'w', 'x', 'y', 'z', '0', '1', '2', '3',
</span><span class='line'>    '4', '5', '6', '7', '8', '9', '+', '/',
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>/*********************************** Code *************************************/
</span><span class='line'>/*
</span><span class='line'> *    Decode a buffer from "string" and into "outbuf"
</span><span class='line'> */
</span><span class='line'>int websDecode64(char_t *outbuf, char_t *string, int outlen)
</span><span class='line'>{
</span><span class='line'>    unsigned long    shiftbuf;
</span><span class='line'>    char_t            *cp, *op;
</span><span class='line'>    int                c, i, j, shift;
</span><span class='line'>
</span><span class='line'>    op = outbuf;
</span><span class='line'>    *op = '\0';
</span><span class='line'>    cp = string;
</span><span class='line'>    while (*cp && *cp != '=') {
</span><span class='line'>        /*
</span><span class='line'>         *        Map 4 (6bit) input bytes and store in a single long (shiftbuf)
</span><span class='line'>         */
</span><span class='line'>        shiftbuf = 0;
</span><span class='line'>        shift = 18;
</span><span class='line'>        for (i = 0; i &lt; 4 && *cp && *cp != '='; i++, cp++) {
</span><span class='line'>            c = map64[*cp & 0xff];
</span><span class='line'>            if (c == -1) {
</span><span class='line'>                error(E_L, E_LOG, T("Bad string: %s at %c index %d"), string,
</span><span class='line'>                      c, i);
</span><span class='line'>                return -1;
</span><span class='line'>            }
</span><span class='line'>            shiftbuf = shiftbuf | (c &lt;&lt; shift);
</span><span class='line'>            shift -= 6;
</span><span class='line'>        }
</span><span class='line'>        /*
</span><span class='line'>         *        Interpret as 3 normal 8 bit bytes (fill in reverse order).
</span><span class='line'>         *        Check for potential buffer overflow before filling.
</span><span class='line'>         */
</span><span class='line'>        --i;
</span><span class='line'>        if ((op + i) &gt;= &outbuf[outlen]) {
</span><span class='line'>            gstrcpy(outbuf, T("String too big"));
</span><span class='line'>            return -1;
</span><span class='line'>        }
</span><span class='line'>        for (j = 0; j &lt; i; j++) {
</span><span class='line'>            *op++ = (char_t) ((shiftbuf &gt;&gt; (8 * (2 - j))) & 0xff);
</span><span class='line'>        }
</span><span class='line'>        *op = '\0';
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/******************************************************************************/
</span><span class='line'>/*
</span><span class='line'> *    Encode a buffer from "string" into "outbuf"
</span><span class='line'> */
</span><span class='line'>void websEncode64(char_t *outbuf, char_t *string, int outlen)
</span><span class='line'>{
</span><span class='line'>    unsigned long    shiftbuf;
</span><span class='line'>    char_t            *cp, *op;
</span><span class='line'>    int                x, i, j, shift;
</span><span class='line'>
</span><span class='line'>    op = outbuf;
</span><span class='line'>    *op = '\0';
</span><span class='line'>    cp = string;
</span><span class='line'>    while (*cp) {
</span><span class='line'>        /*
</span><span class='line'>         *        Take three characters and create a 24 bit number in shiftbuf
</span><span class='line'>         */
</span><span class='line'>        shiftbuf = 0;
</span><span class='line'>        for (j = 2; j &gt;= 0 && *cp; j--, cp++) {
</span><span class='line'>            shiftbuf |= ((*cp & 0xff) &lt;&lt; (j * 8));
</span><span class='line'>        }
</span><span class='line'>        /*
</span><span class='line'>         *        Now convert shiftbuf to 4 base64 letters. The i,j magic calculates
</span><span class='line'>         *        how many letters need to be output.
</span><span class='line'>         */
</span><span class='line'>        shift = 18;
</span><span class='line'>        for (i = ++j; i &lt; 4 && op &lt; &outbuf[outlen] ; i++) {
</span><span class='line'>            x = (shiftbuf &gt;&gt; shift) & 0x3f;
</span><span class='line'>            *op++ = alphabet64[(shiftbuf &gt;&gt; shift) & 0x3f];
</span><span class='line'>            shift -= 6;
</span><span class='line'>        }
</span><span class='line'>        /*
</span><span class='line'>         *        Pad at the end with '='
</span><span class='line'>         */
</span><span class='line'>        while (j-- &gt; 0) {
</span><span class='line'>            *op++ = '=';
</span><span class='line'>        }
</span><span class='line'>        *op = '\0';
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Linux提供了命令行方式的base64编码和解码。</p>

<ul>
<li>将字符串str+换行 编码为base64字符串输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo "str" | base64</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将字符串str编码为base64字符串输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo -n "str" | base64</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从指定的文件file中读取数据，编码为base64字符串输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ base64 file</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从标准输入中读取已经进行base64编码的内容，解码输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ base64 -d </span></code></pre></td></tr></table></div></figure>


<ul>
<li>从标准输入中读取已经进行base64编码的内容，解码输出。加上-i参数，忽略非字母表字符，比如换行符。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ base64 -d -i</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将base64编码的字符串str+换行 解码输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo "str" | base64 -d</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将base64编码的字符串str解码输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo -n "str" | base64 -d</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从指定的文件file中读取base64编码的内容，解码输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ base64 -d file </span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[minilzo无损压缩库测试例子（二）]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/10/minilzowu-sun-ya-suo-ku-ce-shi-li-zi-%28er-%29/"/>
    <updated>2013-07-10T23:01:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/10/minilzowu-sun-ya-suo-ku-ce-shi-li-zi-(er-)</id>
    <content type="html"><![CDATA[<p>在minilzo无损压缩库中提供了一个测试例子（文件名为testmini.c），对该示例作一个分析。如果我们要使用该库中的四个基本函数，首先必须包含以下的头文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "minilzo.h"</span></code></pre></td></tr></table></div></figure>


<p>其中，lzo_init()函数包含在以下的头文件中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "lzoconf.h"</span></code></pre></td></tr></table></div></figure>


<p>lzoconf.h已包含在minilzo.h中，所以在写测试例子时只需包含minilzo.h头文件即可。</p>

<p>将原始数据存放在in中且定义其长度为IN_LEN，压缩后的数据存放在out中且定义其长度为OUT_LEN。因为输入块可能是不可压缩的，所以我们必须提供多一点的输出空间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if defined(__LZO_STRICT_16BIT)
</span><span class='line'>#define IN_LEN      (8*1024u)
</span><span class='line'>#elif defined(LZO_ARCH_I086) && !defined(LZO_HAVE_MM_HUGE_ARRAY)
</span><span class='line'>#define IN_LEN      (60*1024u)
</span><span class='line'>#else
</span><span class='line'>#define IN_LEN      (128*1024ul)
</span><span class='line'>#endif
</span><span class='line'>#define OUT_LEN     (IN_LEN + IN_LEN / 16 + 64 + 3)
</span><span class='line'>
</span><span class='line'>static unsigned char __LZO_MMODEL in  [ IN_LEN ];
</span><span class='line'>static unsigned char __LZO_MMODEL out [ OUT_LEN ];</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>压缩需要工作缓冲区，内存分配以‘lzo_align_t’（而不是‘char’）为单元，以确保它对齐。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define HEAP_ALLOC(var,size) \
</span><span class='line'>    lzo_align_t __LZO_MMODEL var [ ((size) + (sizeof(lzo_align_t) - 1)) / \
</span><span class='line'>                                    sizeof(lzo_align_t) ]
</span><span class='line'>
</span><span class='line'>static HEAP_ALLOC(wrkmem, LZO1X_1_MEM_COMPRESS);</span></code></pre></td></tr></table></div></figure>


<p>Step 1: 初始化lzo库。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (lzo_init() != LZO_E_OK)
</span><span class='line'>{
</span><span class='line'>    printf("internal error - lzo_init() failed !!!\n");
</span><span class='line'>    printf("(this usually indicates a compiler bug - try recompiling\n
</span><span class='line'>                without optimizations, and enable '-DLZO_DEBUG' for diagnostics)\n");
</span><span class='line'>    return 3;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Step 2: 准备将要被压缩的输入块，在这个例子程序中我们只是简单的写入“0”。在实际的应用中，应该写入真正需要压缩的数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>in_len = IN_LEN;
</span><span class='line'>lzo_memset(in,0,in_len);</span></code></pre></td></tr></table></div></figure>


<p>Step 3: 使用LZO1X-1将in中的数据压缩到out中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>r = lzo1x_1_compress(in,in_len,out,&out_len,wrkmem);
</span><span class='line'>if (r == LZO_E_OK)
</span><span class='line'>    printf("compressed %lu bytes into %lu bytes\n",
</span><span class='line'>        (unsigned long) in_len, (unsigned long) out_len);
</span><span class='line'>else
</span><span class='line'>{
</span><span class='line'>    /* this should NEVER happen */
</span><span class='line'>    printf("internal error - compression failed: %d\n", r);
</span><span class='line'>    return 2;
</span><span class='line'>}
</span><span class='line'>/* check for an incompressible block */
</span><span class='line'>if (out_len &gt;= in_len)
</span><span class='line'>{
</span><span class='line'>    printf("This block contains incompressible data.\n");
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Step 4: 将out中的数据解压缩到in中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new_len = in_len;
</span><span class='line'>r = lzo1x_decompress(out,out_len,in,&new_len,NULL);
</span><span class='line'>if (r == LZO_E_OK && new_len == in_len)
</span><span class='line'>    printf("decompressed %lu bytes back into %lu bytes\n",
</span><span class='line'>        (unsigned long) out_len, (unsigned long) in_len);
</span><span class='line'>else
</span><span class='line'>{
</span><span class='line'>    /* this should NEVER happen */
</span><span class='line'>    printf("internal error - decompression failed: %d\n", r);
</span><span class='line'>    return 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>minilzo支持多个平台，在编译的时候应该设置编译选项。在Linux系统中，编译该测试例程使用以下指令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ make gcc
</span><span class='line'>gcc  -s -Wall -O2 -fomit-frame-pointer -o testmini testmini.c minilzo.c</span></code></pre></td></tr></table></div></figure>


<p>以下为运行结果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./testmini 
</span><span class='line'>
</span><span class='line'>LZO real-time data compression library (v2.06, Aug 12 2011).
</span><span class='line'>Copyright (C) 1996-2011 Markus Franz Xaver Johannes Oberhumer
</span><span class='line'>All Rights Reserved.
</span><span class='line'>
</span><span class='line'>compressed 131072 bytes into 598 bytes
</span><span class='line'>decompressed 598 bytes back into 131072 bytes
</span><span class='line'>
</span><span class='line'>miniLZO simple compression test passed.</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[minilzo无损压缩库介绍（一）]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/minilzowu-sun-ya-suo-ku-jie-shao-%28%5B%3F%5D-%29/"/>
    <updated>2013-07-07T23:32:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/minilzowu-sun-ya-suo-ku-jie-shao-([?]-)</id>
    <content type="html"><![CDATA[<p>在网络上传输大批量数据的时候，网络的传输速度是固定的（比如100 Mb的以太网实际测量的传输速度大概在10 MB/s左右），而想要在固定时间内传输更多容量的数据，最常见的解决方案是——在传输之前通过一定的算法把数据的容量压缩，然后通过网络传输，对端接收到数据之后再通过相应的算法进行解压还原。如果“压缩的时间 + 压缩后数据的传输时间 + 解压缩的时间 &lt; 未压缩数据的传输时间”，就相当于提高了单位时间内的传输能力，拓宽了网络传输的带宽。</p>

<h1>minilzo库使用介绍</h1>

<p>lzo是一个开源的无损压缩c语言库，其优点是压缩/解压缩比较迅速且占用内存小等特点。具体可查看 <a href="http://www.oberhumer.com/opensource/lzo/">这里</a>，提供了比较全的lzo库和一个minilzo库。minilzo库提供了1个c文件和3个头文件，解压后的目录树如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>minilzo-2.06$ tree
</span><span class='line'>.
</span><span class='line'>├── COPYING
</span><span class='line'>├── lzoconf.h
</span><span class='line'>├── lzodefs.h
</span><span class='line'>├── Makefile
</span><span class='line'>├── minilzo.c
</span><span class='line'>├── minilzo.h
</span><span class='line'>├── README.LZO
</span><span class='line'>└── testmini.c</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>常用的有4个API（在使用的时候包含minilzo.h即可）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* lzo_init() should be the first function you call.
</span><span class='line'> * Check the return code !
</span><span class='line'> *
</span><span class='line'> * lzo_init() is a macro to allow checking that the library and the
</span><span class='line'> * compiler's view of various types are consistent.
</span><span class='line'> */
</span><span class='line'>#define lzo_init() __lzo_init_v2(LZO_VERSION,(int)sizeof(short),(int)sizeof(int),\
</span><span class='line'>    (int)sizeof(long),(int)sizeof(lzo_uint32),(int)sizeof(lzo_uint),\
</span><span class='line'>    (int)lzo_sizeof_dict_t,(int)sizeof(char *),(int)sizeof(lzo_voidp),\
</span><span class='line'>    (int)sizeof(lzo_callback_t))
</span><span class='line'>
</span><span class='line'>/* compression */
</span><span class='line'>LZO_EXTERN(int)
</span><span class='line'>lzo1x_1_compress        ( const lzo_bytep src, lzo_uint  src_len,
</span><span class='line'>                                lzo_bytep dst, lzo_uintp dst_len,
</span><span class='line'>                                lzo_voidp wrkmem );
</span><span class='line'>
</span><span class='line'>/* decompression */
</span><span class='line'>LZO_EXTERN(int)
</span><span class='line'>lzo1x_decompress        ( const lzo_bytep src, lzo_uint  src_len,
</span><span class='line'>                                lzo_bytep dst, lzo_uintp dst_len,
</span><span class='line'>                                lzo_voidp wrkmem /* NOT USED */ );
</span><span class='line'>
</span><span class='line'>/* safe decompression with overrun testing */
</span><span class='line'>LZO_EXTERN(int)
</span><span class='line'>lzo1x_decompress_safe   ( const lzo_bytep src, lzo_uint  src_len,
</span><span class='line'>                                lzo_bytep dst, lzo_uintp dst_len,
</span><span class='line'>                                lzo_voidp wrkmem /* NOT USED */ );</span></code></pre></td></tr></table></div></figure>


<p>minilzo库使用十分简单，在压缩和解压缩之前先调用lzo_init函数进行初始化，返回LZO_E_OK表示初始化成功。压缩数据时调用lzo1x_1_compress函数；解压数据时调用lzo1x_decompress函数或lzo1x_decompress_safe函数，这两个函数的区别是——lzo1x_decompress_safe函数会对解压缩数据的有效性进行验证，验证通过才会进行解压缩操作，而lzo1x_decompress函数则不会这么做，数据不是有效时就会产生“段错误”，建议使用lzo1x_decompress_safe函数。以下是这些函数的详细操作说明：</p>

<ul>
<li>lzo1x_1_compress函数进行压缩数据操作，需要5个参数：压缩的数据、压缩数据的大小、压缩后数据的缓冲区、压缩缓冲区的大小、压缩工作缓冲区。压缩数据成功之后会返回LZO_E_OK。第4个参数传进去的是用来指示存放压缩后数据缓冲区的大小，执行成功之后通过指针返回的结果是压缩后的数据实际使用的缓冲区大小（即压缩后的数据大小）。压缩后需要的数据缓冲区大小的上限是可以根据未压缩数据大小进行计算的，其公式为：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>output_size = input_size + (input_size / 16) + 64 + 3；</span></code></pre></td></tr></table></div></figure>


<p>第5个参数是压缩的时候需要使用的工作缓冲区，缓冲的生成在minilzo库提供的测试例程中有相关的宏定义。</p>

<ul>
<li>lzo1x_decompress和lzo1x_decompress_safe函数进行数据的解压缩操作，需要5个参数：解压缩的数据、解压缩数据的大小、解压缩后数据的存放缓冲区、原始数据（未压缩数据）大小、解压缩工作缓冲区（不需要，可以置为NULL）。执行成功之后返回LZO_E_OK。第4个参数传进去的值是原始的未压缩数据的大小，执行成功之后通过指针返回的是实际解压缩后数据的大小。所以压缩之后的数据在传输的时候需要将原始数据的大小和压缩后数据一起传输，否则对方在解压缩的时候将无法解压。可以定义一个数据结构专门用来传输，这些数据在传输的时候相当于有效载荷：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct{
</span><span class='line'>    unsigned long org_data_size;    /* 原始的未压缩数据大小 */
</span><span class='line'>    unsigned char data[MAX_DATA_SIZE];  /* 压缩之后的数据 */
</span><span class='line'>}COMP_DATA, *P_COMP_DATA;</span></code></pre></td></tr></table></div></figure>


<p></p>

<h1>压缩/解压缩时间的计算</h1>

<p>在压缩/解压缩数据之前，可以通过gettimeofday函数获取当前的系统时间，接着进行相关操作，完成之后再次获取系统时间，对2次获取的时间进行减操作即可得到实际操作所花费的时间。以下是计算操作所需花费时间的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned long interval_ms = 0;       /* 间隔的毫秒数 */
</span><span class='line'>struct timeval stime, etime;
</span><span class='line'>
</span><span class='line'>gettimeofday(&stime, NULL);
</span><span class='line'>
</span><span class='line'>/* TODO:Do compression or decompression */
</span><span class='line'>
</span><span class='line'>gettimeofday(&etime, NULL);
</span><span class='line'>
</span><span class='line'>interval_ms = (etime.tv_sec - stime.tv_sec) * 1000.0 + \
</span><span class='line'>                    （etime.tv_usec - stime.tv_usec）/ 1000.0;</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PF_NETLINK应用实例:NETLINK_KOBJECT_UEVENT的实现]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/pf-netlinkying-yong-shi-li-netlink-kobject-ueventde-shi-xian/"/>
    <updated>2013-07-07T17:43:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/pf-netlinkying-yong-shi-li-netlink-kobject-ueventde-shi-xian</id>
    <content type="html"><![CDATA[<p>udev的文档介绍：</p>

<ol>
<li><p>dynamic replacement for /dev。作为devfs的替代者，传统的devfs不能动态分配major和minor的值，而major和minor非常有限，很快就会用完了。udev能够像DHCP动态分配IP地址一样去动态分配major和minor。</p></li>
<li><p>device naming。提供设备命名持久化的机制。传统设备命名方式不具直观性，像/dev/hda1这样的名字肯定没有boot_disk这样的名字直观。udev能够像DNS解析域名一样去给设备指定一个有意义的名称。</p></li>
<li><p>API to access info about current system devices 。提供了一组易用的API去操作sysfs，避免重复实现同样的代码。</p></li>
</ol>


<!--more-->


<p>用户空间的程序与设备通信的方法，主要有以下几种方式：</p>

<ol>
<li><p>通过ioperm获取操作IO端口的权限，然后用inb/inw/ inl/ outb/outw/outl等函数，避开设备驱动程序，直接去操作IO端口。</p></li>
<li><p>用ioctl函数去操作/dev目录下对应的设备，这是设备驱动程序提供的接口。像键盘、鼠标和触摸屏等输入设备一般都是这样做的。</p></li>
<li><p>用write/read/mmap去操作/dev目录下对应的设备，这也是设备驱动程序提供的接口。像framebuffer等都是这样做的。</p></li>
</ol>


<p>上面的方法在大多数情况下都可以正常工作，但是对于热插拨(hotplug)的设备，比如像U盘就有点困难了，因为你不知道“什么时候设备插上了，什么时候设备拔掉了”。这就是所谓的hotplug问题了。</p>

<p>处理hotplug传统的方法是在内核中执行一个称为hotplug的程序，相关参数通过环境变量传递，再由hotplug通知其它关注hotplug事件的应用程序。这样做不但效率低下，而且也不那么优雅。新的方法是采用NETLINK实现，这是一种特殊类型的socket，专门用于内核空间与用户空间的异步通信。下面的这个例子可以监听来自内核hotplug事件。</p>

<pre><code>#include &lt;linux/netlink.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;


#define UEVENT_BUFFER_SIZE 2048

static int init_hotplug_sock(void)
{
    int ret;
    int s = -1;
    const int buffersize = 1024;
    struct sockaddr_nl snl;

    bzero(&amp;snl, sizeof(struct sockaddr_nl));
    snl.nl_family = AF_NETLINK;
    snl.nl_pid = getpid();
    snl.nl_groups = 1;

    s = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
    if (s == -1) {
        perror("socket");
        return -1;
    }
    setsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;buffersize, sizeof(buffersize));

    ret = bind(s, (struct sockaddr *)&amp;snl, sizeof(struct sockaddr_nl));
    if (ret &lt; 0) {
        perror("bind");
        close(s);
        return -1;
    }

    return s;
}

int main(int argc, char *argv[])
{
    int hotplug_sock = init_hotplug_sock();

    while (1) {    
        char buf[UEVENT_BUFFER_SIZE * 2] = { 0 };

        recv(hotplug_sock, &amp;buf, sizeof(buf), 0);
        printf("%s\n", buf);

        /* USB 设备的插拔会出现字符信息，通过比较不同的信息确定特定设备的插拔，在这添加比较代码 */
    }

    return 0;
}
</code></pre>

<p>编译：</p>

<pre><code>$ gcc -g hotplug.c -o hotplug
</code></pre>

<p>执行：</p>

<pre><code>$ ./hotplug
remove@/devices/pci0000:00/0000:00:1d.7/usb2/2-1/2-1:1.0
remove@/devices/pci0000:00/0000:00:1d.7/usb2/2-1
add@/devices/pci0000:00/0000:00:1d.7/usb2/2-1
add@/devices/pci0000:00/0000:00:1d.7/usb2/2-1/2-1:1.0
</code></pre>

<p>udev的主体部分在udevd.c文件中，它主要监控来自4个文件描述符的事件/消息，并做出处理：</p>

<ol>
<li>来自客户端的控制消息。这通常由udevcontrol命令通过地址为/org/kernel/udev/udevd的本地socket，向udevd发送控制消息。其中消息类型有：</li>
</ol>


<pre><code>UDEVD_CTRL_STOP_EXEC_QUEUE  //停止处理消息队列
UDEVD_CTRL_START_EXEC_QUEUE //开始处理消息队列
UDEVD_CTRL_SET_LOG_LEVEL //设置LOG的级别
UDEVD_CTRL_SET_MAX_CHILDS //设置最大子进程数限制
UDEVD_CTRL_SET_MAX_CHILDS_RUNNING //设置最大运行子进程数限制(遍历proc目录下所有进程，根据session的值判断) 
UDEVD_CTRL_RELOAD_RULES //重新加载配置文件
</code></pre>


<ol>
<li><p>来自内核的hotplug事件。如果有事件来源于hotplug，它读取该事件，创建一个udevd_uevent_msg对象，记录当前的消息序列号，设置消息的状态为EVENT_QUEUED，然后放入running_list和exec_list两个队列中，稍后再进行处理。</p></li>
<li><p>来自signal handler中的事件。signal handler是异步执行的，即使有signal产生，主进程的select并不会唤醒，为了唤醒主进程的select，它建立了一个管道，在signal handler中，向该管道写入长度为1个子节的数据，这样就可以唤醒主进程的select了。</p></li>
<li><p>来自配置文件变化的事件。udev通过文件系统inotify功能，监控其配置文件目录/etc/udev/rules.d，一旦该目录中文件有变化，它就重新加载配置文件。</p></li>
</ol>


<p>其中最主要的事件当然是来自内核的hotplug事件，如何处理这些事件是udev的关键。udev本身并不知道如何处理这些事件，也没有必要知道，因为它只实现机制，而不实现策略。事件的处理是由配置文件决定的，这些配置文件即所谓的rule。</p>

<p>关于rule的编写方法可以参考《writing_udev_rules》，udev_rules.c实现了对规则的解析。在规则中，可以让外部应用程序处理某个事件，这有两种方式：一种是直接执行命令，通常是让modprobe去加载驱动程序，或者让mount去加载分区；另外一种是通过本地socket发送消息给某个应用程序。</p>

<p>在udevd.c的udev_event_process函数中，我们可以看到：如果RUN参数以”socket:”开头则认为是发到socket，否则认为是执行指定的程序。</p>

<p>下面的规则是执行指定程序：</p>

<pre><code>60-pcmcia.rules: RUN+="/sbin/modprobe pcmcia"
</code></pre>

<p>下面的规则是通过socket发送消息：</p>

<pre><code>90-hal.rules:RUN+="socket:/org/freedesktop/hal/udev_event"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[求两个整数的最大公约数]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/qiu-liang-ge-zheng-shu-de-zui-da-gong-yue-shu/"/>
    <updated>2013-07-07T17:10:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/qiu-liang-ge-zheng-shu-de-zui-da-gong-yue-shu</id>
    <content type="html"><![CDATA[<p>辗转相除法又名欧几里德算法（Euclidean algorithm），用于求两个正整数的最大公因子的算法。它是已知最古老的算法，可追溯至公元前300年。它首次出现于欧几里德的《几何原本》中，而在中国则可以追溯至东汉出现的《九章算术》。</p>

<p>设两数为a、b(b&lt;a)，求它们的最大公约数的步骤如下：用b除a，得a＝bq&hellip;r1(0≤r1)。若r1=0，则(a，b)＝b；若r1≠0，则再用r1除b，得b＝r1q&hellip;r2(0≤r2)。若r2＝0，则(a，b)＝r1，若r2≠0，则继续用r2除r1,&hellip;如此下去，直到能整除为止。其最后一个非零余数即为(a，b)。</p>

<!--more-->


<p>辗转相除法是利用以下性质来确定两个正整数a和b的最大公因子的：</p>

<p>1、若r是a÷b的余数,则gcd(a,b) = gcd(b,r)；</p>

<p>2、若b为0，则其最大公因子为a。</p>

<p>另一种置换实现方式：</p>

<p>1、r为a÷b所得余数（0≤r＜b）。若r=0，算法结束，b即为答案；</p>

<p>2、若r不为0，则互换：置a←b，b←r，并返回第一步。</p>

<p>递归实现：</p>

<pre><code>int gcd(int a,int b)
{
    if(b == 0)
        return a;
    else
        return gcd(b, a%b);
}
</code></pre>

<p>对递归实现的改进：</p>

<pre><code>int gcd(int a,int b)
{
    return b ? gcd(b, a%b) : a;
}
</code></pre>

<p>置换实现：</p>

<pre><code>int gcd( int a, int b)
{
    int temp;

     while(b) {
        temp = b;
        b = a%b;
        a = temp;      
     }

     return a;
}
</code></pre>

<p>对置换实现的改进：</p>

<pre><code>int gcd(int a, int b)
{
    while(b)
        b = a%b + 0/(a=b);

    return a;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下C语言伪随机数编程]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/linuxxia-cyu-yan-wei-sui-ji-shu-bian-cheng/"/>
    <updated>2013-07-07T12:50:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/linuxxia-cyu-yan-wei-sui-ji-shu-bian-cheng</id>
    <content type="html"><![CDATA[<p>在日常生活中，我们经常会遇到随机数（比如丢骰子，抓阄，抽签等等），那么在程序中如何实现随机数呢？现在很多操作系统内核都会提供相应的api，通过获取一些计算机运行时的原始信息（如内存，电压，物理信号等等，它们的值在一个时间段可以保证是唯一的）来生成随机数。下文介绍如何使用rand、srand来生成伪随机数。</p>

<h1>rand产生伪随机数</h1>

<p>Linux中rand()会返回一随机数值，范围在0至RAND_MAX 间，其中RAND_MAX定义在stdlib.h，其值为2147483647。</p>

<p>以下例子利用rand函数生成随机数。</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define LOOP_TIMES    5

int main(int argc, char *argv[])
{
    int i;

    for(i=0; i&lt; LOOP_TIMES; i++)
        printf("%d ", rand());

    printf("\n");

    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>$ ./rand
1804289383 846930886 1681692777 1714636915 1957747793 
$ ./rand
1804289383 846930886 1681692777 1714636915 1957747793
</code></pre>

<p>从以上的结果可以看出，rand两次产生的随机数是一样的，之所以这样是因为“在调用rand函数产生随机数前没有先利用srand()设好随机数种子”。如果未设随机数种子，rand()在调用时会自动设随机数种子为1。</p>

<!--more-->


<h1>srand设置随机数种子</h1>

<p>要想每次运行得到的随机数不同，我们还要设置随机数种子。既然要设置随机数种子，那我们就使用srand()来设置rand()产生随机数时的随机数种子。参数seed必须是个整数，通常可以利用geypid()或time(NULL)的返回值来当做seed。如果每次seed都设相同值，rand()所产生的随机数值每次就会一样。</p>

<p>以下例子设置随机数种子然后生成随机数。</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

#define LOOP_TIMES    5

int main(int argc, char *argv[])
{
    int i;

    srand((unsigned int) time(NULL));

    for(i=0; i&lt;LOOP_TIMES; i++)
        printf("%d ", rand());

    printf("\n");

    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>$ ./rand
1943306114 679448932 319436844 1922998560 1458181616 
$ ./rand
1789418334 999331839 757991171 363979956 882919632 
</code></pre>

<h1>合理利用随机数</h1>

<p>运行结果是不是不同了，但这么大的数对我们来说也没有多大意义，又怎么利用这些这些随机数呢？我们可对它进行范围化分，这样就可以产生我们想要范围内的数。</p>

<p>产生一定范围随机数的通用表示公式：a + rand() % n，其中的a是起始值，n是整数的范围；</p>

<p>要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;</p>

<p>要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a，另一种表示为a + (int)b * rand() / (RAND_MAX + 1)；</p>

<p>要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;</p>

<p>要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。</p>

<p>以下例子生成［0，26］之间的数，使用了语句“nu = 0 + (int)( 26.0 *rand()/(RAND_MAX + 1.0));”来获取a到b之间的随机整数。</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

#define LOOP_TIMES    5

int main(int argc, char *argv[])
{
    int i, nu;

    srand((unsigned int) time(NULL));

    for(i=0; i&lt; LOOP_TIMES; i++) {
        nu = 0 + (int)( 26.0 *rand()/(RAND_MAX + 1.0));
        printf("%d ", nu);
    }

    printf("\n");

    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>$ ./rand
6 21 20 22 7
$ ./rand
4 12 25 3 13
</code></pre>

<h1>生成随机字符串</h1>

<p>以下例子用来生成一个指定长度的随机字符串。</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

#define BUFFER_LENGTH 257

int main(int argc, char *argv[])
{
    int leng = 128 ;
    int i, nu;
    char buffer[BUFFER_LENGTH];

    printf("Please Input length for the String, Default is 128, The Maxest legth is 256:");
    fgets(buffer, BUFFER_LENGTH, stdin);
    buffer[strlen(buffer)-1] = '\0' ;

    if(buffer[0] != '\0')
        leng = atoi(buffer);

    srand((unsigned int)time(NULL));
    bzero(buffer, BUFFER_LENGTH);

    for (i= 0; i&lt; leng; i++)
        buffer[i] = 'a' + ( 0+ (int)(26.0 *rand()/(RAND_MAX + 1.0)));

    buffer[strlen(buffer)] = '\0';

    printf("The randm String is [ %s ]\n", buffer);
    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>$ ./rand
Please Input length for the String, Default is 128, The Maxest legth is 256:8
The randm String is [ rdekbnxj ]
$ ./rand
Please Input length for the String, Default is 128, The Maxest legth is 256:36
The randm String is [ bvfrbvvhdcuwdoarefcrkytsntltawpbsusu ]
</code></pre>

<p>注意，需要使用bzero(buffer, 257)这条语句将缓存清空，否则生成的随机字符串中可能就会出现乱码的情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下PDF文件的操作与转换]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/linuxxia-pdfwen-jian-de-cao-zuo-yu-zhuan-huan/"/>
    <updated>2013-07-07T11:21:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/linuxxia-pdfwen-jian-de-cao-zuo-yu-zhuan-huan</id>
    <content type="html"><![CDATA[<p>在Linux中常常涉及到多种文档格式（如doc、txt、html、rtf等等），为了方便文件传递，就可能需要在各种格式之间进行转换。下面介绍几个命令行下的工具，用于将pdf文件转换成其它我们需要的文件格式。</p>

<h1>Pdftk</h1>

<p>如果说PDF是电子纸张，那么pdftk就是电子起钉器、打孔机、粘合剂、解密指环和X光镜片。pdftk是一个简单的工具，可以对PDF文档进行各种日常操作，让你简单而自由地操作PDF。它不需要Acrobat，并且可以运行在Linux,Windows,Mac OS X,FreeBSD和Solaris上。在Debian/Ubuntu中你可以通过apt安装pdftk:</p>

<pre><code>$ sudo aptitude install pdftk
</code></pre>

<!--more-->


<p>将两个或更多个PDF合并成一个新文档：</p>

<pre><code>$ pdftk 1.pdf 2.pdf 3.pdf cat output 123.pdf
</code></pre>

<p>或者使用句柄:</p>

<pre><code>$ pdftk A=1.pdf B=2.pdf cat A B output 12.pdf
</code></pre>

<p>或者使用通配符:</p>

<pre><code>$ pdftk *.pdf cat output combined.pdf
</code></pre>

<p>将多个PDF中选定的页面分离出来并形成一个新文档：</p>

<pre><code>$ pdftk A=one.pdf B=two.pdf cat A1-7 B1-5 A8 output combined.pdf
</code></pre>

<p>将PDF的第一页顺时针旋转90度：</p>

<pre><code>$ pdftk in.pdf cat 1E 2-end output out.pdf
</code></pre>

<p>将整个PDF文档的页面旋转180度：</p>

<pre><code>$ pdftk in.pdf cat 1-endS output out.pdf
</code></pre>

<p>用128位强度（默认）对一个PDF进行加密，保留所有权利（默认）：</p>

<pre><code>$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foopass
</code></pre>

<p>同上，唯一例外的是需要密码才能打开这个PDF：</p>

<pre><code>$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foo user_pw baz
</code></pre>

<p>同上，例外的是允许打印(在PDF被打开以后)：</p>

<pre><code>$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foo user_pw baz allow printing
</code></pre>

<p>加密一个PDF：</p>

<pre><code>$ pdftk secured.pdf input_pw foopass output unsecured.pdf
</code></pre>

<p>合并两个文件，其中一个是加密的 (输出是不加密的)：</p>

<pre><code>$ pdftk A=secured.pdf mydoc.pdf input_pw A=foopass cat output combined.pdf
</code></pre>

<p>解压PDF页面流，以便可以在文本编辑器中编辑PDF代码：</p>

<pre><code>$ pdftk mydoc.pdf output mydoc.clear.pdf uncompress
</code></pre>

<p>修复一个PDF被破坏的XREF表和流长度 (如果可能的话)：</p>

<pre><code>$ pdftk broken.pdf output fixed.pdf
</code></pre>

<p>将单个PDF文档拆分成一个个页面，并且将相关数据报告到doc_data.txt：</p>

<pre><code>$ pdftk mydoc.pdf burst
</code></pre>

<p>报告PDF文档的元数据、书签和页面标签：</p>

<pre><code>$ pdftk mydoc.pdf dump_data output report.txt
</code></pre>

<h1>Poppler</h1>

<p>Poppler是一个基于xpdf-3.0代码基础的PDF渲染库。 Poppler-utils软件包包括了pdftops (PDF到PostScript的转换器), pdfinfo (PDF文档信息提取器), pdfimages (PDF图像提取器), pdftohtml (PDF到HTML的转换器), pdftotext (PDF到text的转换器), 以及pdffonts (PDF字体分析器)。Debian/Ubuntu用户可以通过apt安装poppler:</p>

<pre><code>$ sudo aptitude install poppler-utils
</code></pre>

<p>将可移植文档格式(PDF)文件转换成纯文本：</p>

<pre><code>$ pdftotext example.pdf example.txt
</code></pre>

<p>如果文本文件未指定, pdftotext将file.pdf转换成file.txt。如果文本文件是?-’，则文本会被送到标准输出。</p>

<p>转换第3到7页(包括3和7)使用:</p>

<pre><code>$ pdftotext -f 3 -l 7 example.pdf example.txt
</code></pre>

<p>只提取第3页：</p>

<pre><code>$ pdftotext -f 3 -l 3 example.pdf example.txt
</code></pre>

<p>下面的命令可以维持原始的物理布局并按阅读顺序输出文本。如果不想插入页面分隔符你可以设置-nopgbrk选项。如果PDF文件有密码保护，可以设置-opw (拥有者密码)或者-upw (用户密码)选项。</p>

<pre><code>$ pdftotext -layout example.pdf example.txt
</code></pre>

<p>pdftohtml是一个将pdf文档转换成html的程序，它在当前工作目录中产生输出。pdf文件转换成html:</p>

<pre><code>$ pdftohtml file.pdf file.html
</code></pre>

<p>如果你想要看到图形，需要使用-c(也就是“complex”) 选项:</p>

<pre><code>$ pdftohtml -c file.pdf file.html
</code></pre>

<h1>Pdfimages</h1>

<p>Pdfimages从可移植文档格式(PDF)文件中提取图片，保存为可移植像素图(PPM), 可移植位图(PBM), 或者JPEG文件。Pdfimages读取PDF文件，扫描一个或多个页面，并将每一个图像写入一个名为image-root-nnn.xxx的PPM、PBM或者JPEG文件，其中nnn是图像编号，xxx是图像类型(.ppm, .pbm, .jpg)。Pdfimages从PDF文件提取原始图像数据，不做任何额外的变化。任何PDF内容流里的旋转，剪切，颜色反转等动作都被忽略。</p>

<p>从example.pdf提取所有的图像，图像会被保存为PPM格式：</p>

<pre><code>$ pfdimages example.pdf exampleimage
</code></pre>

<p>使用-j选项将图像保存为JPG格式：</p>

<pre><code>$ pfdimages -j example.pdf exampleimage
</code></pre>

<p>使用-f和-l选项制定起始页和结束页。为了扫描第3至7页(包括3和7)使用：</p>

<pre><code>$ pfdimages -f 3 -l 7 example.pdf exampleimage
</code></pre>

<p>只扫描指定的某一页使用:</p>

<pre><code>$ pfdimages -f 3 -l 3 example.pdf exampleimage
</code></pre>

<p>如果PDF文件有密码保护使用-opw和-upw选项:
-opw 拥有者密码
-upw 用户密码</p>

<h1>ImageMagick</h1>

<p>如果要将PDF转换到图像，首先你的机器上必须已经安装ImageMagick。要在Debian/Ubuntu上安装ImageMagick可以运行下面的命令：</p>

<pre><code>$ sudo aptitude install imagemagick
</code></pre>

<p>要将pdf文件转换成图像使用‘convert‘命令:</p>

<pre><code>$ convert doc.pdf doc.jpeg
</code></pre>

<p>转换成tiff</p>

<pre><code>$ convert doc.pdf doc.tiff
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内核中关于isdigit和min（max）的实现]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/nei-he-zhong-guan-yu-isdigithe-min%28max%29de-shi-xian/"/>
    <updated>2013-07-07T10:41:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/nei-he-zhong-guan-yu-isdigithe-min(max)de-shi-xian</id>
    <content type="html"><![CDATA[<p>isdigit、min、max等函数或宏定义是我们平时最常使用的，但往往没有更多的去思考它们的效率及其副作用。下面让我们来看看，内核是如何实现它们的。</p>

<h1>isdigit</h1>

<p>在标准C中，isdigit函数可以用来判断字符是否为0~9之间的数字。比如：</p>

<pre><code>int a = isdigit('1');
int b = isdigit('a');
int c = isdigit(3);
</code></pre>

<p>可以使用宏定义去实现这个简单的函数，如下所示：</p>

<pre><code>#define isdigit(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
</code></pre>

<!--more-->


<p>Linux内核中isdigit的实现，其代码如下所示：</p>

<pre><code>#define _U 0x01 /* upper */
#define _L 0x02 /* lower */
#define _D 0x04 /* digit */
#define _C 0x08 /* cntrl */
#define _P 0x10 /* punct */
#define _S 0x20 /* white space (space/lf/tab) */
#define _X 0x40 /* hex digit */
#define _SP 0x80 /* hard space (0x20) */

extern unsigned char _ctype[];

#define isdigit(c) ((_ctype+1)[c]&amp;(_D))

unsigned char _ctype[] = {0x00, /* EOF */
 _C,_C,_C,_C,_C,_C,_C,_C, /* 0-7 */
 _C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C, /* 8-15 */
 _C,_C,_C,_C,_C,_C,_C,_C, /* 16-23 */
 _C,_C,_C,_C,_C,_C,_C,_C, /* 24-31 */
 _S|_SP,_P,_P,_P,_P,_P,_P,_P, /* 32-39 */
 _P,_P,_P,_P,_P,_P,_P,_P, /* 40-47 */
 _D,_D,_D,_D,_D,_D,_D,_D, /* 48-55 */
 _D,_D,_P,_P,_P,_P,_P,_P, /* 56-63 */
 _P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U, /* 64-71 */
 _U,_U,_U,_U,_U,_U,_U,_U, /* 72-79 */
 _U,_U,_U,_U,_U,_U,_U,_U, /* 80-87 */
 _U,_U,_U,_P,_P,_P,_P,_P, /* 88-95 */
 _P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L, /* 96-103 */
 _L,_L,_L,_L,_L,_L,_L,_L, /* 104-111 */
 _L,_L,_L,_L,_L,_L,_L,_L, /* 112-119 */
 _L,_L,_L,_P,_P,_P,_P,_C, /* 120-127 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 128-143 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 144-159 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 160-175 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 176-191 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 192-207 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 208-223 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 224-239 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; /* 240-255 */
</code></pre>

<p>字符&#8217;0&#8217;~&lsquo;9&#8217;对应的ASCII码为48~57，映射到上面的<em>ctype数组，相应的位置全是</em>D，<em>D&amp;</em>D则为真，其它的字符则判断为false。对不同种类的字符进行了分类，并使用唯一的二进制来进行标识，使用&amp;和|保证了不同类别的字符不会同时满足两种分类的条件。</p>

<h1>min和max</h1>

<p>实现min和max这两个函数，可以有三种形式：1）定义宏；2）定义函数； 3）定义inline函数。以定义宏举例，一般都是以下形式：</p>

<pre><code>#define min(x,y) ((x)&gt;(y)?(y):(x))
#define max(x,y) ((x)&gt;(y)?(x):(y))
</code></pre>

<p>但是上面的写法是有副作用的。比如输入：</p>

<pre><code>minval = min(x++, y);
</code></pre>

<p>替换宏之后，代码变成：</p>

<pre><code>minval = ((x++)&gt;(y)? (y):(x++))
</code></pre>

<p>可以看出，如果x是最小值，那么它加了两次，很明显是不对的。</p>

<p>Linux内核实现min和max宏：</p>

<pre><code>/*
 * min()/max() macros that also do
 * strict type-checking.. See the
 * "unnecessary" pointer comparison.
 */
 #define min(x, y) ({ \
         typeof(x) _min1 = (x); \
         typeof(y) _min2 = (y); \
         (void) (&amp;_min1 == &amp;_min2); \
         _min1 &lt; _min2 ? _min1 : _min2; })

 #define max(x, y) ({ \
         typeof(x) _max1 = (x); \
         typeof(y) _max2 = (y); \
         (void) (&amp;_max1 == &amp;_max2); \
         _max1 &gt; _max2 ? _max1 : _max2; })
</code></pre>

<p>1、typeof(x)的用途：得到x的类型信息，比如typeof(10) 为int， typeof(1.0)为double。</p>

<p>2、({})的用途：一句语句，({ 和 })之间可以有很多表达式，它的值为最后一个表达式的值。</p>

<p>3、(void)(&amp;<em>x == &amp;</em>y);这一句的作用：判断<em>x和</em>y的类型是否一样。如果是不同的类型，编译器会报“warning: comparison of distinct pointer types lacks a cast”的警告信息。</p>

<p>其实，内核的宏定义就是先引入和x及y同样类型的两个临时变量，然后对临时变量进行求最大值或者最小值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[公交小事]]></title>
    <link href="http://txgcwm.github.io/blog/2013/05/19/gong-jiao-xiao-shi/"/>
    <updated>2013-05-19T16:05:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/05/19/gong-jiao-xiao-shi</id>
    <content type="html"><![CDATA[<p><img class="right" src="http://www.gscn.com.cn/upload/image/2009/10/21/1256085698750.jpg" width="300" height="386" title="Place Kitten #3" ></p>

<p>很舒适的坐在公交后面的位置上，拿着手机看完了一篇文章，退出了应用看了一下时间是8：19，不到百米的距离就要到站了。正当我暗自庆幸能够很早到公司的时候，传来一个女人A的声音“你偷我东西”。A推了女人B一把，B也不甘示弱，迅速还击，两个女人拳打脚踢，几个乘客也因激烈的战斗而离开自身的座位。现在我才明白比男人的战争更恐怖的是女人间的战争。</p>

<p>司机见此状况，将车子停在了路的一旁，开始调解。司机问A有没有东西被偷，是否要报警，A和B都同意报警，司机和B都打电话报了警。司机接着又补充道“警察未来之前谁也不准离开”，这个做法全国的公交应该都这样吧，个人不是反对而是赞成。</p>

<p>在这间隙，A诉说着她事件：她站在靠下车门的地方，B站在另一测，另外一个女人C站在她的同一侧，她刚好在B和C的中间，她本能的感觉到有手深入她的手提包在偷她的东西，她怀疑B和C在合谋偷她的东西。接着发生了前面提到的那一幕。A也补充到她上车的时候手提包的拉链是拉紧的。B也解释道没有偷A的东西，同时也不认识C。由于当时是低着头看手机，加上距离比较的远，我并不清楚事情到底是否有偷窃的事情。</p>

<!--more-->


<p>过了一小会儿，警察还是没有来到。很多人就问司机能不能让那两个女人下车，让她们独自等待警察，然后送我们去上班，司机拒绝了这些不合理的请求。在这种情况下，他们就转向了A，让她们自己下去。其他人的声音我听得不是很清楚，我身边的一个女人的话大概是这样的：“东西有没有被偷呢？没有的话就算了。要叫警察的话，你们自己下去等，浪费别人的时间。我们又没有偷你的东西，对我们凶什么凶了，神经病的！”车上80%的人表示的都是类似的声音。面对如此喧嚣的声音，我的前座的一个男人和前座的前座的一个男人都劝大家稍安误噪，要多体谅。</p>

<p>女人A面对这些攻势，有些激动，大声的回应道：“要不是我不让你们走，是司机不让你们走。幸好东西没有被偷，偷了的话你们就高兴了是吧？大家上班不就是为了挣钱嘛，要是东西被偷了还挣钱干嘛。要是你们被偷了会怎样？我已经被偷了两个iphone4s了。”</p>

<p>过了30分钟左右，警察来了。警察看了司机的证件，同时要了B的证件，让她们几个当事人下车。C没有跟着去，A走到C的面前，厉声道“你也一起走”。她们下了车，公交车继续前行。警察没有询问公交车上乘客任何问题，不至于每个人都低着头看手机而没有看到一些事情吧？我认为这是警察做得不足之处。</p>

<p>下车之后，一个哥们说B和C她们肯定是小偷，我不知道他的判断依据是什么，或许每个人都有自己的判断吧。</p>

<p>以上当事人的话语并不完完全全是原话，所写的是表达她们原话的意思。有几点我很不解：一、那时公交车上已不是很挤，人很稀疏的站在车内，加上是监控对准的地方，如果要偷窃的话，她们是不是很傻或者是神偷；二、女人B报了警，或许真的被冤枉，或许技术高超到知道如何挡住摄像头，我不明白；三、我没有听到女人C一句反驳的话语，如果被冤枉的话，一般人的反应不会那么平静，难道是见过大世面的人。</p>

<p>从以往的经历来看，A可能被偷怕了，对这类事情已经过敏了。或许是自己忘记了将拉链拉上，这些我们也无从知晓。警察调出视频查阅后，如果没有发生偷窃的事情，当然是好事，可以还B和C一个清白，那么A可能需要反省一下自己；如果真的有这样的事情发生，那么该惩罚的应该得到相应的惩罚。</p>

<p>发生这种事情，如果我们是事件中的A，我们又会如何处理：没有被偷就算了，还是报警？我们是旁观者，当我们思考着因报警而耽误上班时间的时候，我们是否应当先思考一下这个问题呢。当很多事情与我们无关的时候，我们是否应该如此的漠视呢？当我们是受害者的时候，如果得不到旁观者的支持，我们是否会觉得孤独，这个世界很残忍呢？面对这个繁杂而又浮躁的社会，我们真的应该学会设身处地的思考。</p>

<p>司机师傅的举动，由衷向他表示敬意。</p>

<p>警察的行动速度真的太慢了，不知道当国家面临危险的时候，你们是否只会选择“打扫战场”。处理事情的方式是否也能改进改进，这么多乘客在这里并不只是专门是在等你如此解决问题，我们中的某一个或许就是你的目击证人，不然就辜负了司机师傅的用意了。</p>

<p>这种事情每天都在公交车上上演，大家又是如何看待的？</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[残剑]]></title>
  <link href="http://txgcwm.github.io/atom.xml" rel="self"/>
  <link href="http://txgcwm.github.io/"/>
  <updated>2013-08-06T21:36:39+08:00</updated>
  <id>http://txgcwm.github.io/</id>
  <author>
    <name><![CDATA[残剑]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[毕业后的抉择]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/06/bi-ye-hou-de-jue-ze/"/>
    <updated>2013-08-06T21:34:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/06/bi-ye-hou-de-jue-ze</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://p.qpimg.cn/cgi-bin/cgi_imgproxy?url=http%3A%2F%2Fa1.att.hudong.com%2F07%2F52%2F19300001049826131285529454110_950.jpg&size=0"></p>

<p>在学校的时候，老师总是给我们传输“先就业后择业”的观点，尤其当我们被一场场面试打击之后，更加觉得这句话在理。以我现在的观点来看，这完全是误人子弟，还不如不说，让学生们自己去体会。接下来谈论的都是个人在工作中的体会，仅限于IT行业，其它行业的情况我不清楚，所以不敢随意说道。</p>

<!--mopre-->


<h1>理想与现实</h1>

<p>在学校的时候，大部分人可能都豪情壮志，希望从事一份自己理想中的工作。期间也可能对这些东西有过了解、学习，但与有些公司的要求始终存在着差距。往往这些时候，很多人会犹豫，会改变原来的道路，选择一个会接纳我们的公司。如果那个公司跟我们想做的事情有些相同，那是最好不过的，可大部分情况不是那样。即便我们去了，工作的热情也会大大折扣。</p>

<p>所以即使我们不能找到那个最合适的公司，那我们也应该选择和我们理想中工作相似的公司，这样才能让我们工作的更有激情，让职业方向能够有延续性。那样的选择可能只会得到较低的薪水，但对后期的发展会很有帮助，也不会让你工作的很迷茫。看过很多人的博客，了解过他们很多的经历，有一部分人在不能选择自己最初理想的公司的情况下，他们会选择一家较符合自己理想的公司（可能那只是一个偏远的工作）。一年或者两年后，他们重新找工作，往往能够找到心仪的工作。虽然他们随同时间在老去，可精神上依旧焕发着光彩，激情依旧无限。</p>

<p>拿着一份不错薪水、做着一个不太喜欢的体面工作，还是选择低薪却是自己喜欢做的工作？就看一个人的心有多大、魄力有多少！</p>

<h1>大与小</h1>

<p>关于这方面的选择，我比较倾向于大公司。除非你是牛人，否则就应该到大公司去学习学习。大公司已经形成了很好的规模，人尽其责，基本上每个人只需要负责一块内容，这将会导致成长很慢，学不到东西。虽然可以把一块做的很精，但有好多东西没什么深度，如果长期维护将会导致你停滞不前。</p>

<p>所以学习还得靠自己的努力。在大公司学习有一个好处就是，有优秀的架构师（良好的架构）和优秀的高级开发（可以写出漂亮的优秀的代码，源代码就是最好的学习资料），这些人都是很好的学习对象，而且有良好的培训机制。我们可以直接去看他们的源代码和架构，了解和学习架构是怎么搭建、代码如何规范书写，我们不用走万里路就可以把这些先进和优秀的东西都装进我们的知识库中，站在巨人的肩膀上前进。</p>

<p>在大公司待几年后，不该适应安逸的生活，应该去小公司看看。好多小公司都是3、4（可能只有你一个）个人一小组，工作量大、杂，什么都要做，就连测试都要亲历亲为。怎么看都觉得这不是人待的地方，被严重剥削廉价劳动力。</p>

<p>我们要从当中看到优势，我们才有可能进步。逆向思维下，工作量大、杂是坏事吗？在我看来，对于一个想真正成长，想将来有一番作为的人，这正是小公司的优势。小公司的员工有一个普遍性，就是学历技术都很普通，无法很好的进入到大公司，也只能在小公司游走，但心里也有抱负和理想。</p>

<p>杂是一个很好的东西，就是因为人少，所以什么都得做，这样我们就可以接触到很广泛的东西，有可能连架构设计都要自己去处理，说不定图都要自己去PS。如果把所做的这些事情拼接起来，这将会是很大的一张蓝图。而我们要做的就是在工作中不断地去学习，花大量的时间去看书，去了解蓝图中的每一块是怎么去衔接、怎么关联的。当我们把这些都弄熟了后，那时我们就已经具备了超强的能力。</p>

<h1>我的经历</h1>

<p>虽然我不喜欢前东家的产品、方针政策以及让我负责处理的模块，但我很感谢它将我带入到了软件开发这条道路上。前东家是一家大型的芯片设计公司，但产品已经走向淘汰的边缘。虽然在观念上没有什么长进，但在公司的工作流程、软件架构设计、工作方式等方面还是学习到了很多东西，现在的一些良好习惯就是从那个时候养成的。在这里一年后，毫不犹豫的交完学费，离开了。</p>

<p>现在的东家是一家小型的创业公司，幸运的是，我进去的时候还有一个“老人”可以带领我前行。很多事情都需要你独自去完成，刚到手的时候你会茫然而不知所措，但随着自己的学习和了解，很多的困难都会迎刃而解。在这里，我更多的是技术上的长进以及视野的开阔（毕竟很多东西需要自己去挖掘）。更重要的是，它让我成为了一个网络人，从前我是“设备商”的思考方式，而如今增添了一分“网络人”的思考。同时，也让我喜欢上了开源的一切。</p>

<h1>总结</h1>

<p>好多程序员还是很有钻研精神的，学习是他们的一个乐趣，也可以让他们展示自我价值。那些一直在坚持更新技术文章的博主就是典型的例子，如果得不到成长、学习不到新的东西，我想他们应该就会不爽。
读万卷书，不如行万里路，行万里路不如跟随成功人士的脚步。在大公司我们就是要跟随成功人士(公司的架构师和高级工程师)的脚步，去了解、学习他们；在小公司就如行万里路，我们只有多做多学才可以迈出去，将那些成功人士的经验彻底吸收。</p>

<p>以上那些话是个人的一些感受，很浅显，最想对应届生说。工作已经三年了，我们是选择“放弃自己”，还是选择“在路上”？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[楚霸王三追韩信]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/05/chu-ba-wang-san-zhui-han-xin/"/>
    <updated>2013-08-05T21:11:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/05/chu-ba-wang-san-zhui-han-xin</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://chuhan.173.com/resources/jpg/130515/10271368580519378.jpg"></p>

<p>世人皆知“萧何月下追韩信”，可又有多少人知道“楚霸王三追韩信”的故事呢！</p>

<p>秦朝末年，韩信投靠实力雄厚的项梁军队。因轻敌，项家军在定陶被章邯打败，项梁战死，韩信归项羽统领。项羽看韩信生得尖嘴猴腮、其貌不扬，没看上他，只让他做个执戟郎。在多次战役中，韩信曾多次给霸王献计献策，可项羽认为一个小小的执戟郎不懂军国大事，根本没有把他的话放在心上。眼见在楚军那么久都没有得到提升，韩信也心生去意，准备去投靠实力薄弱的刘邦。</p>

<!--more-->


<p>韩信从马棚里偷偷牵出战马，跨上马连夜逃出军营。 天明点兵，却不见韩信，项羽命人去找后才知道他逃跑了。虽然项羽没把这当回事，可范增却急了，催项羽：“霸王，韩信曾忍胯下之辱 ，可以看出此人胸有大志，不可小瞧啊！得过三部天书，熟知兵法布阵，文韬武略，无人可比。韩信骑的是寻常战马，没你的乌骓宝驹跑得快，骑上宝驹去追韩信，一定能把他追回来。如若跟你回来就重用他，可保疆土永存；不回，宁可把他杀了也万万不能让他投奔刘邦，否则后患无穷！”项羽被亚父说得半信半疑，赶紧骑上乌骓前去追赶。</p>

<p>韩信催马加鞭，紧跑慢跑，一口气跑了几十里，人累马乏。看看前边有个村庄，就下马在庄头的老柳树下歇息，却被树上一个光腚没穿衣服的小男孩撒了一身尿。本想教训几句，忽然脑瓜一转，怒气全消。他满脸堆笑，从身上掏出二两银子给小孩并告诉他：“待会儿有个大个子骑着黑马从这路过，你尿他的话，他会给你更多的钱。如果不给的话，你就缠着他！现在你赶紧回去喝水吧。“小孩一听，乐坏了，就赶紧下树回家喝水，接着回到树上等着了。 韩信不敢多歇，只让马啃了几口草，喝足水，又往西跑去。韩信刚离开，项羽就赶到了，也从老柳树下经过，也被尿了一身。项羽问小孩尿他的缘由，才知道这里发生的事情和韩信刚从这过去了，心想：“小孩尿他，还得给二两银子才过去，连个孺子都弄不过，这样的人能有什么本事，追他回来又有什么用？”想到这儿就从身上掏出银子给了小孩，转身催马回去了。</p>

<p>范增看项羽回来了，急忙追问：“追回来了吗？”项羽说：“一个小孩尿他，他还给了二两银子。一个连小孩都斗不过的人我追他回来有什么用， 就没再追，回来了。”范增听了，急得一把扯住项羽的马缰说：“大王，这正是韩信的计谋，他是故意让小孩迷惑你，耽误你工夫，他好跑得远。大王，快拨马回去，把韩信追回来，千万不能让他投了刘邦！”项羽只好二次去追韩信。</p>

<p>韩信正催马跑着，忽听身后有隐隐马蹄声，看看路旁有片乱坟岗，急勒住马，下马来到一座大坟墓跟前，裤子一脱，头下脚上，倒栽在坟墓跟前。看项羽到了，呼呼一泡尿，淌了自己一头，还伸出舌头舔嘴边的尿，嘴里还只叨咕：“天降仙露，真好喝!”项羽看得直恶心，心想：“这韩信疯了，连颠倒都不知，自己的尿自己喝，这样的人追回去有何用，就是杀了他也有损我霸王的名声，我还是回去吧。”霸王又拨马回去了。</p>

<p>范增听项羽把二追韩信的事说完，急得直跺脚，头上大汗直冒，扑通一声跪在霸王面前说：“大王啊，快快回转，追上韩信，绑也得把他绑回来。如再耍花样，千万不能手软，只管上前把他杀了，大王如果不去，为臣就跪死在你马前。”无奈，项羽第三次又去追韩信。</p>

<p>韩信正催马疾奔，可眼前一条大河挡住去路。河水又宽又深，河面上无桥，水中无船，就连个打鱼的小划子也没有。韩信急得在河边乱转，心想：“等会儿霸王赶到，如何是好？要是跟他回去，永无出头之日；要是不跟他回去，我又打不过他，非得命丧于此不可。难道真的是老天要绝我韩信吗？”正叹着，忽听身后有咳嗽声，转身一看，是个头发胡子都花白的老头。韩信慌忙下马，上前深施一礼说：“老人家，此处是什么地方，可有渡船过河？”老头还了一礼，对道：“这是陈仓地界，此河叫陈仓河，河面上没有桥，也没有渡船，你要过河吗？看你知礼，我知道什么地方能过河，你跟我来吧。”韩信跟老头来到河边的一棵弯槐树下，老头说：“从这里下去，水下二尺深有条暗桥，叫陈仓桥。这暗桥如今也只有我知道了。”说完老头牵着韩信的手，把韩信带到暗桥边。 上岸后，韩信跪倒给老头磕了三个头说：“不知你老人家高姓大名？日后我也好报答。”老头说：“我姓吕，叫吕昌合。”韩信爬起来又深施一礼说：“我记住您老人家的救命之恩了。”话没落音，拔出宝剑，一剑把老头的人头砍了下来。霸王没有人引路过河，又一次没把韩信追回去。</p>

<p>故事说完了，不想谈论些什么，各位看官“仁者见仁，智者见智”吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[popen和pclose函数]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/popenhe-pclosehan-shu/"/>
    <updated>2013-08-03T22:07:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/popenhe-pclosehan-shu</id>
    <content type="html"><![CDATA[<p>标准I/O函数库提供了popen函数，它启动一个子进程去执行一个shell命令行。popen函数还创建一个管道用于父子进程间通信。父进程要么从管道读信息，要么向管道写信息，至于是读还是写取决于父进程调用popen时传递的参数。以下给出popen、pclose的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FILE *popen( const char* command, const char* mode )</span></code></pre></td></tr></table></div></figure>


<p>参数说明</p>

<p>command： 是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。<br/>
mode： 只能是读或者写中的一种，得到的返回值(标准I/O流)也具有和type相应的只读或只写类型。如果type是“r”则文件指针连接到command的标准输出;如果type是“w”则文件指针连接到command的标准输入。</p>

<!--more-->


<p>返回值</p>

<p>如果调用成功，则返回一个读或者写打开文件的指针；如果失败，返回NULL，具体错误要根据errno判断。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int pclose (FILE* stream)</span></code></pre></td></tr></table></div></figure>


<p>参数说明</p>

<p>stream： popen返回的文件指针。</p>

<p>返回值</p>

<p>如果调用失败，返回-1。</p>

<p>由于平时接触到usb插拔的事情比较多，现以列举系统中usb设备vid/pid为例。本想从<code>/proc/bus/usb/devices</code>中获取到usb设备的相关信息，可Ubuntu系统下没有<code>/proc/bus/usb/</code>这个目录。至于为什么没有这个目录和如何重新找回这个目录，可以查看 <a href="http://ubuntuforums.org/showthread.php?t=1432598">这里</a> 。所以这里我们使用<code>lsusb</code>去获取usb设备的基本信息。构建<code>int get_device_info(void)</code>函数获取系统中usb设备的vid/pid信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int get_device_info(void)
</span><span class='line'>{
</span><span class='line'>  FILE *fp = NULL;
</span><span class='line'>  char buffer[128];
</span><span class='line'>  char *ptr = NULL;
</span><span class='line'>  int vid, pid;
</span><span class='line'>
</span><span class='line'>  fp = popen("lsusb", "r");
</span><span class='line'>  if (fp == NULL)
</span><span class='line'>      return -1;
</span><span class='line'>
</span><span class='line'>  while (NULL != fgets(buffer, sizeof(buffer), fp)) {
</span><span class='line'>      ptr = strstr(buffer, "ID");
</span><span class='line'>      if (ptr) {
</span><span class='line'>          sscanf(ptr, "ID %04x:%04x", &vid, &pid);
</span><span class='line'>          printf("%04x:%04x\n", vid, pid);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  pclose(fp);
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编写主函数调用以上的接口，使用<code>lsusb</code>查看usb设备及执行测试程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ lsusb 
</span><span class='line'>Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
</span><span class='line'>Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
</span><span class='line'>Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
</span><span class='line'>Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
</span><span class='line'>Bus 001 Device 003: ID 1532:0016 Razer USA, Ltd DeathAdder Mouse
</span><span class='line'>Bus 001 Device 004: ID 058f:b002 Alcor Micro Corp. 
</span><span class='line'>
</span><span class='line'>$ ./a.out 
</span><span class='line'>8087:0024
</span><span class='line'>8087:0024
</span><span class='line'>1d6b:0002
</span><span class='line'>1d6b:0002
</span><span class='line'>1532:0016
</span><span class='line'>058f:b002
</span></code></pre></td></tr></table></div></figure>


<p><big>参考文章</big></p>

<p><a href="http://my.oschina.net/renhc/blog/35116">基于管道的popen和pclose函数</a><br/>
<a href="http://networking.ctocio.com.cn/tips/137/9412137.shtml">Linux popen函数的使用总结</a><br/>
<a href="http://bbs.chinaunix.net/thread-4087539-1-1.html">关于/proc/iomem中信息解释</a>  <br/>
<a href="http://tech.watchstor.com/storage-systems-117859.htm">proc文件系统功能总览</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我们想到的，别人做到了]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/wo-men-xiang-dao-de-%2Cbie-ren-zuo-dao-liao/"/>
    <updated>2013-08-03T15:24:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/wo-men-xiang-dao-de-,bie-ren-zuo-dao-liao</id>
    <content type="html"><![CDATA[<p><img src="http://www.empowernetwork.com/freedomlife/files/2013/03/Action.png"></p>

<p>我们有很多很多的想法，但又有谁扪心问过之后，可以坚信的说“我不仅想到了，而且做到了”。不得不承认，我完全没有做到，在某种意义上说，我就是一个失败者。大学的三年里，没有留下太多的回忆！借老大的一句话来描述我此时的心情以及三年的感触——三年过去了，你已经站在了我需要仰望的地方。</p>

<p>在成长的过程中我们逐渐与别人产生了差距，很多的事情我们想到了，可别人却已经做到。</p>

<!--more-->


<p></p>

<h1>盒饭</h1>

<p>暑假有很多的留校生（考研生，实习生，培训生，还有一部分无所事事生），总计600多人。而且我们这里有暑期的学府考研班，来到这里的还有西安工程大学和二炮的学生，他们下午要继续上课，所以中午必然留在我们学校。这是一个巨大的市场！</p>

<p>送盒饭的理由：一、食堂的伙食并不是很符合广大同学的心意；二、外面的饭店开张的并不是很多，吃饭等待的时间比较长；三、夏天真的很热，我们是“天之骄子”，惧怕这毒辣的太阳。</p>

<p>产生了这个想法，但始终没有行动。过了几天，我发现有同学已经在开展这项业务，并且宣传已经做到了我们的门上。有一天终于联系到了一个老板，他同意和我们合作。我们开始做了，每天都活在期待中，期待手机的响动，等待着那些客户。过了一些时间，我们的对手不见了，他们破产了，据说是质量不是很好。可是，我们也在十多天后破产了，其中的原因我也在前面的文章里提到了。不过我要说的是，我们的那个老板很不错，手艺也不错，价格很低廉。他的店名叫“巴渝川香居”，我极力推荐，如果各位朋友有机会的话，可以去品尝品尝！</p>

<h1>莲子</h1>

<p>偶然间，和几个同学走到了学校的三里河畔，看到了荷花盛开，那一株株莲子妖艳的向来往的过客招手。它们清楚，处在河的中间地段不会招来杀生之祸。可是它们错了，不幸的是遇见了我。下了水，结束了它们的性命。摘的不是莲子，而是一种乐趣！</p>

<p>回到了宿舍有种想法，我可以出售莲苞——在七夕情人节这一天。卖的不是莲子的营养，而是一种概念。我并不是一个很开放的人，需要一个人合作，可没有找到一个合作的伙伴，结果这个计划流产了。说实在的，针对七夕情人节的广告我都已经做好了。</p>

<p>没有实施这个计划，我把莲子送给了一个我一直喜欢着的女孩，本想送上两株莲苞的，可她没有收下，只要了6颗莲子。原本只是摘给她的，可是一冲动就摘得有点多了，剩下的就和同学分享了。</p>

<h1>打包的袋子</h1>

<p>马上就要搬到雁塔校区了，那时肯定需要很多的编织袋，这毫无疑问。我和同学一商量，决定做这桩生意。起先的时候，我们根本没有把握，都已经做好了赔本的准备。我们没有太大的胆量，所以只投入了600元。起初也没想盈利，只是想尝试着做一件事情。</p>

<p>就以在校的同学为对象，我们跑到宿舍作了一个调查，了解同学们的一个具体看法。我们来到一个宿舍（他们之后就是我们的对手了），当推进门的时候，我发现他们宿舍已经放满了编织袋，数量是五百之上。我们很佩服他的魄力，能够一次购买如此大的货量。最主要的是，我们还只是停留在想法的时候，他们已经开始行动了。我们不得不佩服！</p>

<p>我们进的布制编织袋价格比较的贵，所以第一次进的量比较的少，进了150个。有了上次的教训，我们的行动也就早了些。学校规定的是在24号到学校，我们在18的晚上就开始行动了，我们避开了对手，在6号楼开始了试销。第二天晚上，我们到了1号楼销售，在这里我们占据了很大的一个市场。可以肯定的说，我们销售是在所有的学生商家中是最早的。</p>

<p>第一次的150多个我们花了较长的时间才把它卖完。那时很多的同学都没有来，于是我们决定再去进货，这次我们又进了150个，这一次我们用了1天多的时间就把它卖完了。或许是因为贪婪吧，又进行了第三次进货（150），这次进货用的是我们前两次的利润，可以说我们是在赌了（可事实告诉我们，并不是我们想的那样，市场还有很大的容量，只是我们并不知晓这个市场的具体情况）。第三次，我们花了1天的时间全部清货。后来，我们实在不敢进货了，我们就等着电话订单，统计之后完全能够赚回成本，我们又进行了第四次的进货（73个，比订单多进了10多个）。这次，我们清货的速度更快。很多同学再问的时候，我们只能拒绝了。</p>

<p>在后来的一两天内，我们接到了很多的电话，定的数量也很大，但我们都拒绝了，我们制止了我们自己的贪婪。同时，我们也想让自己休息一下，这些天下来实在很累。</p>

<p>有人说，卖袋子赚钱了。我说，确实赚钱了。可是又有谁看到了其中的艰辛，没有人能够体会到。我和我的合作伙伴已经被楼管阿姨给封杀了，只要见到我们就盘问，盘问的结果就是不让我们进宿舍楼（当然我们自己的宿舍楼还是可以进的），即便你是去找老同学。</p>

<p>非常感谢我的合作伙伴，辛勤的付出和不懈的努力，以及那些具有智慧的商业策略。可以毫不自夸的说，我们的质量是最好的，我们的销售是最早的，我们的售后服务是最好的，我们合伙人的人均利润是最高的，我们合伙人的数量是最少的，我们也是最早销售完的。可是，也有很多东西我们没有做得最好，我们并不是最早行动的，别人已经在行动，而我们只是停留在想法当中！</p>

<p>但愿此文在今后的日子里，给自己有所提示。有了想法之后，尽早的采取行动。如果我们想要成功，我们就必须不懈的努力，比别人多做一些，行动的更早一些！</p>

<br></br>


<p>书于雁塔校区本部宿舍，2009年8月29日21时11分</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[致未来的合作伙伴]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/zhi-wei-lai-de-he-zuo-huo-ban/"/>
    <updated>2013-08-03T15:12:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/zhi-wei-lai-de-he-zuo-huo-ban</id>
    <content type="html"><![CDATA[<p><img src="http://trusbe.com/wp-content/uploads/2013/05/%E4%B8%AD%E5%9B%BD%E5%90%88%E4%BC%99%E4%BA%BA-%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C.png"></p>

<p>首先想说的是——你选择了我作为你的合作伙伴，我感到万分的荣幸。对于当代的我们来说，要靠一个人独自去做一件事或者事业真的很难，唯有合作才能创就一番事业，毕竟个人的能力总是有限的。起初我认为凭借个人的力量能够做得很好（的确我依旧这么认为），可是那要花费大量的时间，等到真正完成的时候时机可能已经错过了。</p>

<!--more-->


<h2>信誉是第一</h2>

<p>从小到大，家长、老师都在教导我们，做人必须讲信誉。确实如此，上了大学对此深有体会。我发现很多人答应其他人的事情只是信誓旦旦，等到真正要做的时候却推脱。这就好比是一个突然的袭击，或许这只是一件小事，但也是致命的打击！我也清楚，在某些时候确实是有一些要紧的事要办，可是既然已经答应了，这件事情就是第一位的。如果要离开团队，那就提前说明，不要等到关键的时刻。当然，紧急的事情也是会得到队友谅解的。所以，在做一个决定前首先考虑仔细，不要轻易答应别人的邀请。我们都已经很大了，心血来潮已经不属于我们。我敢肯定的是，当你失信别人一次时，这种事情就没有第二次发生了，而且你的声名也就此远播了。</p>

<h2>做事第二</h2>

<p>做事也就是做人，看一个的做事态度就可以看出一个人的做人态度，我很坚信这一点。很多人或许会认为“做事要积极”这话说的很虚，我也认同。可我要换种说法，做事要主动，不要总是等着别人告诉你去做什么才开始动手或者等到任务下来，要主动去询问。在很多的时候，谁都不知道接下来要做的事情，只有在不断的探讨中才会发现，或许那就是在不知不觉中创造的机遇。我想很多人都是喜欢主动型的。因为我们是合伙人，所以彼此的地位是平等的，在这个团队中我们都有责任去发现更多的问题，不能总是等待。如果只是等待，迟早有一天你要么出局，要么是昔日合作伙伴的下属。</p>

<h2>实力是第三</h2>

<p>我们自己有多少本事，我们自己心里都很清楚，有多少力量做多少的事。打肿脸蛋充胖子是很划不来的，迟早是要被看穿的。在一个人说话做事的时候，一个人的实力就暴露无遗了。经常看到人们总是在显示自己的才华，可那正是在述说着自己的无知。所以，我依然坚信“是金子总是是会发光的”！当然，我们不能一味的埋藏自己，把自己藏在别人无法看到的地方。</p>

<p>很喜欢这样一个故事——一个年轻人去看手相，大师没有看，只是让他握紧了手，然后问道“你的事业线在哪”，年轻人很不解地道“在我的手上啊”。大师只是说了那么一句“既然在你的手上，那你何必跑过来问我呢！你还是回去吧”。年轻人大悟&hellip;&hellip;</p>

<p>命运就掌握在我们的手上，我们又何必苦苦去追寻呢！ 一起努力吧，未来的世界属于我们。一个人的成功重点不在于智力，而在于一个人做人的态度。正如我上面把“做事就当成是做人”不是很准确，做人它包含了很多的方面，以上的三点归根结底也就是做人了！ 我坚信你是一个不平凡的人，如果你看到了最后，那么我决定&hellip;</p>

<br></br>


<p>书于7#527宿舍，2009年8月7日10时2分</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我们为什么败了]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/wo-men-wei-shi-yao-bai-liao/"/>
    <updated>2013-08-03T14:52:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/wo-men-wei-shi-yao-bai-liao</id>
    <content type="html"><![CDATA[<p><img src="http://apollo.s.dpool.sina.com.cn/nd/grouphenan/pics/c3/b6/c3b60fcf7612ed5ff4a01fb525f47765.jpg"></p>

<p>当我问出“为之奈何？”时，我已经作出了决定——宣布我们的事业失败。就在昨天晚上正式结束了。原本没有死心，想看看7月26日的状况，可是没有人“买单”了，问题已经很明显，根本没有必要强撑着了。</p>

<!--more-->


<p>从7月15日到7月25日为止，为时11天的“暑期快餐服务计划”成为了过去。计划分为两个阶段：前期老板不在，采取了让其它家做饭的策略，但饭菜的口味并不是很符合。为了不破坏我们的承诺，决定给他们免费带饭；后期从老板那里取盒饭！</p>

<p>一切就那样的发展着，很似平静，基本的矛盾并未道破（基本矛盾一直都存在着）。彼此心里都明白，但都没有说出来。是协作的需求还是其它的原因——而没有把基本的矛盾在桌面上摆开来说，我也说不上具体的来。</p>

<p>可昨天，一件事情引发了导火索。老板在盒饭里参杂了馊饭，事情又很巧的是：馊饭是半生不熟的，有同学告诉我“他吃的竟然是酸的”。我向那些同学道歉，给他们优惠，虽然他们表示了谅解，可这是出于礼貌或者是中国人的一些传统性答复。可事实告诉我们，我们并没有得到多大的谅解。</p>

<p>今天中午，一个女生订3份，可我一口给拒绝了，我没有那个勇气说“好的，待会儿给你送到”。那个女生昨天中午在我们这订餐了，昨天的事件完全毁了我们的信誉。人无信，则不能立。我又怎么能在无保障的前提下，再做下去呢？</p>

<p>午睡之前，同学问我“失败的根结是在哪里？”，我反问他，他告诉我两点——信誉和品质。我想说的是，说得很正确，但它并不是最根本的，有一件事是引起这一切的根源，而未能将这件事处理了是我们最大的失误！下面说一下有这两点的原因。</p>

<h2>信誉问题</h2>

<p>虽然没有在我们的传单上标明我们送的绝对是新鲜饭，但送新鲜饭是必须的，世人都知道的道理。送了馊饭，严重的损毁了我们的信誉。其次，原本允诺的四个菜，我们也没有实现。其中的原因在根本原因中说明。</p>

<p>当发现这个问题的时候，我跑去问了老板。我并没有直接说“老板装的是馊饭”，而是问道“老板，今天中午的饭怎么是两种颜色，上一层是白色的，下一层却是带有黄色的”。当时老板并没有听明白，我重复了多次之后，老板才恍然大悟，明白了我的具体意思。而老板娘在我说完第一遍之后，就在笑了。老板也就坦诚的承认了。</p>

<h2>品质问题</h2>

<p>品质就是品味和质量的综合。在口味上，并没有让客户十分满意；在质量上，每天都是粗菜，有的同学现在见到黄瓜都怕了。</p>

<h2>根本原因</h2>

<p>引起以上的两个问题的最根本原因是盒饭的份数不多。我们很清楚：如果只是做几份盒饭的话，要满足我们的要求（四份菜，其中要两荤两素），那是一个巨大的成本。商人利字当先，老板怎么可能为了我们那样做呢？所以给我们只做了两个菜，一直这样，直到合作的破灭。</p>

<p>馊饭的出现，也跟“少量的份数”有关。饭是超前做的，根本不知道份数的多少，所以也是多做的。多余的饭也就留给了第二天，事情也就发生了。</p>

<p>现在来一个假设，我们有很多的客户，那么我想老板是不敢这样做的。有了大量的盒饭份数的话，对于老板来说的话是一个巨大的利益诱惑，他又怎么敢那么做呢？同时，菜也会变得丰盛，份数增加，菜的成本就会分摊，也就不可能那么单调了。</p>

<p>有同学说“找一个开张的饭馆合作，就不会出现馊饭的事件了”，也是啊，馊饭食不会出现了。可那个最根本的矛盾还是依旧存在的，彼此心里都明白。如果没有妥善的解决，其它的事件还是要出现的。</p>

<p>“份数”没有做上去，是我们缺乏激情，还是没有那种能力，抑或是&hellip;？？？一切的根究，我心里很明白！失败了，败在没有勇于去开拓市场，败在没有勇于去实现自己的想法。归根结底，是败给了自己！</p>

<br></br>


<p>书于7#527宿舍，2009年7月26日16时27分</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐一本好书《货币战争》]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/tui-jian-%5B%3F%5D-ben-hao-shu-%3C%3Chuo-bi-zhan-zheng-%3E%3E/"/>
    <updated>2013-08-03T14:39:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/tui-jian-[?]-ben-hao-shu-<<huo-bi-zhan-zheng->></id>
    <content type="html"><![CDATA[<p><img src="http://www.cr173.com/up/2010-7/2010719183816.jpg"></p>

<p>如果你酷爱金融或者不想让自己在未来的金融大战中灭亡的话，看一下这本书是绝对没有错的。在本学期我所看过的书中，《货币战争》我认为是很不错的。世纪大战的可能性现在几乎很小，可是有另外的一种战场，那就是金融大战，它的毁坏能力超过了战争。</p>

<!--more-->


<p>国际上的金融被一群叫做“国际银行家”的精英小团体所控制着，操纵着欧美国家的货币发行。欧美国家的政府是没有货币发行权的，掌控这一切的是那些个人小群体，而国家通过抵押国债来获取货币，这些国家是以人民的未来税收作抵押。也就是说他们永远也还不清他们所欠下的债务，利滚利的威力是无穷的。</p>

<p>欧洲的政府在斗争过程中失败了，美国政府的努力也没有取得进展，美联储照样被私有化了（美联储的职责就和中国的中央银行一样）。国际银行家们正在试图着废除“黄金是货币之王”的地位，如此他们就可以永无止境的发行货币，达到他们的野心。虽然每一次的斗争，他们都没有取得胜利，可是他们都取得了一些“成就”，为下一步做好了准备。</p>

<p>要知道中国是少数几个政府拥有货币发行权的国家之一，国际银行家们早就在觊觎这块肥肉了，那时对于中国是个很大的危机——富裕了少部分人，却使多数人无比贫穷。迫在目睫的大问题已出现，如果应对失误，2009年的中国将会面临巨大的损失。现在中国要对付的不仅仅是国际银行家了，那些国家也在支持着他们，中国的经济正在使他们恐惧！</p>

<p>这是一场不可避免的战争，而我们要做的是从中学到相应的措施避免造成重大的损失。如果你认为自己不是那些精英中的一员的话，就支持国家的各项措施。我敢保证此书的意图绝对是避免让大部分的人免于贫穷！</p>

<br></br>


<p>书于7#527宿舍，2008年7月12日22时16分</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中国的股市需要你们]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/zhong-guo-de-gu-shi-xu-yao-ni-men/"/>
    <updated>2013-08-03T14:23:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/zhong-guo-de-gu-shi-xu-yao-ni-men</id>
    <content type="html"><![CDATA[<p><img src="http://img.zjol.com.cn/pic/0/02/41/28/2412894_998960.jpg"></p>

<p>如果你认为炒股是不对的话，那将是一个极大的错误。你们肯定是会反对我的，理由很简单：炒股会影响到学习，我们没有资金，炒股需要学习相关的很多知识&hellip;但我认为你们的理由只对了一部分，不是全部。</p>

<!--more-->


<p>炒股会影响到学习，我也同意。没有一个人不会不在乎自己的投入，于是我们就更在乎股市每一天的涨跌了。但那只是短线投资者的烦恼，如果我们是一个长线投资者就不会在乎每天的涨跌，或者是每个月的涨跌，我们更关心的是未来的发展潜力。作为一个长线投资者，我们在选股的时候是投资未来，并不是短期的利益，在作出了一个好的投资之后我们没有太多的理由去关心它，等待的只是收益。而这所需要的时间只是分析它的时间，此后需要的还有什么呢？有些人选的股票很好，可是没有关注技术面，在一个错误的时候介入。作为一个大学生，我们真的不能把大把的时间花在学习以外的事情上，但选择作一个长线投资者我们可以很好的避免这一事件。</p>

<p>我们没有资金，这点我很不同意。我们花很多的money在衣服、娱乐、烟酒等等上，却为何不能把它们省下来呢？而有些东西我们是根本没有必要拥有它的，难道不是吗？或许你曾经在某个时刻为自己的冲动而后悔！当然我也不是鼓励，用自己的生活费去炒股，那肯定是得不偿失的，那样做绝对是愚蠢的。进入股市之后，你会更加懂得赚钱的艰辛，涨一分都是那么的不容易。当然你会在股海中亏钱，可是在这个过程中你积累了经验（无论你在其中混得咋样，都是一个很好的学习），你要明白21世纪的青年是要学会理财的！</p>

<p>炒股需要学习相关的很多知识，这我非常的同意。很多人的借口是我们没有老师的指导，并不知道要学习哪些相关的知识，还要学习专业课，时间少&hellip;这一切都是不合理的理由，我们有一个很好的优势：我们有一个庞大的数据库——图书馆，里面的一切都是免费赠送的（要不要真的是由你了），那些管理学院的老师还没有得到你的足够重视，白日的大美梦是否可以开始结束，游戏的位置是否可以让它动摇，我们有一个丰富的网络资源（你不喜欢google，就用百度吧，你想要的都有，并不是说你不知道百度或google，只是想告诉你——你要的知识你很容易搞到手）。</p>

<p>只要你炒了股，你真的会发现你知道了更多，成熟了不少。不管国际的还是国内的经济动态都会引发你的思考，小小的政策都会引发你对未来经济的猜想。就像我自己说过的一句话一样：我从来没有因为石油的高涨而如此恐慌过！</p>

<p>最近中国的股市受到了越南的影响，下跌了不少，当然在此之前已经下跌了很多，可是中国的基本面还是很好的。中国股市出现这种状况，更多的是有人在做空股市，只是我们太幼稚没有发现其中的巨大阴谋。股市跌到了很低的点了，有人会说要跌到2500点，可我认为跌到两千点都不可怕，买进绝对是个正确的选择，未来的盈利绝对是丰厚的，低廉的股价远远低于了公司的价值了。有人建议政府现在抄自己的底，我也同意，中国的股民被弄怕了都不敢再投入了，可这时候外资在窥探着，如果被他们抄底了，后果不堪设想，等他们撤走的时候又是一场股灾，中国股民再次被套。</p>

<p>中国有一亿多的股民，现在更多的是持现金观望，等待好的行情，可是等他们所谓的好行情来的时候就是被套的时候了。确实，中国现在步入的是一个熊市，可是谁说熊市是赚不到钱的？</p>

<p>加入到股民的行列中来吧，为中国政府出一份力，中国政府出台的一系列措施，更多的是在对付外资，怎们能让肥水流外人田呢！</p>

<p>进入股市，作为新手的你赔钱是不可避免的，但也有例外了。尽管那样，可赔的是小钱，却赢得了人生更大的资本。你的世界观也将得到改变，你的财富也在无形之中增长着，你会发现这个变化的。</p>

<br></br>


<p>书于7#527宿舍，2008年6月18日14时52分</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静悄悄的危机正在侵袭中国]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/jing-qiao-qiao-de-wei-ji-zheng-zai-qin-xi-zhong-guo/"/>
    <updated>2013-08-03T14:00:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/jing-qiao-qiao-de-wei-ji-zheng-zai-qin-xi-zhong-guo</id>
    <content type="html"><![CDATA[<p><img src="http://a3.att.hudong.com/74/68/01300000238080122631688199226.jpg"></p>

<p>作为一个发展迅速的大国，一直是美国打击的对象，它不容得任何的新势力动摇它的霸权地位。80年代的广场协议迫使日本货币升值，还有97年的东南亚金融危机，无不跟美国有关系。</p>

<!--more-->


<p>80年代的日本经济发展迅速，GDP超越了美国的一半以上，在未来的几年内大家都看好日本的经济，都认为会在几年内超越美国。而事实就是那样，日本确实很有实力，可是美国这时候不同意，凭借着自己的霸气，迫使日本签订了广场协议，从此日本的经济痛苦了十年，而恰恰这十年又是美国复苏的十年，又一个辉煌的十年。美国从日本人的手中收回了大量的财富，而这都是日本人辛苦聚集的，通用公司在一买一卖前后两个过程中赚了四亿，而投资大亨在宣布签订协议的一个晚上的时间就赚了四千万美圆，滚滚财富都流入了美国。</p>

<p>苏联解体了，美国没有了对手，这下是收拾他们的时候了，美国深知养虎为患的道理。当年的亚洲四小龙是为了抵抗苏联和中国这两个强大的社会主义经济体，强力扶植这四个地方（注意我这里用的并不是国家两个字，香港和台湾都是中国的，它们只属于地方）。我个人并不认为索罗斯以及那些投资军团有那么强大的实力能够击垮东南亚的经济体，他们的背后肯定有一个强大的主子，那就是美帝国主义！没有美国的默许以及暗地里的支持，他们能够支撑到那么久，能够和众多的国家对抗。</p>

<p>亚洲四小龙倒下了，美国高枕无忧了几年，可是中国却在不断的崛起，成了一个比苏联还要强大的对手，在各个领域与美国争夺，这还得了，是该时候收拾收拾了，要将它扼杀在萌芽阶段。贸易壁垒，支持台独（虽然没有口头上说支持，可是对台出售武器，可恶的航母在太平洋上耀武扬威，这比没有说做得还过分，加上不断的联合演习，不是对中国才是怪事呢），次贷危机转嫁给中国（次贷的债务抛给了中国，据说中国为此支付了比汶川地震的损失还要多的金钱），迫使人民币升值有一次吸取了中国人民辛苦创造的财富，等等。</p>

<p>最近越南出现了股市和楼市危机，金融界出现了一片慌乱，还好对中国的影响暂时不是很大。可是原本就低迷的中国股市在这一波中还是有不小的影响的，都调整了几个月，依旧徘徊在3300点左右，还在不断的探底，国际的投机者还在不断地向中国输送大量的资金，致使中国的印钞机在不断的工作，制造了大量的人民币，这又加剧了中国的通胀压力。人民币太多了！！！</p>

<p>今天到超市买东西，物价又一次的上涨了，都说人民币升值了，可是并不是这样子，只是美圆在一直的贬值。一旦大量的外资从中国撤离，人民币就会迅速的贬值，留给中国政府的只是如何去处理通胀这个后事。危机又一次来到了东南亚，而这些投资家为何要青睐东南亚而不选择发达的欧盟，原因大概是我们的体系太脆弱，比较容易击垮，进而从中获取高额的利润。越南的民众现在是一片恐慌，都忙着拿越南盾兑换美圆或者是黄金，政府已经对整个体系失去了控制，只能求助于国际货币组织，这时美国作为一个大国又会跑出来做一个好人，又从中敲诈。中国的股市，楼市又一次面临着一个巨大的挑战。</p>

<p>97年的金融危机，中国从中走出来了，当那时候也是遍体鳞伤，花了多年的时间才得到了恢复。这一次，在中国面临那么多的挑战之后，又会怎么样呢，希望中国的民众加油，战胜这次金融危机。尽管我们有大量的外汇储备，可是那并不是我们不用当心危机不会侵袭中国的理由。居安思危，这是古人的告诫！</p>

<p>静悄悄的危机，正在侵袭中国，你我都准备好了吗？在这个关键的时刻，我们要遵从政府，听从政府的安排，不要错误的认为政府是在害我们，我们不应该有太多的抱怨。政府也是在和那些想破环中国经济体的恶势力在作战，我们袖手旁观可以，但是我们不能给政府添乱。</p>

<br></br>


<p>书于7#527宿舍，2008年6月8日23时55分</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩大内需对当前的中国非常有必要]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/kuo-da-nei-xu-dui-dang-qian-de-zhong-guo-fei-chang-you-bi-yao/"/>
    <updated>2013-08-03T13:37:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/kuo-da-nei-xu-dui-dang-qian-de-zhong-guo-fei-chang-you-bi-yao</id>
    <content type="html"><![CDATA[<p><img src="http://i3.cnfolimg.com/money/2_1060062.jpg"></p>

<p>中国当前的消费模式：赚钱，存钱，有了足够的钱之后就是买房，买了房后口袋里的钱几乎就剩下不多了，接下来的问题就要考虑养老问题了，这时候已经到了一定的年龄阶段，过去的激情已经不再存在，一生所赚的钱几乎大部分都花在了这两个方面，其它的消费就是在生活必需品上了，剩下的消费少得可怜！</p>

<!--more-->


<p>对于中国这样的一个大国，这是完全不合理的，这严重阻碍了其它产业的发展。买房，养老，看似就是中国人从开始到结束的最终目标，所谓的生活已经不是生活而是一种负担。买房，养老，这两个问题没有得到良好的解决，居民就不敢大胆的消费，企业生产的产品就处于滞销的境地。然而，企业为了更好的生存只能靠出口。出口当然也需要很大的成本，在本国不能创造利润只能这样做了。而一方面政府为了在初期能够更好的发展经济，也鼓励出口，进而对企业进行出口退税，这在很大程度上伤害了中国的经济，尽管在短期上取得了利益。卖到国际上的中国商品很低廉，留给自己的当然也就很少了。</p>

<p>现在很庆幸，中国政府已经取消了很大一部分商品的出口退税，也就是说企业想要出口的话就需要加大成本。有人会说，这样的话，我们的企业在国际上是否会失去竞争力，然而恰恰相反，反而会提高。这样企业就更注重于产品质量的提高以及服务。要知道没有了依靠，它的发展更多的是靠自己，考虑的更多。另一方面，既然外在的市场需要更多的成本，那么就会更加的注重中国本国的市场。</p>

<p>要打开中国的市场还是个问题，就是以上的两个问题是关键。如果政府能够在未来几年内很好的解决这两个问题的话，中国的经济增长在很大程度上就不会那么强烈的依赖于外国的市场，企业的生产成本也会更低，职工就能得到更好的保障。</p>

<p>有数据显示，只要中国的房价下降百分之五十的话，中国的很多居民就不会为买房而担忧，就会有更多的金钱用于其它方面的消费，从而提升了我国的相关产业的发展。中国太依靠国际市场是一个很不好的现象，虽然现在是一个平坦的世界，但作为一个大国，我们要有应对突发事件的能力，更好的依靠自己。战争的可能性在这个世纪依然是存在的，真的发生了，我们就没有丝毫惧怕的理由了，我们的经济依然会很好的快速增长，因为内需在强大的支撑着。</p>

<p>有一件令人寒心的是就是在沃尔玛的货架上可以买到3美元的名牌鞋子，而在中国只能买到很贵并且有可能是假冒的鞋子，中国人看到了能不寒心吗？而这一切又是谁的错呢?我认为最关键的问题就是房子和养老的问题。这样说又有什么理由呢？中国人不能消费，所赚的钱要用到以上两个问题上，所以只有小部分的钱拿出来。企业是要生存的，如果把货物卖给中国的销售商的话，他们很难办到能够将商品销售出去，这些需要很长的一个周期，回收成本也就是一个漫长的过程，中国人不会冒险的去消费啊；但换作将商品出售给一个外国的销售商的话，尽管收到的利润很少，但是能够迅速的回收成本，进而企业可以再生产，企业得到了延续。作为一个企业家，你我都会选择后者的，即便你是那么的爱国，可是&hellip;</p>

<p>希望在未来的几年内，中国政府能够更好地解决买房与养老问题，一旦中国的内需扩大，中国才是真真的崛起!</p>

<br></br>


<p>书于7#527宿舍，2008年6月6日23时43分</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[log10的实现]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/log10de-shi-xian/"/>
    <updated>2013-08-03T01:46:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/log10de-shi-xian</id>
    <content type="html"><![CDATA[<p>在项目中要使用到log10计算，可所用系统的标准库里并没有移植该功能，需要自己实现。请问，采用什么算法实现该功能？</p>

<p>在网上找了一个例子，但不确定能否在嵌入式的一些平台使用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>double my_log10(double x)
</span><span class='line'>{
</span><span class='line'>    register double ret;
</span><span class='line'>
</span><span class='line'>       __asm__(
</span><span class='line'>  "fldlg2\n\t" 
</span><span class='line'>  "fxch\n\t" 
</span><span class='line'>  "fyl2x"
</span><span class='line'>  :"=t"(ret)
</span><span class='line'>          :"0"(x)
</span><span class='line'>      );
</span><span class='line'>   return ret;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>也查看了glibc的源码，可调用了其它的一些API，对库的依赖比较大，逐步移植的话比较麻烦。代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>double __log10 (double x)
</span><span class='line'>{
</span><span class='line'>    if (__builtin_expect (islessequal (x, 0.0), 0) && _LIB_VERSION != _IEEE_)
</span><span class='line'>    {
</span><span class='line'>        if (x == 0.0)
</span><span class='line'>        {
</span><span class='line'>             feraiseexcept (FE_DIVBYZERO);
</span><span class='line'>             return __kernel_standard (x, x, 18); /* log10(0) */
</span><span class='line'>        }
</span><span class='line'>        else
</span><span class='line'>        {
</span><span class='line'>            feraiseexcept (FE_INVALID);
</span><span class='line'>            return __kernel_standard (x, x, 19); /* log10(x&lt;0) */
</span><span class='line'>        }
</span><span class='line'>     }
</span><span class='line'>
</span><span class='line'>   return  __ieee754_log10 (x);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>参考 <a href="http://www.cnblogs.com/skyivben/archive/2013/02/15/2912914.html">这里</a> 实现了一个c语言版本的log10快速算法，还不是很完善。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;math.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>static double Sqrt(double x)
</span><span class='line'>{
</span><span class='line'>    if (x &lt; 0)
</span><span class='line'>        return -1;
</span><span class='line'>    if (x == 0)
</span><span class='line'>        return 0;
</span><span class='line'>    double y = (double)sqrt((double)x);
</span><span class='line'>
</span><span class='line'>    return (y + x / y) / 2;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static double NegativeLog(double q)
</span><span class='line'>{                           
</span><span class='line'>    int p;
</span><span class='line'>    double pi2 = 6.283185307179586476925286766559;
</span><span class='line'>    double eps2 = 0.00000000000001; // 1e-14
</span><span class='line'>    double eps1;    // 1e-28
</span><span class='line'>    double r = q, s = q, n = q, q2 = q * q, q1 = q2 * q;
</span><span class='line'>
</span><span class='line'>    eps1 = eps2 * eps2;
</span><span class='line'>
</span><span class='line'>    for (p = 1; (n *= q1) &gt; eps1; s += n, q1 *= q2)
</span><span class='line'>        r += (p = !p) ? n : -n;
</span><span class='line'>
</span><span class='line'>    double u = 1 - 2 * r, v = 1 + 2 * s, t = u / v;
</span><span class='line'>    double a = 1, b = Sqrt(1 - t * t * t * t);
</span><span class='line'>
</span><span class='line'>    for (; a - b &gt; eps2; b = Sqrt(a * b), a = t)
</span><span class='line'>        t = (a + b) / 2;
</span><span class='line'>
</span><span class='line'>    return pi2 / (a + b) / v / v;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static double Log(double x)
</span><span class='line'>{
</span><span class='line'>    int k = 0;
</span><span class='line'>    double ln10 = 2.30258509299404568401799145468;
</span><span class='line'>
</span><span class='line'>    if (x &lt;= 0)
</span><span class='line'>        return -1;
</span><span class='line'>    if (x == 1)
</span><span class='line'>        return 0;
</span><span class='line'>
</span><span class='line'>    for (; x &gt; 0.1; k++)
</span><span class='line'>        x /= 10;
</span><span class='line'>    for (; x &lt;= 0.01; k--)
</span><span class='line'>        x *= 10;
</span><span class='line'>
</span><span class='line'>    return k * ln10 - NegativeLog(x);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>double Log10(double x)
</span><span class='line'>{
</span><span class='line'>    double ln10 = 2.30258509299404568401799145468;
</span><span class='line'>
</span><span class='line'>    return Log(x) / ln10;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>    printf(" self Log10: %f\n math log10: %f\n\n", Log10(1000), log10(1000));
</span><span class='line'>    printf(" self Log10: %f\n math log10: %f\n\n", Log10(1), log10(1));
</span><span class='line'>    printf(" self Log10: %f\n math log10: %f\n\n", Log10(8192.1024), log10(8192.1024));
</span><span class='line'>    printf(" self Log10: %f\n math log10: %f\n\n", Log10(0.3), log10(0.3));
</span><span class='line'>    printf(" self Log10: %f\n math log10: %f\n\n", Log10(33.8), log10(33.8));
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kfifo.c中in和out的溢出问题]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/03/kfifo-dot-czhong-inhe-outde-yi-chu-wen-ti/"/>
    <updated>2013-08-03T01:08:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/03/kfifo-dot-czhong-inhe-outde-yi-chu-wen-ti</id>
    <content type="html"><![CDATA[<p>先上内核循环缓冲结构体的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct kfifo {
</span><span class='line'>    unsigned char *buffer;        /* the buffer holding the data */
</span><span class='line'>    unsigned int size;        /* the size of the allocated buffer */
</span><span class='line'>    unsigned int in;        /* data is added at offset (in % size) */
</span><span class='line'>    unsigned int out;        /* data is extracted from off. (out % size) */
</span><span class='line'>    spinlock_t *lock;        /* protects concurrent modifications */
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>如果对“Linux内核中的循环缓冲区”不是很了解的话，可以先参考 <a href="http://www.kerneltravel.net/jiaoliu/kern-kfifo.html">这里</a> 。内核中有关kfifo.c和kfifo.h两个文件的源码以及该问题的具体情况，可以查看 <a href="http://bbs.chinaunix.net/thread-4088139-1-1.html">这里</a> 。</p>

<!--more-->


<p>对于结构体内的in和out两个变量，内核是作如下处理的:1、在读入数据时增加in；2、在取出数据时增加out；3、当检测到两个相等的时候将它们复位归0。1和2不作讨论和分析，针对第3点的处理，内核代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline unsigned int kfifo_get(struct kfifo *fifo,
</span><span class='line'>                                     unsigned char *buffer, unsigned int len)
</span><span class='line'>{
</span><span class='line'>    unsigned long flags;
</span><span class='line'>    unsigned int ret;
</span><span class='line'>
</span><span class='line'>    spin_lock_irqsave(fifo-&gt;lock, flags);
</span><span class='line'>    ret = __kfifo_get(fifo, buffer, len);
</span><span class='line'>
</span><span class='line'>    /*
</span><span class='line'>     * optimization: if the FIFO is empty, set the indices to 0
</span><span class='line'>     * so we don't wrap the next time
</span><span class='line'>     */
</span><span class='line'>    if (fifo-&gt;in == fifo-&gt;out)
</span><span class='line'>        fifo-&gt;in = fifo-&gt;out = 0;
</span><span class='line'>
</span><span class='line'>    spin_unlock_irqrestore(fifo-&gt;lock, flags);
</span><span class='line'>
</span><span class='line'>    return ret;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>问题：当数据写入速度大于读取速度的时候，in和out的值将永远不会相等，也就是说buffer永远是有数据的，这样的话in和out都存在超出自身数值表示范围，从而导致错误？</p>

<p>针对这个问题，不知大家有什么好的建议？</p>

<h2>网友felix021的回复</h2>

<p>之前看错了你的问题。</p>

<p>从源码的实现上来说，in和out的确是有可能会出现溢出，但是出现的情况非常极端：每次读取数据的时候都比当前缓冲区中的数据还少、而且这种情况持续直到写入的数据超过4GB。通常应该是不会遇到的；鉴于墨菲定律可能带来的恶果，的确还是得考虑一下。</p>

<p>不过可以再想想，溢出了就真的会导致程序出错吗？</p>

<p>回头再仔细看看 __kfifo_put()里面的代码，在写入的时候是这样实现的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* first put the data starting from fifo-&gt;in to buffer end */
</span><span class='line'>l = min(len, fifo-&gt;size - (fifo-&gt;in & (fifo-&gt;size - 1)));
</span><span class='line'>memcpy(fifo-&gt;buffer + (fifo-&gt;in & (fifo-&gt;size - 1)), buffer, l);</span></code></pre></td></tr></table></div></figure>


<p>注意<code>(fifo-&gt;in &amp; (fifo-&gt;size - 1)</code>这里用了<code>&amp;</code>符号，而不是直接<code>%fifo-&gt;size</code>，也就是说，初始化的时候size必然得设置成2的n次方（这个限制在内核里很合理，因为内核分配的空间通常是2的倍数，比如一个page）。</p>

<p>在像x86这种溢出跟取模操作等价的处理器上，对于当前的写入操作实际上“正好”没有风险。同样的，由于in/out都是 unsigned int，在后续的 kfifo_get/kfifo_len 里面<code>in - out</code>(比如说<code>2 - 4294967295</code>，你可以试试)，结果仍然“正好”是正确的。</p>

<p>结论就是，它居然真的没有风险（前提是在溢出、无符号整数减法操作与x86处理器类似的CPU上）。</p>

<p>不得不说，内核源码的开发者真吝啬啊，多写一个赋值操作都不舍得。</p>

<h2>参考文章</h2>

<p><a href="http://segmentfault.com/q/1010000000249362">内核kfifo.c中in和out的问题</a> <br/>
<a href="http://bbs.chinaunix.net/thread-4088139-1-1.html">内核中kfifo.c相关的问题</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux管道的实现机制]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/02/linuxguan-dao-de-shi-xian-ji-zhi/"/>
    <updated>2013-08-02T00:24:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/02/linuxguan-dao-de-shi-xian-ji-zhi</id>
    <content type="html"><![CDATA[<p>在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现为：</p>

<ul>
<li><p>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不像文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。</p></li>
<li><p>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</p></li>
</ul>


<p>注意：从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。</p>

<!--more-->


<h1>管道的结构</h1>

<p>在Linux中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个file结构指向同一个临时的VFS索引节点，而这个VFS索引节点又指向一个物理页面而实现的。如下图所示。</p>

<p><img src="http://txgcwm.github.io/images/2013/8/pipe/struct.png" alt=" struct " /></p>

<p>图中有两个file数据结构，但它们定义文件操作例程地址是不同的，其中一个是向管道中写入数据的例程地址，而另一个是从管道中读出数据的例程地址。这样，用户程序的系统调用仍然是通常的文件操作，而内核却利用这种抽象机制实现了管道这一特殊操作。</p>

<h1>管道的读写</h1>

<p>管道实现的源代码在fs/pipe.c中，在pipe.c中有很多函数，其中有两个函数比较重要，即管道读函数pipe_read()和管道写函数pipe_wrtie()。管道写函数通过将字节复制到VFS索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，内核必须利用一定的机制同步对管道的访问，为此，内核使用了锁、等待队列和信号。</p>

<p>当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的file结构。file结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查VFS索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p>

<ul>
<li>内存中有足够的空间可容纳所有要写入的数据；</li>
<li>内存没有被读程序锁定。</li>
</ul>


<p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在VFS索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p>

<p>管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。</p>

<h1>CU上的问题</h1>

<h2>popkart718的提问</h2>

<p>《Unix环境高级编程》403页中部分描述如下：</p>

<p><img src="http://txgcwm.github.io/images/2013/8/pipe/sync.jpg" alt=" sync " /></p>

<p>明明是两个管道，为什么read的时候会发生阻塞呢？</p>

<h2>解答</h2>

<p>read依赖于管道的打开模式，打开管道时可使用pipe2设定相应的flags。书上所写的阻塞是在管道中没有数据的情况下发生的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   int pipe2(int pipefd[2], int flags);
</span><span class='line'>
</span><span class='line'>DESCRIPTION
</span><span class='line'>   pipe()  creates  a  pipe, a unidirectional data channel that can be used for interprocess communication.  The array pipefd is used to return
</span><span class='line'>   two file descriptors referring to the ends of the pipe.  pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of
</span><span class='line'>   the  pipe.  Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe.  For further
</span><span class='line'>   details, see pipe(7).
</span><span class='line'>
</span><span class='line'>   If flags is 0, then pipe2() is the same as pipe().  The following values can be bitwise ORed in flags to obtain different behavior:
</span><span class='line'>
</span><span class='line'>   O_NONBLOCK  Set the O_NONBLOCK file status flag on the two new open file descriptions.  Using this flag saves extra  calls  to  fcntl(2)  to
</span><span class='line'>               achieve the same result.
</span><span class='line'>
</span><span class='line'>   O_CLOEXEC   Set  the  close-on-exec  (FD_CLOEXEC) flag on the two new file descriptors.  See the description of the same flag in open(2) for
</span><span class='line'>               reasons why this may be useful.</span></code></pre></td></tr></table></div></figure>


<p>同时也可以查看内核文件fs/pipe.c中的pipe_read函数实现。以下是简单的测试程序。</p>

<p>测试一：使用pipe2且传入参数的flags为0（相当于使用pipe）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int fd[2];
</span><span class='line'>
</span><span class='line'>void handle(int sig)
</span><span class='line'>{
</span><span class='line'>  if (sig == SIGUSR1)
</span><span class='line'>      write(fd[1], "p", 1);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  char c;
</span><span class='line'>  pid_t pid;
</span><span class='line'>
</span><span class='line'>  if (pipe2(fd, 0) &lt; 0) {
</span><span class='line'>      printf("can not creat pipe!\n");
</span><span class='line'>      return -1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if ((pid = fork()) &lt; 0) {
</span><span class='line'>      printf("can not fork!\n");
</span><span class='line'>      return -1;
</span><span class='line'>  } else if (pid &gt; 0) {
</span><span class='line'>      close(fd[0]);
</span><span class='line'>      signal(SIGUSR1, handle);
</span><span class='line'>      for (;;) {
</span><span class='line'>      }
</span><span class='line'>  } else {
</span><span class='line'>      close(fd[1]);
</span><span class='line'>      for (;;) {
</span><span class='line'>          if (read(fd[0], &c, 1) == 1)
</span><span class='line'>              printf("c:%c\n", c);
</span><span class='line'>          else
</span><span class='line'>              printf("nothing to read!\n");
</span><span class='line'>
</span><span class='line'>          sleep(2);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译后，可以看到程序阻塞在那里，当使用“kill -10 进程号”时，才会从管道中读出数据。</p>

<p>测试二：使用pipe2时设置flags的参数为O_NONBLOCK</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/types.h&gt;
</span><span class='line'>#include &lt;sys/stat.h&gt;
</span><span class='line'>#include &lt;fcntl.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int fd[2];
</span><span class='line'>
</span><span class='line'>void handle(int sig)
</span><span class='line'>{
</span><span class='line'>  if (sig == SIGUSR1)
</span><span class='line'>      write(fd[1], "p", 1);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  char c;
</span><span class='line'>  pid_t pid;
</span><span class='line'>
</span><span class='line'>  if (pipe2(fd, O_NONBLOCK) &lt; 0) {
</span><span class='line'>      printf("can not creat pipe!\n");
</span><span class='line'>      return -1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if ((pid = fork()) &lt; 0) {
</span><span class='line'>      printf("can not fork!\n");
</span><span class='line'>      return -1;
</span><span class='line'>  } else if (pid &gt; 0) {
</span><span class='line'>      close(fd[0]);
</span><span class='line'>      signal(SIGUSR1, handle);
</span><span class='line'>      for (;;) {
</span><span class='line'>      }
</span><span class='line'>  } else {
</span><span class='line'>      close(fd[1]);
</span><span class='line'>      for (;;) {
</span><span class='line'>          if (read(fd[0], &c, 1) == 1)
</span><span class='line'>              printf("c:%c\n", c);
</span><span class='line'>          else
</span><span class='line'>              printf("nothing to read!\n");
</span><span class='line'>
</span><span class='line'>          sleep(2);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译后，执行程序可以看到它不停的打印消息，若管道内没有数据的话，read就直接返回了。</p>

<h1>参考文章</h1>

<p><a href="http://oss.org.cn/kernel-book/ch07/7.1.1.htm">Linux管道的实现机制</a> <br/>
<a href="http://bbs.chinaunix.net/thread-4069374-1-1.html">进程通信管道问题</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关注你的是谁]]></title>
    <link href="http://txgcwm.github.io/blog/2013/08/01/guan-zhu-ni-de-shi-shui/"/>
    <updated>2013-08-01T22:46:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/08/01/guan-zhu-ni-de-shi-shui</id>
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/7834999djw1dorelc6br4j.jpg"></p>

<p>仔细看了看自己的QQ好友，总数将近300多人，可实际会去交谈的大约50人以内。我们彼此生活在自己的小圈子里，即便开始了一段交谈，双方都会担心彼此之间的话题噶然而止，以致陷入尴尬的境地，所以我们索性不开始一段交流。</p>

<!--more-->


<p>QQ群是一个很好的东西，当我们想说的时候就在上面吼上一句，不想说的时候就默默地在旁观望，不会有“对面还有个人在等我的回话呢？我是否应该说点其它什么东西”的尴尬。同样，微信也有这么个优点。</p>

<p>即便我们经常交流的好友只有那么几个，但其他的好友依然需要他们静静的躺在我们的列表中，以防某一天我们会需要对方的帮助、咨询、交流。</p>

<p>每个人的好友圈里大体有这么几类人：同学、同事、朋友、客户以及网络上结交的网友。其中以前三类人居多，后两者相对较少。我们有那么多的好友，为何经常交流的朋友只有那么几个？可能跟工作环境和从事领域、个人性格和处事风格、生活背景、地域环境等等因素有关。</p>

<p>除了同事和客户外，其他人或许我们只是偶尔交流，但即便如此，我们也会被很多朋友默默的关注着。这里不讨论男女之间因爱慕或者是亲情而关注的话题，主要说的是普通朋友之间的那种关注。关注你的人大体有以下几类：对你发表的话题感兴趣的人、欣赏你的人、工作环境的同事、交心的朋友。</p>

<h1>对你发表的话题感兴趣的人</h1>

<p>当你发表了一个很有意思的话题，勾起了人们的好奇心，这时他们就会来看看。而如果你没有什么特别能够吸引他们的东西的时候，他们往往不会关注你。他们看重的是事情，更多的会去思考“这是什么样的事情？多有意思，要是能够多点什么就更好了”。</p>

<h1>欣赏你的人</h1>

<p>与前者不同，他们更看重的是你这个人——欣赏你的人格和你的思想，无论你发表什么样的说说或者文章他们都会来看看。他们更多的思考“你为什么会写下这些东西，想表达的是什么，为什么他想的跟我的想法都一样”，但他们往往不给你任何的评论，生怕自己所说的不合适而失去他们在你脑海中的映像。虽然他们平时也很少甚至是不跟你交流、交谈，当某一天他们的心里有千万头“草泥马”在奔腾、头脑中的“火花”在哧哧作响的时候，他们会找上你，和你大谈特谈。而你也发现他们身上的特质和你有共同点的时候，你们会进一步发展，成为交心的朋友。</p>

<h1>工作环境的同事</h1>

<p>这些人是很特殊的群体，起初他们关注你并不是因为你的话题和人本身，而是想通过一些事情和话语更加的了解你，进而增进彼此之间的认识，便于以后的交流。他们在适当的时候，也会和你讨论一些话题，分享一些观点和建议。时间久了，随着对你了解地更加深入，会慢慢地开始欣赏你，最后成为交心的朋友。他们有一个更大的优势，他们平时和你一起工作，更容易从实际工作中去了解你、认识你。</p>

<h1>交心的朋友</h1>

<p>他们不仅对你的话题感兴趣，对你本身更加感兴趣。当你述说某件事情或话题的时候，他们会加入到你的讨论中，发表他们的观点，同时也给出他们认为正确的意见。而这一类人往往也是你关注的对象，你们彼此欣赏着对方。</p>

<h1>我们的财富</h1>

<p>2012年的时候，美国企业状告新东方账目作假，致使新东方的股票大跌。中国企业家联合会的各位大佬询问“老俞，你实话实说，你们到底有没有做过亏心事。如果你说‘做过’，那以后你的事我们就不管了。如果你说‘没做过’，那我们会把新东方救回来。我们不要什么解释，只要你的一句话”。俞敏洪回道“我们没有做过”。第二天，几亿美金入场，买入了大量的新东方股票，将新东方从死亡的边缘救了回来。</p>

<p>朋友之间不需要任何的解释，他们始终理解你，知道你为什么那么做。而需要你给出解释的人，即便你是用事实在说话，他们也始终不相信你。珍惜那些关注我们的人，他们同样是我们人生的财富。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聊聊测试]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/31/liao-liao-ce-shi/"/>
    <updated>2013-07-31T23:26:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/31/liao-liao-ce-shi</id>
    <content type="html"><![CDATA[<p><img src="http://www.51testing.com/zhuanti/img/csvskf_02.gif"></p>

<p>从工作到现在，一直有较长时间跟测试方面的人员交流，所以也顺道聊聊测试的话题。有一部分人只把测试看作是试用用户，并不认为她们在整个过程中能够起到多大的作用，而忽略了她们的巨大价值。一件产品只有通过测试的点头之后才能够走向市场，否则即便上市了每个人的心里都会胆寒，说不定在某个时刻就爆发了问题。测试不仅仅是高级的试用用户，更是一个开发师、设计师和分析师。</p>

<!--more-->


<p>在第一家设备公司的时候，经常去复现测试人员提交的bug，但总是测试不出来，于是就去找她们复现这些问题。当找到她们的时候，她们总能又一次把问题复现。我真的不了解那些测试人员是什么样的思维，很多bug能够被她们用奇特的方法测试出来。很多开发人员总是跑过去跟测试人员讲“你不能这么测试，你应该这么测试”，一般测试人员辩驳几句后会选择沉默。但她们还是坚持着自己的观点，然后把提交的测试问题重新返还给开发人员，只要开发人员不解决她们就不会把问题关闭，跟你死耗着，看你怎么办。由于跟测试人员待在一起时间长了，很了解她们的实力，所以我一般都不会自信的说“这个肯定没有问题，怎么可能出现这样的bug”。如果我真的那么自信的说话，当她们重新复现到问题的时候，我是否会无地自容呢？长久下来，当她们复现出问题的时候，她们都会很和蔼的说“没事，慢慢修复吧。如果复现不了，再来找我，我再帮你复现”。每次的交流都是心平气和，不会有不愉快的冲突。</p>

<p>到了第二家公司的时候，遇到了一个更好的测试人员。她不仅能够清楚的描述问题，还能够附带她的分析，对解决问题起到了很大的帮助。她经常会问我设备内软件的设计架构和原理，我也非常乐意告诉她这些东西。一旦她了解了，就会帮助我分析问题，这样就加快了我解决bug的速度。以下的一段文字是她提交某一bug的描述：</p>

<blockquote><p>【测试版本】：Vxxx</p>

<p>【测试步骤】： <br/>
1、PC接入终端（PCB板已增加屏蔽罩），通过VLC观看频点xxxxxx的节目流畅。 <br/>
2、手机接入终端，启动android客户端但不观看电视节目，此时观察VLC节目中周期性出现水幕或跳跃问题。分析原因是android客户端启动后会向终端获取状态信息。 <br/>
3、操作手机客户端观看电视节目，VLC和手机客户端的节目均播放流畅，分析原因是手机客户端在观看视频时不会获取心跳信息。 <br/>
4、启动windows客户端但不观看电视节目，VLC和手机客户端的节目又周期性出现水幕或跳跃问题。分析原因是windows客户端启动后回获取心跳信息。 <br/>
5、windows客户端观看电视节目后，VLC和手机客户端的节目扔会周期性出现水幕或跳跃问题。原因是windows客户端在节目播放过程中仍会获取状态信息。</p>

<p>问题：客户端周期性获取终端状态会导致节目播放时出现水幕，心跳机制需优化。</p>

<p>【测试结论】：客户端周期性获取心跳包会影响节目播放效果</p></blockquote>

<p>写的很清楚，分析得很有道理。我根据她提供的描述信息去查看问题，检测到引发问题的原因与上述描述的一致。正因她详细地描述测试现象及相关的对比实验、细致的分析，我仅花了几分钟的时间就解决了这个问题。如果没有她所做的工作，我可能会从“视频流传输”方面去分析，这或许会花费几个小时甚至几天的时间去跟踪这个问题。</p>

<p>我曾问过一个朋友“你们公司的测试人员会如何去做”，他回道“在自己的设备上遇到问题后再在使用其它公司的设备作对比测试，然后将问题提交给开发人员”。如他所述，很多测试人员都会做基本的对比测试，却缺少了自己对问题的必要分析。</p>

<p>一个好的测试人员不仅能够发现问题，还能够帮你分析问题且提出解决问题的方案。开发人员很多时候不应该去左右她们，不应该去影响她们，不应该给她们一个框架，她们的思维需要的就是天马行空！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux的硬链接与软链接]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/29/linuxde-ying-lian-jie-yu-ruan-lian-jie/"/>
    <updated>2013-07-29T23:37:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/29/linuxde-ying-lian-jie-yu-ruan-lian-jie</id>
    <content type="html"><![CDATA[<p>文件有文件名与数据，这在Linux上被分成两个部分：用户数据(user data)与元数据(metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在Linux中，元数据中的inode号（inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过inode号寻找正确的文件数据块。下图展示了程序通过文件名获取文件内容的过程。</p>

<p><img src="http://txgcwm.github.io/images/2013/7/link/file.png" alt=" file " /></p>

<p>为解决文件的共享使用，Linux系统引入了两种链接：硬链接(hard link)与软链接（又称符号链接，即soft link或symbolic link）。链接为Linux系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名。</p>

<p><img src="http://txgcwm.github.io/images/2013/7/link/access.png" alt=" access " /></p>

<!--more-->


<h1>硬链接</h1>

<p>硬链接可由命令link或ln创建。如下是对文件oldfile创建硬链接。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>link oldfile newfile 
</span><span class='line'>ln oldfile newfile </span></code></pre></td></tr></table></div></figure>


<p>由于硬链接是有着相同inode号仅文件名不同的文件，因此硬链接存在以下几点特性：</p>

<ul>
<li>文件有相同的inode及data block；</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能交叉文件系统进行硬链接的创建；</li>
<li>不能对目录进行创建，只可对文件创建；</li>
<li>删除一个硬链接文件并不影响其它有相同inode号的文件。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -li
</span><span class='line'>total 0
</span><span class='line'>
</span><span class='line'>// 只能对已存在的文件创建硬连接
</span><span class='line'>$ link old.file hard.link
</span><span class='line'>link: cannot create link `hard.link' to `old.file': No such file or directory
</span><span class='line'>
</span><span class='line'>$ echo "This is an original file" &gt; old.file
</span><span class='line'>$ cat old.file
</span><span class='line'>This is an original file
</span><span class='line'>$ stat old.file
</span><span class='line'>  File: `old.file'
</span><span class='line'>  Size: 25            Blocks: 8          IO Block: 4096   regular file
</span><span class='line'>Device: 807h/2055d    Inode: 796901      Links: 1
</span><span class='line'>Access: (0664/-rw-rw-r--)  Uid: ( 1000/  txgcwm)   Gid: ( 1000/  txgcwm)
</span><span class='line'>Access: 2013-07-29 23:57:49.435157205 +0800
</span><span class='line'>Modify: 2013-07-29 23:57:27.295157688 +0800
</span><span class='line'>Change: 2013-07-29 23:57:27.295157688 +0800
</span><span class='line'> Birth: -
</span><span class='line'> 
</span><span class='line'>// 文件有相同的inode号以及data block
</span><span class='line'>$ link old.file hard.link | ls -li
</span><span class='line'>total 8
</span><span class='line'>796901 -rw-rw-r-- 2 txgcwm txgcwm 25 Jul 29 23:57 hard.link
</span><span class='line'>796901 -rw-rw-r-- 2 txgcwm txgcwm 25 Jul 29 23:57 old.file
</span><span class='line'>
</span><span class='line'>// 不能交叉文件系统
</span><span class='line'>$ sudo ln /dev/input/event5 /root/bfile.txt
</span><span class='line'>[sudo] password for txgcwm: 
</span><span class='line'>ln: failed to create hard link `/root/bfile.txt' =&gt; `/dev/input/event5': Invalid cross-device link
</span><span class='line'>
</span><span class='line'>// 不能对目录进行创建硬连接
</span><span class='line'>$ mkdir -p old.dir/test
</span><span class='line'>$ ln old.dir/ hardlink.dir
</span><span class='line'>ln: `old.dir/': hard link not allowed for directory</span></code></pre></td></tr></table></div></figure>


<p>文件old.file与hard.link有着相同的inode号（796901）及文件权限，inode是随着文件的存在而存在，因此只有当文件存在时才可创建硬链接，即当inode存在且链接计数器（link count）不为0时。inode号仅在各文件系统下是唯一的，当Linux挂载多个文件系统后将出现inode号重复的现象，因此硬链接创建时不可跨文件系统。设备文件目录/dev使用的文件系统是devtmpfs，而/home（与根目录/一致）使用的是磁盘文件系统ext4。以下使用命令df查看当前系统中挂载的文件系统类型、各文件系统inode使用情况及文件系统挂载点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo df -i --print-type
</span><span class='line'>Filesystem     Type      Inodes  IUsed   IFree IUse% Mounted on
</span><span class='line'>/dev/sda5      ext4     1250928  63404 1187524    6% /
</span><span class='line'>udev           devtmpfs  211313    603  210710    1% /dev
</span><span class='line'>tmpfs          tmpfs     215180    566  214614    1% /run
</span><span class='line'>none           tmpfs     215180      3  215177    1% /run/lock
</span><span class='line'>none           tmpfs     215180      9  215171    1% /run/shm
</span><span class='line'>none           tmpfs     215180     23  215157    1% /run/user
</span><span class='line'>/dev/sda6      ext4       62464    355   62109    1% /boot
</span><span class='line'>/dev/sda7      ext4     1250928  91579 1159349    8% /home
</span><span class='line'>/dev/sda11     ext4     2501856 336584 2165272   14% /srv
</span><span class='line'>/dev/sda12     ext4     1875968 144226 1731742    8% /opt
</span><span class='line'>/dev/sda8      ext4      249984    132  249852    1% /tmp
</span><span class='line'>/dev/sda9      ext4     1250928 584616  666312   47% /usr
</span><span class='line'>/dev/sda10     ext4      249984  24565  225419   10% /var
</span><span class='line'>
</span><span class='line'>$ sudo find / -inum 1114
</span><span class='line'>/lib/modules/3.5.0-25-generic/kernel/drivers/hwmon/mcp3021.ko
</span><span class='line'>/sys/devices/LNXSYSTM:00/device:00/PNP0A08:00/device:02/PNP0C02:00/power/autosuspend_delay_ms</span></code></pre></td></tr></table></div></figure>


<p>值得一提的是，Linux系统存在inode号被用完但磁盘空间还有剩余的情况。硬链接不能对目录创建是受限于文件系统的设计。现Linux文件系统中的目录均隐藏了两个特殊的目录：当前目录（.）与父目录（..）。查看这两个特殊目录的inode号可知其实这两目录就是两个硬链接（注意目录/lost+found/的inode号）。若系统允许对目录创建硬链接，则会产生目录环。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo ls -aliF /lost+found
</span><span class='line'>total 20
</span><span class='line'>11 drwx------  2 root root 16384 Nov 11  2012 ./
</span><span class='line'> 2 drwxr-xr-x 23 root root  4096 Jul  7 13:47 ../
</span><span class='line'> 
</span><span class='line'>$ sudo stat /lost+found/
</span><span class='line'>  File: `/lost+found/'
</span><span class='line'>  Size: 16384         Blocks: 32         IO Block: 4096   directory
</span><span class='line'>Device: 805h/2053d    Inode: 11          Links: 2
</span><span class='line'>Access: (0700/drwx------)  Uid: (    0/    root)   Gid: (    0/    root)
</span><span class='line'>Access: 2013-07-30 00:10:47.479140197 +0800
</span><span class='line'>Modify: 2012-11-11 00:50:27.000000000 +0800
</span><span class='line'>Change: 2012-11-11 00:50:27.000000000 +0800
</span><span class='line'> Birth: -</span></code></pre></td></tr></table></div></figure>


<h1>软链接</h1>

<p>软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的inode号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：</p>

<ul>
<li>软链接有自己的文件属性及权限等；</li>
<li>可对不存在的文件或目录创建软链接；</li>
<li>软链接可交叉文件系统；</li>
<li>软链接可对文件或目录创建；</li>
<li>创建软链接时，链接计数 i_nlink 不会增加；</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -li
</span><span class='line'>total 0
</span><span class='line'>
</span><span class='line'>// 可对不存在的文件创建软链接
</span><span class='line'>$ ln -s old.file soft.link
</span><span class='line'>$ ls -liF
</span><span class='line'>total 0
</span><span class='line'>796810 lrwxrwxrwx 1 txgcwm txgcwm 8 Jul 30 00:25 soft.link -&gt; old.file
</span><span class='line'>
</span><span class='line'>// 由于被指向的文件不存在，此时的软链接 soft.link 就是死链接
</span><span class='line'>$ cat soft.link
</span><span class='line'>cat: soft.link: No such file or directory
</span><span class='line'>
</span><span class='line'>// 创建被指向的文件 old.file，soft.link 恢复成正常的软链接
</span><span class='line'>$ echo "This is an original file_A" &gt;&gt; old.file
</span><span class='line'>$ cat soft.link
</span><span class='line'>This is an original file_A
</span><span class='line'>
</span><span class='line'>// 对不存在的目录创建软链接
</span><span class='line'>$ ln -s old.dir soft.link.dir
</span><span class='line'>$ mkdir -p old.dir/test
</span><span class='line'>$ tree . -F --inodes
</span><span class='line'>.
</span><span class='line'>├── [ 796834]  old.dir/
</span><span class='line'>│   └── [ 796851]  test/
</span><span class='line'>├── [ 796830]  old.file
</span><span class='line'>├── [ 796830]  soft.link -&gt; old.file
</span><span class='line'>└── [ 796834]  soft.link.dir -&gt; old.dir/
</span><span class='line'>
</span><span class='line'>3 directories, 2 files</span></code></pre></td></tr></table></div></figure>


<h1>参考文章</h1>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">理解Linux的硬链接与软链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于提建议]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/29/guan-yu-ti-jian-yi/"/>
    <updated>2013-07-29T20:20:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/29/guan-yu-ti-jian-yi</id>
    <content type="html"><![CDATA[<p><img src="http://www.beidou119.com/uploadfile/2013/0106/20130106093231928.jpg"></p>

<p>在一个公司里，我们是否应该提建议，又该如何去提？对于我来说是一个很难的问题，时常提一些建议却得不到对方的理解，甚至别人根本不屑听你讲的东西。慢慢地，也就没有了那个心情，让一切顺其发展。其实我也尝试着想让自己更好地去处理这件事情，也提了问题去询问网友，可得出的结果趋于一致性。以下是我在CU论坛上的提问，以及一些朋友的回复。</p>

<!--more-->


<blockquote><p>在公司里，员工间彼此讨论着公司的各个方面，却很少向上级主管提出。可能其中是有好的建议的，可始终没人提。尤其是对一些创业公司，我认为意见是很重要的。针对这一问题，各位朋友所在的公司又是如何对待员工提的意见，或者是如何鼓励员工提意见，又或者是各个员工针对该问题的态度是什么？</p>

<p>CTUOS: 。。。。看时候。。看领导吧。。提的多。。死的快。。。。。反正我现在就不说老。。。</p>

<p>forestiger: 遇到好领导提还行，不好的领导提不好死的快，所以一般不提。</p>

<p>action08: 关键还是看领导是否有愿意听的心态，，，不少企业领导为了表现自己是领导还是很专断的，甚至听到不同意见的人会打压，，文化文化。不少领导号称开明，我这里还是找到了案例，好话说说都好听；真正做得的高尚人还是难啊！</p>

<p>qinyiwang：感觉没有啥渠道，当面说？发邮件？</p></blockquote>

<p>从回复的结果看，大家都认为没有必要提，提了对自己还未必是好事。这样的一个结果，必然有其缘由。很多的领导表面上希望手下多提意见，表示“对事不对人”，可当员工真的提意见的时候就变成了“对人不对事”，说不定日后还有很多的小鞋子穿。一切只是形式而已，从来没有想过认真的执行一次。或许当面临巨大的危机才真正想执行，那时可能已经没有员工愿意提任何意见了。老是喊着“狼来了”，当狼真的来的时候又有谁会相信呢！虽然比喻不是很恰当，但又何其的相似。</p>

<p>看《贞观长歌》的时候，唐太宗曾提到“隋亡非炀帝一人之过，过在君臣。倘若群臣直言相谏，炀帝能够采纳一些谏言，也不至于如此快的亡国”。是啊，隋朝的灭亡是综合因素导致了这个结果。同样，一个公司也不可能因为一个人而兴起或衰败，是每一个个体因素综合的结果。不同的只是每个人在其中所占据的分量不同罢了。</p>

<p>自古君王死社稷，文臣死谏，武将死战！作为一个公司职员的我们，又该如何呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一封关于“书写技术文档提议”的信]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/28/%5B%3F%5D-feng-guan-yu-shu-xie-ji-zhu-wen-dang-ti-yi-de-xin/"/>
    <updated>2013-07-28T14:50:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/28/[?]-feng-guan-yu-shu-xie-ji-zhu-wen-dang-ti-yi-de-xin</id>
    <content type="html"><![CDATA[<p><img src="http://img2.itokit.com/uploadfile/2012/0308/20120308113544112.gif"></p>

<p>中国有句古话叫“授人以鱼不如授人以渔”，说的是传授给人既有知识，不如传授给人学习知识的方法。道理其实很简单，鱼是目的，钓鱼是手段，一条鱼能解一时之饥，却不能解长久之饥，如果想要永远有鱼吃，那就要学会钓鱼的方法。</p>

<!--more-->


<p>往往很多人理解这句话的时候是从“传授者”的角度出发，觉得“应该如何去做，而不应该如何去做，哪一种才是更好的选择”；然而，在某些特定的环境下却需要从“受众者”的角度去思考，作为一个“受众者”应该明白的问自己“此时此刻，我需要的是什么”。对于一个饥寒交迫的人来说，当然更希望得到那一框鱼以解燃眉之急，后续的生存并非一定要靠钓鱼才能为继；而对于一个已经解决温饱的人来说，更希望的是掌握钓鱼的技能，以后靠自己的垂钓便能享受到美味的鱼儿。</p>

<p>作为一个“受众者”，它是利益的所得者，在相应的环境下，明明白白知道自己想要什么才是最重要的。</p>

<p>对于一个公司来说，同样适用以上的那句古话。从公司的角度来看，可以把公司当作是一个“受众者”，把公司里的员工当作“传授者”。公司处于不同的发展阶段，对员工的需求会有所不同。每年的这个时候是一个“暗流涌动”的季节，难免会给公司带来一定的挑战。针对这个挑战，对公司来说并不是一件好事，怎么可能把它说成是“受众者”呢？针对这种问题，从辩证的角度去分析它会显得合理些。</p>

<p>企业间的人才流动交流，往往都有一段时间用来重新布置及安排任务，而这个安排的任务往往因时、因势而定。</p>

<p>如果公司的一切条件都已具备，那么让员工尽量去完成手头上的项目，对于公司这个“受众者”来说的话是利益最大化的。如果没有一个后来者能够顶替任务的话，那么尽量留下一些技术文档，对于公司来说才是利益最大化的。</p>

<p>我们的公司还很年轻，目前依旧处于发展的阶段，某些方面还不是很完善。针对公司现有的状况，谈谈我个人所看到的现象。之前接替服务器端工作的时候，尝试着去看wiki上的相关文档，发现XXX留下的文档对于后来者是很有价值的，很容易了解到“如何部署服务器”、“如何运行服务器上的监控脚本”等等。终端的前任离开了，但Windows方面的工具等一些东西却是有遗失的。虽然有些东西用作测试等其它方面的使用，但它却是非常有价值的东西（可以用来分析问题，解决相应的问题，缩短调试的时间等）。</p>

<p>记得当初第一份工作的时候，前东家的合同上有这么一句话（在为公司服务期间，所编写的代码和文档的所有权归公司所有），当时我笑了，我心想“系统已经如此的稳定，我们只是解解bug，会有什么东西留下，这是不是杞人忧天了”。然而，我幼稚的想法是非常错误的。除了平时解决bug，我们还是为公司开发了一些功能模块。公司强调着“所有权”的时候，它更侧重强调了“你要为公司留下什么”。一旦有人员流动时，借助着已有的文档，新的同仁就能够很快接手工作。虽然口头上的传授也是一种方法，但口口相传往往会产生一些谬误，也容易失去一些重要的东西。</p>

<p>这让我想起了《笑傲江湖》的一个段子“岳不群的师父传授给它几招《辟邪剑谱》，并嘱咐他‘这几招功夫华山派要代代相传’。岳不群看了之后，也认为那只是平庸无奇的几招。见识了林平之耍的几招之后，觉得跟自己以前学习的那几招很相似，觉得林家的《辟邪剑谱》就是本门失传已久的武功绝学。自此以后，他就开始费劲心思的去寻找那本书。当他得到的时候，他仅花费了不长的时间就学会了其中所有的武功”。在岳不群之前，华山派的那几招功夫传了好几代，却什么也没有悟出来，究其原因缺的就是《辟邪剑谱》那本书。假设华山派没有失去那本武功秘籍，‘辟邪剑法’相信也能够跟‘紫霞神功’一样，代代相传。</p>

<p>可见古语“好记性不如烂笔头”是值得让人深思的。何况一有变动的话，“好记性”已不在公司内部，成为了不可控因素。即便凭借以往的关系能够获取帮助，但他已不存在为公司服务的义务，帮不帮完全在乎心情。终端已尝试着整理一些文档，努力去阐明系统的架构。人可能往往看不清自己，所以这里暂且不论终端。只说说Windows客户端和测试，该两项在Wiki上的文档也是相对较少的。</p>

<p>正如前面提到的，Windows方面的东西是有遗失的。目前，tuner模块的code是由Windows客户端方面维护的，至于“如何编译”、“如何烧写”、“如何更改mac地址和id”等等方面的文档是没有的。尽管只要花时间就能找到方法（这属于一种重复造轮子的行为，有文档的话，我们只要一步步操作即可），但已经会的东西我们又何必去浪费时间去研究呢？客户端的功能虽然已经完备，但也缺少文档的说明。虽然看code加上其他人员对系统的介绍，作为一个后来者也能够逐步接替该部分工作。但这就好比“岳不群不停地在那里耍大招，左冷禅在一旁观看（即便岳不群愿意这样做，左冷禅也未必能够学习到‘飞针’那一招）”那样，既费时，又不能体会其中真正的奥秘。</p>

<p>很多人并不重视测试的作用，认为测试的工作有很多人可以替代。但我不以为然，一个好的测试人员描述的不仅仅是测试的表象，更多的会指出问题的根源，往往会起到指导开发人员的作用。测试方面也很需要一些文档，而且这是很有必要的。虽然测试用例目前已经较完备，可谁来告诉后来者“如何设计同样有效的测试用例”、 “如何正确有效的提交bug（这减少了开发和测试之间一些不必要的交互）”、“如何测试该系统”呢？我承认通过“开发者在某种意义上去指导后来的测试人员”来缩短学习时间。但我并不认为这是一种有效、好的方法，开发者往往带有主观色彩，会告诉测试人员“你应该怎么做，不应该怎么做”，这往往会误导测试（按照开发讲的东西去测试，而未能发现其中深藏的问题）。测试人员就应该专注于前辈留下的文档而脱离于开发者 ，站在客户的角度去思考问题。</p>

<p>如今，需要做的并不一定是要完成某项任务，而是要一些有意义的文档。任务就好比是“鱼”，是目的；而文档就好比是“以渔”，是手段。现今公司要的是“以渔”（作为一个“受众者”是目前所能获取到的最大利益），避免未来重复的造轮子。</p>

<p>虽然这只是一个建议，但还是诚恳的希望您能慎重的考虑一下。文中难免有错误的出现，敬请谅解！</p>

<p>书于蒋村兴达苑21幢2单元401，2013年3月25日23时36分</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[略说博客]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/28/lue-shuo-bo-ke/"/>
    <updated>2013-07-28T12:29:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/28/lue-shuo-bo-ke</id>
    <content type="html"><![CDATA[<p><img src="http://www.youdao.com/help/toys/bloggadget/001/1.gif"></p>

<p>在平时搜索技术问题的时候，收藏了一些技术博客。我发现博主的所在地域、服务公司、学习背景、年龄分布都有一些特性，初步作了一些整理同大家分享。在这里只论那些搭建独立博客的博主，而不讨论那些在各大论坛上构建博客的博主。</p>

<!--more-->


<h1>博主分布图</h1>

<h2>区域分布</h2>

<p>华东以上海、杭州为主，互联网企业相对较多，其公司的开放、自由、分享的文化起到了很关键的作用；华南以深圳、广州为主；华北以北京为主；中西部以重庆、武汉、西安为主，很多是学生博主群体，学校的文化在这方面起到了很重要的作用；西南部以成都为主。</p>

<h2>公司分布</h2>

<p>阿里系最多，腾讯系次之，网易系也有不少，其它较多的是一些新兴的互联网公司（这其中很多有阿里系的身影）。从这方面可以看出，阿里的公司氛围是很不错的，大伙都有分享的精神。补充一点，阿里也分享了很多的开源项目，到github上可以找到。</p>

<h2>学校分布</h2>

<p>西安邮电大学最多，华中科技大学次之，西安电子科技大学、西安交通大学、浙江大学也有不少，其它大学相对较少。所有大学中，西邮给我的映像最好，它们的学生在Linux方面有较高的造诣，出现了很多这方面的牛人。</p>

<h2>年龄分布</h2>

<p>以20～30岁年龄段居多，属于新兴博主，大多以技术路线为主；30～40岁年龄段的博主次之，属于资深博主，不仅有丰富的技术知识，还有精彩的人生阅历及感悟方面的文章；10～20岁年龄段的相对较少，属于后起之秀，大多也以技术为主线，其中年龄最小的大概是12、13岁。很多“老人”坚持写博客6、7年以上，实在是一件不容易的事情；小博主的崛起，真正应了“后生可畏”，想想自己那个年龄段都不知道自己想要做什么，看来“前浪”很快就会被“拍死在沙滩上”。</p>

<h1>杂说</h1>

<p>曾经在QQ空间、网易、其它技术论坛上写过博客，但都因为各种各样的原因（没有专一的主题，工作的变更导致技术方向的改变，人性的懒散等等）没有坚持下来。虽然不在那些博客中写文章，偶尔还是会去看看自己之前写的东西。</p>

<p>2011年的时候决定改变一下自己，觉得应该把自己学习到的东西记录一下，与网上的朋友们分享分享，所以在CU博客上安了家。这个博客从那时到现在一直有更新，大多是个人的学习笔记及从网络上转载的文章，后续也会继续更新。</p>

<p>很不幸的是，2013年年初的时候CU博客改版了，书写博客的整体体验很差，也向管理员反应过这个事件，可并未察觉出它们有更新博客系统的迹象。慢慢的就开始不爽了！5月份的时候就基于github和Octopress搭建了一个个人独立博客，陆陆续续到7月份才构建了一个自己认为比较满意的博客。独立博客的好处在于其可定制性强，不好的地方就是对于一个小白博主来说有一定的技术难度。</p>

<p>如果你是技术狼/媛，对Linux方面有兴趣的话可以看我的 <a href="http://blog.chinaunix.net/uid/25885064.html">CU博客</a> 和 <a href="http://txgcwm.github.io/">个人独立博客</a> 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于微访谈]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/27/guan-yu-wei-fang-tan/"/>
    <updated>2013-07-27T23:34:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/27/guan-yu-wei-fang-tan</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://pic002.cnblogs.com/images/2010/14032/2010111217383632.jpg" width="228" height="221" title="Place Kitten #2" ></p>

<h1>想法的初衷</h1>

<p>进入社会后，周围的事情与我们想象的并不一样，起初我们无所适从，慢慢的我们适应了这个复杂的社会。在这个适应的过程中，背负着社会和家庭的压力，或许有许多人蹉跎了岁月、消磨了意志、荒废了理想，也应该有一些人坚持不懈地行走在通往理想的道路上。有多少人还曾记得自己当初的梦想，记得或不记得都有很多的感慨。我们也常想把它记录下来，但真正提笔的时候却不知道从何处下手，所以也就放弃了。</p>

<!--more-->


<p>曾经一个同学在QQ上上传了一张“关于某某事意见签名”的单子，那时引起了强烈的反响，很多人都不曾记得有那么一回事。是的，岁月在消磨着我们的记忆。很多事情我们应该用笔把它记录下来，但多少人会使用日记把过往的经历记录下来呢？那么这个艰难的任务就交由我来处理吧，让我当一次“小史公”来记录你们走过的道路。虽然不能记录每一天的状况，但我们可以记录下一大段时间内的精彩。</p>

<p>由于行业、地域等方面的原因，交流圈变得小型化、区域化，彼此之间的交流越来越少，但我相信大家牵挂着彼此。借助这样一个机会，让大家了解一下我们的近况，增进彼此之间的认识，同时也可以让我们认识到更多的行业。</p>

<p>或许我们小有成就，认为这一切不足以拿来分享，可你的经历却可能给一些朋友带来帮助，其它朋友也可能给你带去更好的建议促你成长；或许我们过得很艰辛，这又如何，只有经历过辛酸才能品味美好。无论怎样，我们都可能得获取到宝贵的建议，让我们越走越好。</p>

<h1>执行流程</h1>

<p>按照初步的设计，本次微访谈的大概流程如下：</p>

<ol>
<li>向受访者发出要求，朋友们也可以主动告知我希望接受这样一个访谈；</li>
<li>如果接受的话，请告知我目前你所从事的事业、想法等等基本信息，我根据获取到的信息设计一些问题；</li>
<li>可以选择以邮件回复的方式或跟我以网络通讯工具交谈的方式来完成微访谈；</li>
<li>整理微访谈的问答以博文的形式发出，问答中所使用的署名采用受访者的网名，如果不同意可以不发表。</li>
</ol>


<h1>后续计划</h1>

<p>或许很多人不屑于这样的一次访谈，认为一个小小人物不值得记述，但我认为小人物的故事同样精彩。若干年后，或许我们成功了，又或许依旧平凡，回过头看看我们又会有怎样的感慨呢？所以，我希望两年后再做一次微访谈。</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[残剑]]></title>
  <link href="http://txgcwm.github.io/atom.xml" rel="self"/>
  <link href="http://txgcwm.github.io/"/>
  <updated>2013-07-23T23:09:24+08:00</updated>
  <id>http://txgcwm.github.io/</id>
  <author>
    <name><![CDATA[残剑]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ubuntu下安装SublimeText2及其插件]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/23/ubuntuxia-an-zhuang-sublimetext2ji-qi-cha-jian/"/>
    <updated>2013-07-23T22:33:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/23/ubuntuxia-an-zhuang-sublimetext2ji-qi-cha-jian</id>
    <content type="html"><![CDATA[<p>Sublime Text 2是一个轻量、简洁、高效、跨平台的编辑器，方便的配色以及兼容vim快捷键等各种优点博得了很多前端开发人员的喜爱。Sublime Text 2基本上是共享软件，免费版和收费版基本无区别，只是偶尔会弹框让你去购买，这个基本不影响使用。</p>

<h1>软件安装</h1>

<p>Ubuntu下安装Sublime Text 2有两种方式：指令安装和直接下载安装。</p>

<h2>指令安装</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo add-apt-repository ppa:webupd8team/sublime-text-2
</span><span class='line'>$ sudo apt-get update
</span><span class='line'>$ sudo apt-get install sublime-text-2</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h2>直接下载安装</h2>

<p>从 <a href="http://www.sublimetext.com/2">这里</a>下载所需要的版本，然后解压文件到安装目录。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo tar -jxvf Sublime\ Text\ 2.0.1.tar.bz2 -C /usr/local/</span></code></pre></td></tr></table></div></figure>


<h1>在applications菜单中创建快捷方式</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo gedit /usr/share/applications/sublimetext.desktop 
</span><span class='line'>
</span><span class='line'>[Desktop Entry]
</span><span class='line'>Encoding=UTF-8
</span><span class='line'>Name=Sublime Text
</span><span class='line'>Comment=Sublime Text
</span><span class='line'>Exec=/usr/local/SublimeText/sublime_text
</span><span class='line'>Icon=/usr/local/SublimeText/Icon/48x48/sublime_text.png
</span><span class='line'>Terminal=false
</span><span class='line'>StartupNotify=true
</span><span class='line'>Type=Application
</span><span class='line'>Categories=Application;Development;</span></code></pre></td></tr></table></div></figure>


<h1>安装插件</h1>

<p>安装Sublime text 2插件也有两种方法：直接安装和使用Package Control组件安装。</p>

<h2>直接安装</h2>

<p>可以直接下载安装包解压缩到Packages目录（菜单->preferences->packages）。</p>

<h2>使用Package Control组件安装</h2>

<p>也可以先安装package control组件，然后直接在线安装：</p>

<ul>
<li>按Ctrl + <code>调出console ，其中</code>是键盘左上角那个符号。</li>
<li>粘贴以下代码到底部命令行并回车。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print 'Please restart Sublime Text to finish installation'</span></code></pre></td></tr></table></div></figure>


<ul>
<li>重启Sublime Text 2。</li>
<li>如果在Perferences->package settings中看到package control这一项，则安装成功。 如果这种方法不能安装成功，可以到 <a href="http://wbond.net/sublime_packages/package_control/installation">这里</a> 下载文件手动安装。</li>
</ul>


<p>用Package Control安装插件的方法：a、按下<code>Ctrl+Shift+P</code>调出命令面板；b、输入<code>install</code>调出Install Package选项并回车，然后在列表中选中要安装的插件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress添加中文标签功能]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/21/octopresstian-jia-zhong-wen-biao-qian-gong-neng/"/>
    <updated>2013-07-21T11:02:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/21/octopresstian-jia-zhong-wen-biao-qian-gong-neng</id>
    <content type="html"><![CDATA[<p>Octopress有自带的分类，详情请见 <a href="http://octopress.org/docs/plugins/category-generator/">官方文档</a> 。<code>_config.yml</code>中配置项如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>category_dir: blog/categories
</span><span class='line'>category_title_prefix: "Category: "</span></code></pre></td></tr></table></div></figure>


<p>然后添加类似<code>categories: [Ruby&amp;Rails]</code>或<code>categories: [Ruby&amp;Rails，C/C++]</code>的分类标签配置到每个<code>_posts/*.markdown</code>文件头中，示例如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: post
</span><span class='line'>title: "Octopress添加中文标签功能"
</span><span class='line'>date: 2013-07-21 11:02
</span><span class='line'>comments: true
</span><span class='line'>categories: [Ruby&Rails,Octopress]
</span><span class='line'>---</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h1>添加分类侧边栏并支持中文</h1>

<p>尽管Octopress有自带的分类，但它并不支持中文，如果你在文章中定义了中文分类，那么点击的时候会链接到404页面。事实上，这个分类功能是通过plugins/category_generator.rb来实现，所以只要对该文件进行适当的修改和作一些其它的配置就可以提供中文分类的支持。</p>

<ul>
<li>category_generator.rb的修改我直接使用 <a href="https://github.com/denjones/denjones.github.com/blob/source/plugins/category_generator.rb">这个</a> 文件作了替换，然后作一些细微的修改。</li>
</ul>


<p>SPRabbit(超科学兔耳中队)的 <a href="http://blog.sprabbit.com/blog/2012/03/23/octopress/">修改方法</a> 是重新定义分类标签在文章中的格式，例如用<code>中文分类标签名{英文别名}</code>这样的格式来定义标签。于是在文章中显示的是中文分类，但实际链接到英文别名上。这种方法虽然定义标签麻烦些，但可定制性强。</p>

<p>由于书写很麻烦，所以很不喜欢以上重新定义标签的方式，在 <a href="http://khaos.github.io/blog/2012/12/06/using-chinese-category-tags-in-octopress/">这里</a> 找到了另外一种更改方式。它同样是修改category_generator.rb文件来达到目的，利用了stringex包的to_url函数将中文分类标签的链接名和category_dir下的目录名都转换成相应的拼音，这样无论在本地还是GitHub上都没有问题。事实上，Octopress系统在利用rake new_[post|page]命令创建含有中文名的文章时也采用了这样的技巧。</p>

<p>找到<code>def write_category_indexes</code>中定义category目录的部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.write_category_index(File.join(dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').downcase), category)</span></code></pre></td></tr></table></div></figure>


<p>将其修改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.write_category_index(File.join(dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').to_url.downcase), category)</span></code></pre></td></tr></table></div></figure>


<p>再找到<code>def category_links(categories)</code>中定义中文分类网页标签的部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"&lt;a class='category' href='http://txgcwm.github.io/#{dir}/#{item.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').downcase}/'&gt;#{item}&lt;/a&gt;"</span></code></pre></td></tr></table></div></figure>


<p>将其修改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"&lt;a class='category' href='http://txgcwm.github.io/#{dir}/#{item.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').to_url.downcase}/'&gt;#{item}&lt;/a&gt;"</span></code></pre></td></tr></table></div></figure>


<p>注意，上面两处的修改就是在相应的地方加上to_url函数进行地址的转换。如果不想折腾的话，你也可以直接到 <a href="https://github.com/txgcwm/txgcwm.github.com/blob/source/plugins/category_generator.rb">这里</a> 下载我更改后的category_generator.rb插件。</p>

<ul>
<li>在plugins目录中创建category_list_tag.rb文件，文件内容如下：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require 'stringex'
</span><span class='line'>
</span><span class='line'>module Jekyll
</span><span class='line'>  class CategoryListTag &lt; Liquid::Tag
</span><span class='line'>    def render(context)
</span><span class='line'>      html = ""
</span><span class='line'>      categories = context.registers[:site].categories.keys
</span><span class='line'>    category_dir = context.registers[:site].config['category_dir']
</span><span class='line'>      categories.sort.each do |category|
</span><span class='line'>        posts_in_category = context.registers[:site].categories[category].size    
</span><span class='line'>        category_url = File.join(category_dir, category.gsub(/_|\P{Word}/u, '-').gsub(/-{2,}/u, '-').to_url.downcase)
</span><span class='line'>        html &lt;&lt; "&lt;li class='category'&gt;&lt;a href='http://txgcwm.github.io/#{category_url}/'&gt;#{category} (#{posts_in_category})&lt;/a&gt;&lt;/li&gt;\n"
</span><span class='line'>      end
</span><span class='line'>      html
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>Liquid::Template.register_tag('category_list', Jekyll::CategoryListTag)</span></code></pre></td></tr></table></div></figure>


<p>在实际使用（rake generate/rake preview）的时候，若blog整体采用了非ascii码的编码格式（比如utf-8）就会出现类似这样的错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Liquid error: incompatible encoding regexp match (ascii-8bit regexp with utf-8 string)</span></code></pre></td></tr></table></div></figure>


<p>其实是由于插件文件plugins/category_list_tag.rb本身是ascii编码所致:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ chardet category_list_tag.rb
</span><span class='line'>category_list_tag.rb: ascii (confidence: 1.00)</span></code></pre></td></tr></table></div></figure>


<p>category_list_tag.rb中很多地方用到了ruby的正则表达式，而ruby的正则表达式在匹配的时候，默认是按照“代码源文件”的编码格式(在这里是ascii)进行匹配的，而如果blog是utf-8编码的话就会出现上述错误。有两种解决办法：</p>

<ol>
<li>将category_list_tag.rb转成utf-8格式。</li>
<li>更改category_list_tag.rb中所有的正则表达式声明，加上<code>u</code>选项（<code>u</code>的意思就是以utf-8编码格式来进行匹配）。例如，若原正则表达式是<code>/regexp/</code>, 则改成<code>/regexp/u</code>。</li>
</ol>


<p>在我实际处理问题的时候采用了第二种方法，category_list_tag.rb文件中的更改网上大多采用以下的方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>category_url = File.join(category_dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').to_url.downcase)</span></code></pre></td></tr></table></div></figure>


<p>更改成如下形式（只是简单增加了<code>u</code>选项）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>category_url = File.join(category_dir, category.gsub(/_|\P{Word}/u, '-').gsub(/-{2,}/u, '-').to_url.downcase)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>添加source/_includes/custom/asides/category_list.html文件，内容可到 <a href="https://github.com/txgcwm/txgcwm.github.com/blob/source/source/_includes/custom/asides/category_list.html">这里</a> 查看。</p></li>
<li><p>修改_config.yml文件，在default_asides项中添加custom/asides/category_list.html，值之间以逗号隔开。</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default_asides: [asides/recent_posts.html, custom/asides/category_list.html]</span></code></pre></td></tr></table></div></figure>


<p><code>_posts/*.markdown</code>文件头中添加categories标签示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: post
</span><span class='line'>title: "使用libevent编写Linux服务"
</span><span class='line'>date: 2013-07-18 19:01
</span><span class='line'>comments: true
</span><span class='line'>categories: [C/C++, 开源库, Unix/Linux]
</span><span class='line'>---</span></code></pre></td></tr></table></div></figure>


<p>到此为止，Octopress中添加分类侧边栏并使其支持中文的修改设置已经完毕。</p>

<h1>参考文章</h1>

<ul>
<li><a href="http://www.cnblogs.com/oec2003/archive/2013/05/31/3109577.html">Octopress博客设置</a></li>
<li><a href="http://ikeepu.com/bar/10393365">Octopress博客分类添加中文支持</a></li>
<li><a href="http://khaos.github.io/blog/2012/12/06/using-chinese-category-tags-in-octopress/">Octopress易筋经，中文分类标签</a></li>
<li><a href="http://blog.sprabbit.com/blog/2012/03/23/octopress/">关于在64位 Windows 7 中部署中文化的Octopress</a></li>
<li><a href="http://pfmiles.github.io/blog/liquid-error-about-regexp-match-when-using-octopress-tagcloud/">Liquid Error About Regexp Match When Using Octopress-tagcloud</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将Emacs配置成一个C/C++的IDE编程环境]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/20/jiang-emacspei-zhi-cheng-%5B%3F%5D-ge-c-slash-c-plus-plus-de-idebian-cheng-huan-jing/"/>
    <updated>2013-07-20T14:47:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/20/jiang-emacspei-zhi-cheng-[?]-ge-c-slash-c-plus-plus-de-idebian-cheng-huan-jing</id>
    <content type="html"><![CDATA[<p>在Linux环境下编程，首先要选择开发工具，大部分程序员都是使用VIM和EMACS这两大神器。虽说它们只是编辑器，但由于其超强的可定制性，已成为广大linux工作者的首选。使用<code>sudo apt-get install emacs</code>来安装Emaces。</p>

<h1>Emacs的基本操作和组合键</h1>

<h2>模式键定义</h2>

<p>四个模式键：C&mdash;-Ctrl；M&mdash;-Alt；s&mdash;-Super(Win)；S&mdash;-Shift</p>

<p>比如：</p>

<p>C-x：表示按下ctrl键，然后按下x键。</p>

<p>C-x c C-c：表示按下ctrl，然后按下x键，松开后再按下c键。</p>

<p>C-x k：表示按下ctrl，同时按下x和k键。</p>

<!--more-->


<h2>基本组合键</h2>

<p>C-x C-c：退出Emacs。</p>

<p>C-x C-s：保存当前buffer。</p>

<p>C-x C-f：打开和新建文件。</p>

<p>C-n：光标移到下一行。</p>

<p>C-p：光标移到上一行。</p>

<p>C-k：删除一行。</p>

<p>M-x：执行命令。</p>

<h1>启动时的大小和屏幕中的位置</h1>

<p>关于修改Emacs启动大小和屏幕中的位置有两种方法：1、修该~/.Xdefault文件，然后运行<code>xrdb ~/.Xdefault</code>；2、在~/.emacs文件中进行修改。按照第二种方法作如下设置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;设置启动的大小和屏幕中的位置
</span><span class='line'>(setq default-frame-alist
</span><span class='line'>  '((height . 35)(width . 100)(menubar-lines . 20)(tool-bar-lines . 0)))</span></code></pre></td></tr></table></div></figure>


<p>以上语句表示Emacs在启动后其高度为35，宽度为100，显示在屏幕的x=20，y=0处。</p>

<h1>Emacs的基本常规设定</h1>

<p>按照一般的习惯，.emacs文件中一般不会放太多的设置信息，一般放一些emacs的搜索路径信息。这里将emacs的配置文件（即lisp脚本）都放在~/.emacs.d/emacs的文件夹中。因此首先添加一个emacs的搜索路径：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;;; 添加Emacs搜索路径
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/emacs")
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/emacs/ecb-2.40")
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/emacs/codepilot")
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/emacs/emacs-eclim")
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/emacs/icicles")
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/emacs/gnuserv")</span></code></pre></td></tr></table></div></figure>


<p>然后加载我们对emacs的设置脚本，在.emacs中添加如下语句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;;;读取脚本
</span><span class='line'>(load "base.el")
</span><span class='line'>(load "cyexpand.el")
</span><span class='line'>(load "cykbd.el")
</span><span class='line'>(load "addon.el")
</span><span class='line'>
</span><span class='line'>;;编程的配置
</span><span class='line'>(load "cycode.el")</span></code></pre></td></tr></table></div></figure>


<p>对emacs的基本设置，即base.el文件（在~/.emacs.d/emacs中），base.el文件中的部分内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;显示时间
</span><span class='line'>;;(display-time)
</span><span class='line'>(display-time-mode 1);;启用时间显示设置，在minibuffer上面的那个杠上
</span><span class='line'>(setq display-time-24hr-format t);;时间使用24小时制
</span><span class='line'>(setq display-time-day-and-date t);;时间显示包括日期和具体时间
</span><span class='line'>;;(setq display-time-use-mail-icon t);;时间栏旁边启用邮件设置
</span><span class='line'>;;(setq display-time-interval 10);;时间的变化频率，单位多少来着？
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>;;显示列号
</span><span class='line'>(setq column-number-mode t)
</span><span class='line'>;;没列左边显示行号,按f3显示/隐藏行号
</span><span class='line'>(require 'setnu)
</span><span class='line'>(setnu-mode t)
</span><span class='line'>;;(global-set-key[f3] (quote setnu-mode))
</span><span class='line'>
</span><span class='line'>;;显示标题栏 %f 缓冲区完整路径 %p 页面百分数 %l 行号
</span><span class='line'>(setq frame-title-format "%f")
</span><span class='line'>
</span><span class='line'>;;=======================================================================
</span><span class='line'>;;缓冲区
</span><span class='line'>;;=====================================================================
</span><span class='line'>;;设定行距
</span><span class='line'>(setq default-line-spaceing 4)
</span><span class='line'>;;页宽
</span><span class='line'>(setq default-fill-column 60)
</span><span class='line'>;;缺省模式 text-mode
</span><span class='line'>;;(setq default-major-mode 'text-mode)
</span><span class='line'>;;设置删除记录
</span><span class='line'>(setq kill-ring-max 200)
</span><span class='line'>;;以空行结束
</span><span class='line'>;;(setq require-final-newline t)
</span><span class='line'>;;开启语法高亮。
</span><span class='line'>(global-font-lock-mode 1)
</span><span class='line'>;;高亮显示区域选择
</span><span class='line'>(transient-mark-mode t)
</span><span class='line'>;;页面平滑滚动,scroll-margin 3 靠近屏幕边沿3行开始滚动，正好可以看到上下文
</span><span class='line'>;;(setq scroll-margin 3 scroll-consrvatively 10000)
</span><span class='line'>;;高亮显示成对括号
</span><span class='line'>(show-paren-mode t)
</span><span class='line'>(setq show-paren-style 'parentheses)
</span><span class='line'>;;鼠标指针避光标
</span><span class='line'>(mouse-avoidance-mode 'animate)
</span><span class='line'>;;粘贴于光标处,而不是鼠标指针处
</span><span class='line'>(setq mouse-yank-at-point t)</span></code></pre></td></tr></table></div></figure>


<p>设置默认工作目录，即启动emacs后所在的目录，在base.el中加上下面一句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;设置默认工作目录
</span><span class='line'>(setq default-directory "/srv") </span></code></pre></td></tr></table></div></figure>


<h1>C/C++的配置</h1>

<p>C/C++的配置主要是cycode.el文件。开发时很重要的一步就是调试，所以首先就是增加图形化调试界面：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;==============================================================
</span><span class='line'>;;gdb-UI配置
</span><span class='line'>;;==============================================================
</span><span class='line'>(setq gdb-many-windows t)
</span><span class='line'>(load-library "multi-gud.el")
</span><span class='line'>(load-library "multi-gdb-ui.el")</span></code></pre></td></tr></table></div></figure>


<p>上面加载了两个lisp的脚本文件，这两个文件是直接在网上下载的图形化调试文件。</p>

<p>为了能高效的浏览和编辑代码，需要安装cedet插件。从官网下载cedet后，在~/.emacs.d/emacs目录中解压，根据解压出来文件夹中的INSTALL文件说明的方法安装cedet即可。有一点需要注意就是安装完成后不能删除安装后的文件，也就是需要保留解压后的文件夹。安装完成后，用下面的语句将我们需要的一些东西包含进来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;==================================================
</span><span class='line'>;;cedet插件设置
</span><span class='line'>;;==================================================
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/emacs/cedet-1.1/speedbar")
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/emacs/cedet-1.1/eieio")
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/emacs/cedet-1.1/semantic")</span></code></pre></td></tr></table></div></figure>


<p>然后就可进行有关cedet的设置，这里仅以一个代码折叠和展开为例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;代码折叠
</span><span class='line'>;;(require 'semantic-tag-folding nil 'noerror)
</span><span class='line'>(global-semantic-tag-folding-mode 1)
</span><span class='line'>;;折叠和打开整个buffer的所有代码
</span><span class='line'>(define-key semantic-tag-folding-mode-map (kbd "C--") 'semantic-tag-folding-fold-all)
</span><span class='line'>(define-key semantic-tag-folding-mode-map (kbd "C-=") 'semantic-tag-folding-show-all)
</span><span class='line'>;;折叠和打开单个buffer的所有代码
</span><span class='line'>(define-key semantic-tag-folding-mode-map (kbd "C-_") 'semantic-tag-folding-fold-block)
</span><span class='line'>(define-key semantic-tag-folding-mode-map (kbd "C-+") 'semantic-tag-folding-show-block)</span></code></pre></td></tr></table></div></figure>


<p>为了使用更方便（即对上面cedet插件的一个补充），需要再安装一个ecb插件。下载ecb后解压到~/.emacs.d/emacs目录中即可，然后加上下面两句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;==============================================================
</span><span class='line'>;;ecb配置
</span><span class='line'>;;==============================================================
</span><span class='line'>;;(require 'ecb)
</span><span class='line'>;;开启ecb用,M-x:ecb-activate
</span><span class='line'>(require 'ecb-autoloads)
</span><span class='line'>;;自动启动ecb并且不显示每日提示
</span><span class='line'>;;(require 'ecb)
</span><span class='line'>;;(setq ecb-auto-activate t)
</span><span class='line'>(setq ecb-tip-of-the-day nil)</span></code></pre></td></tr></table></div></figure>


<p>为了实现自动补全功能，需要安装auto-complete和yasnippet这两个插件。auto-complete下载后放到~/.emacs.d/emacs目录中解压，然后进入解压后的目录输入make命令即可；yasnippet下载后解压到~/.emacs.d/emacs目录中即可。下面是关于这两个插件的配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;==========================================================
</span><span class='line'>;;YASnippet的配置
</span><span class='line'>;;==========================================================
</span><span class='line'>(require 'yasnippet)    ;;not yasnippet-bundle
</span><span class='line'>(yas/initialize)
</span><span class='line'>(yas/load-directory "~/.emacs.d/emacs/yasnippet-0.6.1c/snippets")</span></code></pre></td></tr></table></div></figure>


<p>装完插件后，作一些综合的配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;配置Semantic搜索范围
</span><span class='line'>(setq semanticdb-project-roots
</span><span class='line'>    (list
</span><span class='line'>     (expand-file-name "/")))
</span><span class='line'>;;自定义补全命令，如果单词在中间就补全，否则就tab
</span><span class='line'>(defun my-indent-or-complete()
</span><span class='line'>  (interactive)
</span><span class='line'>  (if (looking-at "\\&gt;")
</span><span class='line'>    (hippie-expand nil)
</span><span class='line'>    (indent-for-tab-command))
</span><span class='line'>  )
</span><span class='line'>;;补全快捷键，ctrl+tab用senator补全，不显示列表
</span><span class='line'>;;alt+/补全，显示列表让选择
</span><span class='line'>(global-set-key [(control tab)] 'my-indent-or-complete)
</span><span class='line'>(define-key c-mode-base-map [(meta ?/)] 'semantic-ia-complete-symbol-menu)
</span><span class='line'>(autoload 'senator-try-expand-semantic "senator")
</span><span class='line'>(setq hippie-expand-try-functions-list
</span><span class='line'>    '(
</span><span class='line'>      senator-try-expand-semantic
</span><span class='line'>      try-expand-dabbrev
</span><span class='line'>      try-expand-dabbrev-visible
</span><span class='line'>      try-expand-dabbrev-all-buffers
</span><span class='line'>      try-expand-dabbrev-from-kill
</span><span class='line'>      try-expand-list
</span><span class='line'>      try-expand-list-all-buffers
</span><span class='line'>      try-expand-line
</span><span class='line'>      try-expand-line-all-buffers
</span><span class='line'>      try-complete-file-name-partially
</span><span class='line'>      try-complete-file-name
</span><span class='line'>      try-expand-whole-kill
</span><span class='line'>      )
</span><span class='line'>    )</span></code></pre></td></tr></table></div></figure>


<h1>键绑定</h1>

<p>为了使用emacs更方便，需要一些键绑定（即自己定义一些组合键），这也是emacs配置中必不可少的一步。自定义组合键放在cykbd.el文件中。根据一般的习惯用f1来表示帮助，即man命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(global-set-key [f1] 'manual-entry)
</span><span class='line'>(global-set-key [C-f1] 'info )</span></code></pre></td></tr></table></div></figure>


<p>f3-f5的一些绑定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;f3为查找字符串,alt+f3关闭当前缓冲区
</span><span class='line'>(global-set-key [f3] 'grep-find)
</span><span class='line'>(global-set-key [M-f3] 'kill-this-buffer)
</span><span class='line'>
</span><span class='line'>;;.emacs中设一个speedbar的快捷键
</span><span class='line'>(global-set-key [(f4)] 'speedbar-get-focus)
</span><span class='line'>;;ctrl-f4,激活,ecb
</span><span class='line'>(global-set-key [C-f4] 'ecb-activate)
</span><span class='line'>
</span><span class='line'>;;F5显示/隐藏工具栏 方便调试
</span><span class='line'>(global-set-key [f5] 'tool-bar-mode)
</span><span class='line'>;;ctrl-F5显示/隐藏菜单栏 ;; M-x menu-bar-open
</span><span class='line'>(global-set-key [C-f5] 'menu-bar-mode)</span></code></pre></td></tr></table></div></figure>


<p>f6为gdb调试，f7调用make来对原文件进行编译：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(global-set-key [f6] 'gdb)
</span><span class='line'>
</span><span class='line'>;;  C-f7, 设置编译命令; f7, 保存所有文件然后编译当前窗口文件
</span><span class='line'>(defun du-onekey-compile ()
</span><span class='line'>  "Save buffers and start compile"
</span><span class='line'>  (interactive)
</span><span class='line'>  (save-some-buffers t)
</span><span class='line'>  (switch-to-buffer-other-window "*compilation*")
</span><span class='line'>  (compile compile-command))
</span><span class='line'>  
</span><span class='line'>(setq-default compile-command "make")    
</span><span class='line'>(global-set-key [C-f7] 'compile)
</span><span class='line'> (global-set-key [f7] 'du-onekey-compile)</span></code></pre></td></tr></table></div></figure>


<p>将f8为对buffer的一些常用操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;目的是开一个shell的小buffer，用于更方便地测试程序(也就是运行程序了)，我经常会用到。
</span><span class='line'>;;f8就是另开一个buffer然后打开shell，C-f8则是在当前的buffer打开shell,shift+f8清空eshell
</span><span class='line'>(defun open-eshell-other-buffer ()
</span><span class='line'>  "Open eshell in other buffer"
</span><span class='line'>  (interactive)
</span><span class='line'>  (split-window-vertically)
</span><span class='line'>  (eshell))
</span><span class='line'>(defun my-eshell-clear-buffer ()
</span><span class='line'>  "Eshell clear buffer."
</span><span class='line'>  (interactive)
</span><span class='line'>  (let ((eshell-buffer-maximum-lines 0))
</span><span class='line'>    (eshell-truncate-buffer)))
</span><span class='line'>(global-set-key [(f8)] 'open-eshell-other-buffer)
</span><span class='line'>(global-set-key [C-f8] 'eshell)
</span><span class='line'>(global-set-key [S-f8] 'my-eshell-clear-buffer)</span></code></pre></td></tr></table></div></figure>


<p>f9-f11的一些绑定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;设置[C-f9]为调用dired命令
</span><span class='line'>(global-set-key [C-f9] 'dired)
</span><span class='line'>(global-set-key [f9] 'other-window);f9在其他窗口之间旋转
</span><span class='line'>
</span><span class='line'>;;设置F10为撤销
</span><span class='line'>(global-set-key [C-f10] 'undo)
</span><span class='line'>
</span><span class='line'>;;设置F11快捷键指定Emacs 的日历系统
</span><span class='line'>(global-set-key [C-f11] 'calendar) </span></code></pre></td></tr></table></div></figure>


<p>用f12查看函数定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;设置C-F12 快速察看日程安排
</span><span class='line'>;;F12调到函数定义
</span><span class='line'>(global-set-key [f12] 'semantic-ia-fast-jump)
</span><span class='line'>(global-set-key [C-f12] 'list-bookmarks)
</span><span class='line'>;;shift-f12跳回去
</span><span class='line'>(global-set-key [S-f12]
</span><span class='line'>  (lambda ()
</span><span class='line'>  (interactive)
</span><span class='line'>  (if (ring-empty-p (oref semantic-mru-bookmark-ring ring))
</span><span class='line'>  (error "Semantic Bookmark ring is currently empty"))
</span><span class='line'>  (let* ((ring (oref semantic-mru-bookmark-ring ring))
</span><span class='line'>  (alist (semantic-mrub-ring-to-assoc-list ring))
</span><span class='line'>  (first (cdr (car alist))))
</span><span class='line'>  (if (semantic-equivalent-tag-p (oref first tag)
</span><span class='line'>  (semantic-current-tag))
</span><span class='line'>  (setq frist (cdr (car (cdr alist)))))
</span><span class='line'>  (semantic-mrub-switch-tags first))))</span></code></pre></td></tr></table></div></figure>


<p>对ecb的键绑定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;==================ecb的配置=================================
</span><span class='line'>;;为了ecb窗口的切换
</span><span class='line'>(global-set-key [M-left] 'windmove-left)
</span><span class='line'>(global-set-key [M-right] 'windmove-right)
</span><span class='line'>(global-set-key [M-up] 'windmove-up)
</span><span class='line'>(global-set-key [M-down] 'windmove-down)
</span><span class='line'>;;隐藏和显示ecb窗口
</span><span class='line'>(global-set-key [f11] 'ecb-hide-ecb-windows)
</span><span class='line'>(global-set-key [S-f11] 'ecb-show-ecb-windows)</span></code></pre></td></tr></table></div></figure>


<p>对窗口的一些键绑定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;;关闭当前窗口,alt+4
</span><span class='line'>(global-set-key (kbd "M-4") 'delete-window)
</span><span class='line'>;;(global-set-key (kbd "M-4") 'kill-this-buffer)
</span><span class='line'>;;关闭其他窗口,alt+1
</span><span class='line'>(global-set-key (kbd "M-1") 'delete-other-windows)
</span><span class='line'>;;水平分割窗口,alt+2
</span><span class='line'>(global-set-key (kbd "M-2") 'split-window-vertically)
</span><span class='line'>;;垂直分割窗口,alt+3
</span><span class='line'>(global-set-key (kbd "M-3") 'split-window-horizontally)
</span><span class='line'>;;切换到其他窗口，alt+0
</span><span class='line'>(global-set-key (kbd "M-0") 'other-window)
</span><span class='line'>;;显示缓冲区完整名称
</span><span class='line'>(global-set-key (kbd "M-5") 'display-buffer-name)</span></code></pre></td></tr></table></div></figure>


<h1>Emacs的扩展配置</h1>

<p>为了使emacs更符合个人的习惯，增加了一个cyexpand.el配置文件，其部分设置如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>;; 编码设置
</span><span class='line'>(require 'coding-settings)
</span><span class='line'>
</span><span class='line'>;; `mode-line'显示格式
</span><span class='line'>(require 'mode-line-settings)
</span><span class='line'>
</span><span class='line'>;; 各种语言开发方面的设置,这个设置牵涉到太多配置....
</span><span class='line'>(require 'dev-settings)
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>;; 显示行号
</span><span class='line'>(require 'linum-settings)
</span><span class='line'>
</span><span class='line'>;; color theme Emacs主题,很多face文件
</span><span class='line'>(require 'color-theme-settings)
</span><span class='line'>
</span><span class='line'>(require 'ahei-face)
</span><span class='line'>(require 'color-theme-ahei)
</span><span class='line'>(require 'face-settings)
</span><span class='line'>
</span><span class='line'>;; 高亮当前行
</span><span class='line'>(require 'hl-line-settings)
</span><span class='line'>
</span><span class='line'>;; 字体配置
</span><span class='line'>(require 'font-settings)
</span><span class='line'>;; diff
</span><span class='line'>(require 'diff-settings)
</span><span class='line'>;; Emacs的diff: ediff,有个my-fontest-win的文件很关键
</span><span class='line'>(require 'ediff-settings)
</span><span class='line'>
</span><span class='line'>;; 在buffer中方便的查找字符串: color-moccur
</span><span class='line'>(require 'moccur-settings)
</span><span class='line'>;; Emacs超强的增量搜索Isearch配置
</span><span class='line'>(require 'isearch-settings)
</span><span class='line'>
</span><span class='line'>;; 增加更丰富的高亮
</span><span class='line'>(require 'generic-x)
</span><span class='line'>
</span><span class='line'>;; spell check
</span><span class='line'>(setq-default ispell-program-name "aspell")
</span><span class='line'>
</span><span class='line'>;; Emacs中的包管理器
</span><span class='line'>(require 'package)
</span><span class='line'>(package-initialize)
</span><span class='line'>
</span><span class='line'>;; 在Emacs里面使用shell
</span><span class='line'>(require 'term-settings)
</span><span class='line'>(require 'multi-term-settings)
</span><span class='line'>
</span><span class='line'>;; 可以把光标由方块变成一个小长条
</span><span class='line'>(require 'bar-cursor)</span></code></pre></td></tr></table></div></figure>


<p>到此为止，已经将emacs打造成了开发C/C++的简易IDE。在使用过程中只需要会配置base.el、cycode.el、cykbd.el、cyexpand.el这四个文件即可，相关配置文件和插件可以到 <a href="https://github.com/txgcwm/emacs.d">这里</a> 下载。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Uboot中TFTP解释]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/19/ubootzhong-tftpjie-shi/"/>
    <updated>2013-07-19T22:45:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/19/ubootzhong-tftpjie-shi</id>
    <content type="html"><![CDATA[<p>TFTP在Uboot中用于发送较小的文件，使用UDP协议，发送使用69端口，每次发送的最大分组为512 bytes，发送双方采用超时重传机制，数据传输模式为octet模式（二进制模式）。发送文件时使用<code>tftp MemoryAddress FileName</code>命令即可，其中MemoryAddress为放入文件的内存首地址，FileName为传送文件的文件名。</p>

<p>使用TFTP传送文件的步骤：</p>

<ol>
<li>使用时已经初始化以下变量：NetOurIP（本机IP地址，定义在Net.c文件）、NetServerIP（TFTP服务器的IP地址，定义在Net.c文件）、BootFile（需要传送文件的文件名，定于在tftp.c）、NetOurGatewayIP（本机的网关地址）、NetOurSubnetMask（本机子网掩码）。</li>
<li>调用TftpStart 函数开始文件传送。</li>
</ol>


<!--more-->


<h1>客户端状态</h1>

<p>TFTP使用一个变量TftpState来描述TFTP客户端可能的5种状态：</p>

<p><img src="http://txgcwm.github.io/images/2013/7/tftp/states.png" alt=" states " /></p>

<h1>包类型</h1>

<p>使用TFTP传送的包分为6种类型：</p>

<p><img src="http://txgcwm.github.io/images/2013/7/tftp/types.png" alt=" types " /></p>

<h1>各种包结构</h1>

<p>TFTP协议中各种包的结构：</p>

<p><img src="http://txgcwm.github.io/images/2013/7/tftp/pack_struct.png" alt=" pack_struct " /></p>

<p>Uboot中客户端发送的包的包括RRQ和ACK。RRQ（请求读的包）包的结构:</p>

<p><img src="http://txgcwm.github.io/images/2013/7/tftp/rrq.png" alt=" rrq " /></p>

<p>ACK（确认帧）结构：</p>

<p><img src="http://txgcwm.github.io/images/2013/7/tftp/ack.png" alt=" ack " /></p>

<h1>主要函数及作用</h1>

<p>Uboot中与tftp协议有关的文件有tftp.c与tftp.h文件，主要函数包括：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 根据预先设定的地址load_addr决定将首地址为src，长度为len的block个数据块写入flash 或写入内存*/
</span><span class='line'>static __inline__ void store_block (unsigned block, uchar * src, unsigned len);
</span><span class='line'>
</span><span class='line'>/* 根据TftpState变量的不同值发送不同的 Tftp包 （使用UDP协议发送） */
</span><span class='line'>static void TftpSend (void) ;
</span><span class='line'>
</span><span class='line'>/* 处理收到的Tftp包 */
</span><span class='line'>static void TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len) ;
</span><span class='line'>
</span><span class='line'>/* 超时处理函数 */
</span><span class='line'>static void TftpTimeout (void);
</span><span class='line'>
</span><span class='line'>/* 初始化各个需要的数据 然后开始发送TFTP读请求 */
</span><span class='line'>void TftpStart (void);</span></code></pre></td></tr></table></div></figure>


<h1>流程</h1>

<p>TFTP总体流程：首先客户端发出读写请求，如果服务器批准此请求，则打开连接并接收第一个数据包。客户端收到数据包后发回确认，而服务器发出下一个数据包以前必须得到客户对上一个数据包的确认。如果数据包在传输过程中丢失，服务器方会在超时后重新传输最后一个未被确认的数据包。发送的数据包一般为512字节，如果一个数据包小于 512 字节，则表示这个包是最后一个包，如果发送的数据正好是 512 的整数倍，发送完后再发一个空包。</p>

<p>以下是客户端和服务器端通信的流程图：</p>

<p><img src="http://txgcwm.github.io/images/2013/7/tftp/flow.png" alt=" flow " /></p>

<p>客户端程序流程：</p>

<ol>
<li>客户端设定NetOurIP 、NetServerIP、BootFile 变量的值。</li>
<li>调用TftpStart函数完成如下6步工作：（1）若BootFile为空则使用默认文件名，否则使用BootFile为传送的文件名。（2）比较客户端和服务器的子网地址，判断两者是否在同一个子网内。（3）设定超时处理函数为TftpTimeout 。（4）设置处理接收到的TFTP包的函数为TftpHandler。（5）初始化服务器端口、本机端口、超时次数为0、初始状态为RRQ。（6）调用TftpSend函数发送TFTP读取请求。</li>
<li>TftpSend函数根据TftpState发送不同的包，同时根据包的类型和当前客户端的状态（TftpState）处理接收到的包。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下c语言获取网络接口IP地址]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/19/linuxxia-cyu-yan-huo-qu-wang-luo-jie-kou-ipdi-zhi/"/>
    <updated>2013-07-19T22:34:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/19/linuxxia-cyu-yan-huo-qu-wang-luo-jie-kou-ipdi-zhi</id>
    <content type="html"><![CDATA[<p>在Linux环境下，可以使用以下的代码获取网络的ip地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (gethostname(host, sizeof(host)) &lt; 0) {
</span><span class='line'>    printf("Can't get hostname\n");
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>if ((hp = gethostbyname(host)) == NULL) {
</span><span class='line'>    printf("Can't get host address\n");
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>memcpy((char *) &intaddr, (char *) hp-&gt;h_addr_list[0],
</span><span class='line'>        (size_t) hp-&gt;h_length);</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>在嵌入式系统中，使用goahead的时候， 以上代码是获取不到正确ip地址的，我们可以结合以下两个接口函数去获取需要的ip地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/socket.h&gt;
</span><span class='line'>#include &lt;sys/ioctl.h&gt;
</span><span class='line'>#include &lt;arpa/inet.h&gt;
</span><span class='line'>#include &lt;netinet/in.h&gt;
</span><span class='line'>#include &lt;net/if.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>static int getIfaceName(char *iface_name, int len)
</span><span class='line'>{
</span><span class='line'>    int r = -1;
</span><span class='line'>    int flgs, ref, use, metric, mtu, win, ir;
</span><span class='line'>    unsigned long int d, g, m;    
</span><span class='line'>    char devname[20];
</span><span class='line'>    FILE *fp = NULL;
</span><span class='line'>
</span><span class='line'>    if((fp = fopen("/proc/net/route", "r")) == NULL) {
</span><span class='line'>        perror("fopen error!\n");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if (fscanf(fp, "%*[^\n]\n") &lt; 0) {
</span><span class='line'>        fclose(fp);
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    while (1) {
</span><span class='line'>        r = fscanf(fp, "%19s%lx%lx%X%d%d%d%lx%d%d%d\n",
</span><span class='line'>                 devname, &d, &g, &flgs, &ref, &use,
</span><span class='line'>                 &metric, &m, &mtu, &win, &ir);
</span><span class='line'>        if (r != 11) {
</span><span class='line'>            if ((r &lt; 0) && feof(fp)) {
</span><span class='line'>                break;
</span><span class='line'>            }
</span><span class='line'>            continue;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        strncpy(iface_name, devname, len);
</span><span class='line'>        fclose(fp);
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    fclose(fp);
</span><span class='line'>
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static int getIpAddress(char *iface_name, char *ip_addr, int len)
</span><span class='line'>{
</span><span class='line'>    int sockfd = -1;
</span><span class='line'>    struct ifreq ifr;
</span><span class='line'>    struct sockaddr_in *addr = NULL;
</span><span class='line'>
</span><span class='line'>    memset(&ifr, 0, sizeof(struct ifreq));
</span><span class='line'>    strcpy(ifr.ifr_name, iface_name);
</span><span class='line'>    addr = (struct sockaddr_in *)&ifr.ifr_addr;
</span><span class='line'>    addr-&gt;sin_family = AF_INET;
</span><span class='line'>
</span><span class='line'>    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
</span><span class='line'>        perror("create socket error!\n");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    if (ioctl(sockfd, SIOCGIFADDR, &ifr) == 0) {
</span><span class='line'>        strncpy(ip_addr, inet_ntoa(addr-&gt;sin_addr), len);
</span><span class='line'>        close(sockfd);
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    close(sockfd);
</span><span class='line'>
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, char** argv)
</span><span class='line'>{
</span><span class='line'>    struct in_addr    intaddr;
</span><span class='line'>    char iface_name[20];
</span><span class='line'>
</span><span class='line'>    if(getIfaceName(iface_name, sizeof(iface_name)) &lt; 0) {
</span><span class='line'>        printf("get interface name error!\n");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(getIpAddress(iface_name, (char *) &intaddr, 15) &lt; 0) {
</span><span class='line'>        printf("get interface ip address error!\n");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    printf("address:%s\n",(char *) &intaddr);
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu下编译vlc-android源代码]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/19/ubuntuxia-bian-yi-vlc-androidyuan-dai-ma/"/>
    <updated>2013-07-19T21:18:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/19/ubuntuxia-bian-yi-vlc-androidyuan-dai-ma</id>
    <content type="html"><![CDATA[<p>在编译源码前，需要先安装Android的SDK、NDK以及一些必需的软件，具体安装方法这里就不再详述了，网上可以找到很多相应的文章。安装软件可以执行以下指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ apt-get install  apache-ant(or ant)  autoconf automake autopoint  libtool  gawk (or nawk)
</span><span class='line'>gcc  g++  pkg-config  cmake  patch subversion git</span></code></pre></td></tr></table></div></figure>


<p>ant工具在最后编译android源码生成apk文件会用到，所以需要安装。如果手动安装了ant，需要在环境变量中配置好ant的 path，或者在编译前执行命令<code>export PATH=$PATH:/xxx/ant/bin</code>，保证可以在执行编译的命令行中执行ant命令即可。</p>

<!--more-->


<h1>环境变量配置</h1>

<p>配置ANDROID_SDK（请把path改为自己的路径）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export ANDROID_SDK=/path/to/android-sdk</span></code></pre></td></tr></table></div></figure>


<p>配置ANDROID_NDK</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export ANDROID_NDK=/path/to/android-ndk</span></code></pre></td></tr></table></div></figure>


<p>配置PATH变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=$PATH:$ANDROID_SDK/tools:$ANDROID_SDK/platform-tools</span></code></pre></td></tr></table></div></figure>


<p>配置NEON相关信息（一般编译的时候，会编译NO_NEON和支持NEON两种包出来）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export NO_NEON=1</span></code></pre></td></tr></table></div></figure>


<p>如果设备不支持NEON技术，请务必配置此项；如果机器支持NEON技术，可以不用配置此项。关于NEON的简单信息：根据维基百科英文版ARM架构中的介绍，Cortex-A8架构的设备均支持NEON技术，而在Cortex-A9架构的设备中则是可选的，更多信息请参考 <a href="http://www.arm.com/zh/products/processors/technologies/neon.php">NEON</a> 和 <a href="http://en.wikipedia.org/wiki/ARM_architecture#Advanced_SIMD_.28NEON.29">ARM architecture</a> 。</p>

<p>配置ABI</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export ANDROID_ABI=armeabi-v7a</span></code></pre></td></tr></table></div></figure>


<h1>获取源码</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone git://git.videolan.org/vlc-ports/android.git</span></code></pre></td></tr></table></div></figure>


<h1>编译源码</h1>

<p>下载完成后，进入android文件夹执行<code>sh compile.sh</code>，开始自动编译。如果编译过程中遇到错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>checking host system type… Invalid configuration `arm-linux-androideabi’: system 
</span><span class='line'>`androideabi’ not recognized</span></code></pre></td></tr></table></div></figure>


<p>请在重新编译之前执行以下操作：1. 到 <a href="http://git.savannah.gnu.org/gitweb/?p=config.git;a=tree">这里</a>下载最新的config.guess和config.sub文件；2. 将下载的文件拷贝到/usr/share/misc目录下；3. 重新启动编译。</p>

<p>最后提示BUILD SUCESSFUL，说明编译成功了，在android/vlc-android/bin目录下会生成一个apk文件，可以直接拿来安装。如果想自己调整界面部分，或者添加、修改其它功能，可以直接把项目导入eclipse进行开发。</p>

<h1>出错处理</h1>

<p>如果编译过程中提示缺少某一软件的错误，请根据错误提示安装对应的工具，或者在执行编译之前就把之前提到的工具全部安装好。</p>

<p>出错信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> CC     posix/plugin.lo
</span><span class='line'>../../src/posix/plugin.c: In function 'module_Load':
</span><span class='line'>../../src/posix/plugin.c:50:50: warning: unused parameter 'lazy' [-Wunused-parameter]
</span><span class='line'>  CC     posix/thread.lo
</span><span class='line'>../../src/posix/thread.c:85:5: warning: #warning Monotonic clock not available. Expect timing issues. [-Wcpp]
</span><span class='line'>../../src/posix/thread.c: In function 'vlc_cancel':
</span><span class='line'>../../src/posix/thread.c:830:5: error: implicit declaration of function 'pthread_cancel' [-Werror=implicit-function-declaration]
</span><span class='line'>../../src/posix/thread.c: In function 'vlc_savecancel':
</span><span class='line'>../../src/posix/thread.c:847:5: error: implicit declaration of function 'pthread_setcancelstate' [-Werror=implicit-function-declaration]
</span><span class='line'>../../src/posix/thread.c:847:39: error: 'PTHREAD_CANCEL_DISABLE' undeclared (first use in this function)
</span><span class='line'>../../src/posix/thread.c:847:39: note: each undeclared identifier is reported only once for each function it appears in
</span><span class='line'>../../src/posix/thread.c: In function 'vlc_restorecancel':
</span><span class='line'>../../src/posix/thread.c:867:9: error: 'PTHREAD_CANCEL_DISABLE' undeclared (first use in this function)
</span><span class='line'>../../src/posix/thread.c: In function 'vlc_testcancel':
</span><span class='line'>../../src/posix/thread.c:884:5: error: implicit declaration of function 'pthread_testcancel' [-Werror=implicit-function-declaration]
</span><span class='line'>cc1: some warnings being treated as errors
</span><span class='line'>
</span><span class='line'>make[3]: *** [posix/thread.lo] Error 1
</span><span class='line'>make[3]: Leaving directory `/srv/android/vlc/android/src'
</span><span class='line'>make[2]: *** [all] Error 2
</span><span class='line'>make[2]: Leaving directory `/srv/android/vlc/android/src'
</span><span class='line'>make[1]: *** [all-recursive] Error 1
</span><span class='line'>make[1]: Leaving directory `/srv/android/vlc/android'
</span><span class='line'>make: *** [all] Error 2</span></code></pre></td></tr></table></div></figure>


<p>解决方法：
进入下载的android vlc目录，执行以下指令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd vlc
</span><span class='line'>$ git reset --hard origin
</span><span class='line'>$ git pull origin master
</span><span class='line'>$ git checkout -b android ${TESTED_HASH}
</span><span class='line'>$ git am ../patches/*</span></code></pre></td></tr></table></div></figure>


<p>注：在老的git版本中git checkout并没有-B的选项，所以一开始执行的时候并没有下载android版本的vlc代码，故使用<code>git checkout -b android ${TESTED_HASH}</code>。</p>

<p>出错信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>BUILD FAILED
</span><span class='line'>/usr/local/android-sdk-linux/tools/ant/build.xml:517: Unable to resolve project target 'android-15'
</span><span class='line'>
</span><span class='line'>Total time: 3 seconds
</span><span class='line'>make: *** [vlc-android/bin/VLC-debug.apk] Error 1
</span><span class='line'>rm android-libs/libmedia.c android-libs/libutils.c android-libs/libstagefright.c android-libs/libbinder.c</span></code></pre></td></tr></table></div></figure>


<p>解决方法：
进入到android-sdk-linux/tools目录，执行<code>./android</code>下载Android 4.0.3（API15）的相关文件。</p>

<p>出错信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -f -L -- "http://git.xiph.org/?p=speex.git;a=snapshot;h=HEAD;sf=tgz" &gt; "../../contrib/tarballs/speex-git.tar.gz"
</span><span class='line'>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
</span><span class='line'>                                 Dload  Upload   Total   Spent    Left  Speed
</span><span class='line'>100   814  100   814    0     0    226      0  0:00:03  0:00:03 --:--:-- 23941
</span><span class='line'>../../contrib/src/speex/rules.mak:20: .sum-speex not implemented
</span><span class='line'>touch .sum-speex
</span><span class='line'>touch -r .sum-speex .sum-speexdsp
</span><span class='line'>rm -Rf speex-git
</span><span class='line'>mkdir -p speex-git
</span><span class='line'>zcat "../../contrib/tarballs/speex-git.tar.gz" | (cd speex-git && tar xv --strip-components=1)
</span><span class='line'>
</span><span class='line'>gzip: ../../contrib/tarballs/speex-git.tar.gz: not in gzip format
</span><span class='line'>tar: This does not look like a tar archive
</span><span class='line'>tar: Exiting with failure status due to previous errors
</span><span class='line'>make: *** [speex] Error 2</span></code></pre></td></tr></table></div></figure>


<p>解决方法：
将<code>http://git.xiph.org/?p=speex.git;a=snapshot;h=HEAD;sf=tgz</code>输入到浏览器地址栏中就会开始下载你所需要的文件，然后将相应下载的压缩文件存放于contrib/tarballs/目录下，将名字改成speex-git.tar.gz。若碰到其它的库文件有类似的错误，可采用该办法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[车速的计算]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/19/che-su-de-ji-suan/"/>
    <updated>2013-07-19T00:04:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/19/che-su-de-ji-suan</id>
    <content type="html"><![CDATA[<p>假设你坐在汽车内，你会如何计算汽车在高速路上的平均速度？说说方法，请写下闯入你大脑的第一个想法，希望不要太离谱。没有标准，百家争鸣！</p>

<h1>问题背景</h1>

<p>之前从家里到工作地的总体花费时间是知道的，但我对汽车的实际速度并没有一个概念。坐在车上有时很想知道某一地到我的目的地还需要多少时间。因不太擅长跟陌生人交流，所以自己想一些办法解决。因为高速路上会有到某地还有多少距离的提示，而且相隔几里路后又会有提示，所以采用了距离差除以时间，然后用还剩的距离除以速度，最后得到我想知道的时间。在不堵车的情况下，这种方法是比较有效的，误差不是很大。</p>

<h1>网友的回复</h1>

<p>djsxut：1、看仪表盘在一定时间的行驶路程，除以行驶时间得到平均速度；2、不怕麻烦的话，多次取样，再计算平均速度；3、视力足够好，数数高速中间的小树苗，基本上两颗小数栽种的距离是一定的。</p>

<p>hellioncu：每次看到指示牌标记的公里数，并记下时间，公里数差/时间差——就是速度。</p>

<p>群雄逐鹿中原：装个GPS导航软件。汽车上或手机上都行。</p>

<p>folklore：hire a beauty girl, and ask her: what is our average speed now？</p>

<p>cokeboL：距离/时间，这还能有啥。</p>

<p>cxytz01：超速行驶，交警叔叔会告诉你。</p>

<!--more-->


<p>shan_ghost：空速管……（被pia飞……</p>

<p>一介村夫：超车或被超车的时候问问边上的车。</p>

<p>windoze：上高速到下高速，距离可以查地图，再计个时，一除就好了吧….</p>

<p>cjaizss：直接问司机，现在开到几码了。</p>

<p>fireyu：主车轴上或者变速箱轴上放个频率传感器。采集频率信号向上送。轮子的周长是固定的。根据频率次数算每分钟轮子转1圈的次数可以得到每分钟的瞬时速度。</p>

<p>纵观所有的回答，我补充一个方法：通过查看汽油的使用量，（油量之差/时间）/每升油所能够行驶的距离。</p>

<h1>对回答的评论</h1>

<p>对于网友的回答，我假设大家都是“看到问题后，涌入大脑里的第一个想法”。</p>

<p>djsxut、hellioncu、cokeboL、windoze：都是从工程的问题出发解决问题。djsxut的第一种方法简单有效。hellioncu的方法比djsxut的第二种方法精准些。cokeboL虽然没有说出具体的一种计算方法，但我也认为他也明白的表述了他的思想。cokeboL后面一句“这还能有啥”，我不清楚为何会有这个提问（你说“原来是脑筋急转弯啊”，但我并不认为它是个脑筋急转弯，它并不需要你转，只是看看你的第一个反应是什么）。windoze的方法比较费时了。</p>

<p>群雄逐鹿中原：很好的使用了现有的科技。</p>

<p>folklore、cjaizss：合理的利用了现有环境。folklore非要个beautygirl，不知是否是调侃，^_^。</p>

<p>cxytz01、村长：比较冒险，嘿嘿。</p>

<p>shan_ghost、fireyu：思维比较活跃，扩散的技术人才啊，&hellip;o(∩∩)o&hellip;</p>

<h1>引出的问题</h1>

<p>这些问题是基于以上问题的答案提出的：当看到这个问题时，你是从什么样的角度出发的？从看一个问题的角度，也能反应出一个人的性格及处理事物的方式，你又是怎样的性格或处事方式呢？对于有某种性格和某种方式处理问题的人，你认为他做什么比较适合呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用libevent编写Linux服务]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/18/shi-yong-libeventbian-xie-linuxfu-wu/"/>
    <updated>2013-07-18T19:01:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/18/shi-yong-libeventbian-xie-linuxfu-wu</id>
    <content type="html"><![CDATA[<p>libevent是一个事件触发的网络库，适用于windows、linux、bsd等多种平台，内部使用select、epoll、kqueue等系统调用管理事件机制，著名分布式缓存软件memcached也使用到了该库。</p>

<h1>初始化事件</h1>

<p>首先完成对libenvent的事件初始化和事件驱动模型的选择。在使用多线程的情况下，一般我们需获取所返回的事件根基。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>main_base = event_init();</span></code></pre></td></tr></table></div></figure>


<p>event_init函数返回的是一个event_base对象，该对象包括了事件处理过程中的一些全局变量，其结构为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct event_base {
</span><span class='line'>    const struct eventop *evsel;
</span><span class='line'>    void *evbase;
</span><span class='line'>    int event_count;        /* counts number of total events */
</span><span class='line'>    int event_count_active; /* counts number of active events */
</span><span class='line'>    int event_gotterm;      /* Set to terminate loop */
</span><span class='line'>    int event_break;        /* Set to terminate loop immediately */
</span><span class='line'>    /* active event management */
</span><span class='line'>    struct event_list **activequeues;
</span><span class='line'>    int nactivequeues;
</span><span class='line'>    /* signal handling info */
</span><span class='line'>    struct evsignal_info sig;
</span><span class='line'>    struct event_list eventqueue;
</span><span class='line'>    struct timeval event_tv;
</span><span class='line'>    struct min_heap timeheap;
</span><span class='line'>    struct timeval tv_cache;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h1>添加事件</h1>

<p>事件初始化完毕后，可以使用event_set设置事件，然后使用event_add将其加入。首先完成socket的监听，然后将其加入到事件队列中（这里对所有的异常都不做考虑）。</p>

<p>（1）socket监听</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sockaddr_in listen_addr;
</span><span class='line'>
</span><span class='line'>int port = 10000; //socket监听端口
</span><span class='line'>int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
</span><span class='line'>
</span><span class='line'>memset(&listen_addr, 0, sizeof(listen_addr));
</span><span class='line'>
</span><span class='line'>listen_addr.sin_family = AF_INET;
</span><span class='line'>listen_addr.sin_addr.s_addr = INADDR_ANY;
</span><span class='line'>listen_addr.sin_port = htons(port)
</span><span class='line'>
</span><span class='line'>reuseaddr_on = 1;
</span><span class='line'>
</span><span class='line'>/*支持端口复用*/
</span><span class='line'>setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &reuseaddr_on, sizeof(reuseaddr_on));
</span><span class='line'>
</span><span class='line'>bind(listen_fd, (struct sockaddr *) &listen_addr, sizeof(listen_addr));
</span><span class='line'>listen(listen_fd, 1024);
</span><span class='line'>
</span><span class='line'>/*将描述符设置为非阻塞*/
</span><span class='line'>int flags = fcntl(listen_fd,F_GETFL);
</span><span class='line'>flags |= O_NONBLOCK;
</span><span class='line'>fcntl(listen_fd, F_SETFL, flags);</span></code></pre></td></tr></table></div></figure>


<p>（2）事件设置</p>

<p>socket服务建立后，就可以进行事件设置。使用event_set来设置事件对象，其传入参数包括事件根基(event_base对象)，描述符，事件类型，事件发生时的回调函数，回调函数传入参数。其中事件类型包括EV_READ、EV_WRITE、EV_PERSIST，EV_PERSIST和前两者结合使用，表示该事件为持续事件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct event ev;
</span><span class='line'>
</span><span class='line'>event_set(&ev, listen_fd, EV_READ | EV_PERSIST, accept_handle, (void *)&ev);</span></code></pre></td></tr></table></div></figure>


<p>（3）事件添加与删除</p>

<p>事件设置好后，就可以将其加入事件队列。event_add用来将事件加入，它接受两个参数：要添加的事件和时间的超时值。如果需要将事件删除，可以使用event_del来完成。event_del函数会取消所指定的事件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>event_add(&ev, NULL)</span></code></pre></td></tr></table></div></figure>


<h1>进入事件循环</h1>

<p>libevent提供了多种方式来进入事件循环，常用的是event_dispatch和event_base_loop，前者最后实际是使用当前事件根基来调用event_base_loop。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>event_base_loop(main_base, 0);</span></code></pre></td></tr></table></div></figure>


<h1>处理连接</h1>

<p>已经完成了事件的设置、事件的添加并进入到了事件循环，但是当事件发生时又如何处理呢？ 当连接建立时回调函数accept_handle会自动的得到调用。对于缓冲区的读写在非阻塞式网络编程中是一个难以处理的问题，幸运的是libevent提供了bufferevent和evbuf来替我们完成该项工作。这里我们采用bufferevent来处理。</p>

<p>（1）生成bufferevent对象</p>

<p>使用bufferevent_new对象来生成bufferevent对象，并分别指定读、写、连接错误时的处理函数和函数传入参数。</p>

<p>（2）设置读取量</p>

<p>bufferevent的读事件激活以后，即使用户没有读取完bufferevent缓冲区中的数据, bufferevent读事件也不会再次被激活。因为bufferevent的读事件是由其所监控的描述符的读事件激活的，只有描述符可读，读事件才会被激活。可通过设置wm_read.high来控制bufferevent从描述符缓冲区中读取的数据量。</p>

<p>（3）将事件加入事件队列</p>

<p>和前面一样，在事件设置好后，需将事件加入到事件队列中， 不过bufferevent的有自己专门的加入函数bufferevent_base_set和激活函数bufferevent_enable。bufferevent接收两个参数事件根基和事件对象，前者用来指定事件将加入到哪个事件根基中，后者说明需将那个bufferevnet事件加入。在bufferevent初始化完毕后，可以使用bufferevent_enable和bufferevent_disable反复的激活与禁止事件，其接收参数为事件对象和事件标志。其中标志参数为EV_READ和EV_WRITE。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void accept_handle(const int sfd, const short event, void *arg)
</span><span class='line'>{
</span><span class='line'>    struct sockaddr_in addr;
</span><span class='line'>
</span><span class='line'>    socklen_t addrlen = sizeof(addr);
</span><span class='line'>
</span><span class='line'>    int fd = accept(sfd, (struct sockaddr *) &addr, &addrlen); //处理连接
</span><span class='line'>
</span><span class='line'>    buf_ev = bufferevent_new(fd,   buffered_on_read, NULL, NULL, fd)
</span><span class='line'>    buf_ev-&gt;wm_read.high = 4096
</span><span class='line'>    bufferevent_base_set(main_base, buf_ev);
</span><span class='line'>    bufferevent_enable(buf_ev, EV_READ);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>读取缓冲区</h1>

<p>当缓冲区读就绪时会自动激活前面注册的缓冲区读函数，我们可以使用bufferevent_read函数来读取缓冲区，bufferevent_read函数参数分别为:所需读取的事件缓冲区，读入数据的存放地，希望读取的字节数。函数返回实际读取的字节数。注意：即时缓冲区未读完，事件也不会再次被激活（除非再次有数据）。因此此处需反复读取直到全部读取完毕。</p>

<h1>写回客户端</h1>

<p>bufferevent系列函数不但支持读取缓冲区，而且支持写缓冲区（即将结果返回给客户端）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void buffered_on_read(struct bufferevent *bev, void * arg){
</span><span class='line'>    char buffer[4096]
</span><span class='line'>
</span><span class='line'>    ret = bufferevent_read(bev, &buffer, 4096);
</span><span class='line'>    bufferevent_write(bef, (void *)&buffer, 4096);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>异步事件处理示例</h1>

<p>利用libevent编写服务端程序，主要有4部分。
（1）创建主通知链base</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>base = event_base_new();</span></code></pre></td></tr></table></div></figure>


<p>（2）创建要监听的事件，并将其加入到主通知链中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void*)base);
</span><span class='line'>event_add(listener_event, NULL);
</span><span class='line'>event_free( listener_event ); //释放由event_new申请的结构体</span></code></pre></td></tr></table></div></figure>


<p>
（3）主循环</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>event_base_dispatch(base);</span></code></pre></td></tr></table></div></figure>


<p>（4）释放</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>event_base_free(base);</span></code></pre></td></tr></table></div></figure>


<p>以下程序中do_read, do_write是异步的，为了解决了异步之间的问题，程序使用了state这个结构体变量将do_read和do_write联系起来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;netinet/in.h&gt;
</span><span class='line'>#include &lt;sys/socket.h&gt;
</span><span class='line'>#include &lt;event2/event.h&gt;
</span><span class='line'>#include &lt;assert.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;errno.h&gt;
</span><span class='line'>#include &lt;fcntl.h&gt;
</span><span class='line'>
</span><span class='line'>#define MAX_LINE 16384
</span><span class='line'>#define PORT 9999
</span><span class='line'>
</span><span class='line'>void do_read(evutil_socket_t fd, short events, void *arg);
</span><span class='line'>void do_write(evutil_socket_t fd, short events, void *arg);
</span><span class='line'>
</span><span class='line'>struct fd_state {
</span><span class='line'>    char buffer[MAX_LINE];
</span><span class='line'>    size_t buffer_used;
</span><span class='line'>
</span><span class='line'>    size_t n_written;
</span><span class='line'>    size_t write_upto;
</span><span class='line'>
</span><span class='line'>    struct event *read_event;
</span><span class='line'>    struct event *write_event;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct fd_state *alloc_fd_state(struct event_base *base, evutil_socket_t fd)
</span><span class='line'>{
</span><span class='line'>    struct fd_state *state =
</span><span class='line'>     (struct fd_state *)malloc(sizeof(struct fd_state));
</span><span class='line'>    if (!state) {
</span><span class='line'>        return NULL;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    state-&gt;read_event =
</span><span class='line'>     event_new(base, fd, EV_READ | EV_PERSIST, do_read, state);
</span><span class='line'>    if (!state-&gt;read_event) {
</span><span class='line'>        free(state);
</span><span class='line'>        return NULL;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    state-&gt;write_event =
</span><span class='line'>     event_new(base, fd, EV_WRITE | EV_PERSIST, do_write, state);
</span><span class='line'>    if (!state-&gt;write_event) {
</span><span class='line'>        event_free(state-&gt;read_event);
</span><span class='line'>        free(state);
</span><span class='line'>        return NULL;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    assert(state-&gt;write_event);
</span><span class='line'>
</span><span class='line'>    return state;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void free_fd_state(struct fd_state *state)
</span><span class='line'>{
</span><span class='line'>    event_free(state-&gt;read_event);
</span><span class='line'>    event_free(state-&gt;write_event);
</span><span class='line'>    free(state);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void do_read(evutil_socket_t fd, short events, void *arg)
</span><span class='line'>{
</span><span class='line'>    struct fd_state *state = arg;
</span><span class='line'>    char buf[1024];
</span><span class='line'>    int i;
</span><span class='line'>    ssize_t result;
</span><span class='line'>    while (1) {
</span><span class='line'>        // assert(state-&gt;write_event);
</span><span class='line'>        result = recv(fd, buf, sizeof(buf), 0);
</span><span class='line'>        if (result &lt;= 0)
</span><span class='line'>            break;
</span><span class='line'>        printf("[%s][%d]buf=[%s]len=[%d]\n", __FILE__, __LINE__, buf,
</span><span class='line'>         result);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    memcpy(state-&gt;buffer, "reply", sizeof("reply"));
</span><span class='line'>    assert(state-&gt;write_event);
</span><span class='line'>    event_add(state-&gt;write_event, NULL);
</span><span class='line'>    state-&gt;write_upto = state-&gt;buffer_used;
</span><span class='line'>
</span><span class='line'>    if (result == 0) {
</span><span class='line'>        free_fd_state(state);
</span><span class='line'>    } else if (result &lt; 0) {
</span><span class='line'>        if (errno == EAGAIN)    // XXXX use evutil macro
</span><span class='line'>            return;
</span><span class='line'>        perror("recv");
</span><span class='line'>        free_fd_state(state);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void do_write(evutil_socket_t fd, short events, void *arg)
</span><span class='line'>{
</span><span class='line'>    struct fd_state *state = arg;
</span><span class='line'>
</span><span class='line'>    //while (state-&gt;n_written &lt; state-&gt;write_upto)
</span><span class='line'>    {
</span><span class='line'>        //ssize_t result = send(fd, state-&gt;buffer + state-&gt;n_written,
</span><span class='line'>        //state-&gt;write_upto - state-&gt;n_written, 0);
</span><span class='line'>        ssize_t result =
</span><span class='line'>         send(fd, state-&gt;buffer, strlen(state-&gt;buffer), 0);
</span><span class='line'>        if (result &lt; 0) {
</span><span class='line'>            if (errno == EAGAIN)    // XXX use evutil macro
</span><span class='line'>                return;
</span><span class='line'>            free_fd_state(state);
</span><span class='line'>            return;
</span><span class='line'>        }
</span><span class='line'>        assert(result != 0);
</span><span class='line'>        state-&gt;n_written += result;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //if (state-&gt;n_written == state-&gt;buffer_used)
</span><span class='line'>    {
</span><span class='line'>        state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = 1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    event_del(state-&gt;write_event);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void do_accept(evutil_socket_t listener, short event, void *arg)
</span><span class='line'>{
</span><span class='line'>    struct event_base *base = arg;
</span><span class='line'>    struct sockaddr_storage ss;
</span><span class='line'>    socklen_t slen = sizeof(ss);
</span><span class='line'>
</span><span class='line'>    int fd = accept(listener, (struct sockaddr *)&ss, &slen);
</span><span class='line'>    if (fd &lt; 0) {        // XXXX eagain??
</span><span class='line'>        perror("accept");
</span><span class='line'>    } else if (fd &gt; FD_SETSIZE) {
</span><span class='line'>        close(fd);    // XXX replace all closes with EVUTIL_CLOSESOCKET */
</span><span class='line'>    } else {
</span><span class='line'>        struct fd_state *state;
</span><span class='line'>        evutil_make_socket_nonblocking(fd);
</span><span class='line'>        state = alloc_fd_state(base, fd);
</span><span class='line'>
</span><span class='line'>        assert(state);    /*XXX err */
</span><span class='line'>        assert(state-&gt;write_event);
</span><span class='line'>        event_add(state-&gt;read_event, NULL);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>    evutil_socket_t listener;
</span><span class='line'>    struct sockaddr_in sin;
</span><span class='line'>    struct event_base *base;
</span><span class='line'>    struct event *listener_event;
</span><span class='line'>
</span><span class='line'>    setvbuf(stdout, NULL, _IONBF, 0);
</span><span class='line'>    
</span><span class='line'>    base = event_base_new();
</span><span class='line'>    if (!base)
</span><span class='line'>        return -1;        /*XXXerr */
</span><span class='line'>
</span><span class='line'>    sin.sin_family = AF_INET;
</span><span class='line'>    sin.sin_addr.s_addr = 0;
</span><span class='line'>    sin.sin_port = htons(PORT);
</span><span class='line'>
</span><span class='line'>    listener = socket(AF_INET, SOCK_STREAM, 0);
</span><span class='line'>    evutil_make_socket_nonblocking(listener);
</span><span class='line'>
</span><span class='line'>#ifndef WIN32
</span><span class='line'>    {
</span><span class='line'>        int one = 1;
</span><span class='line'>        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &one,
</span><span class='line'>             sizeof(one));
</span><span class='line'>    }
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>    if (bind(listener, (struct sockaddr *)&sin, sizeof(sin)) &lt; 0) {
</span><span class='line'>        perror("bind");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if (listen(listener, 16) &lt; 0) {
</span><span class='line'>        perror("listen");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    listener_event =
</span><span class='line'>     event_new(base, listener, EV_READ | EV_PERSIST, do_accept,
</span><span class='line'>         (void *)base);
</span><span class='line'>    /*XXX check it */
</span><span class='line'>    event_add(listener_event, NULL);
</span><span class='line'>    event_base_dispatch(base);
</span><span class='line'>    event_base_free(base);
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链栈]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/15/lian-zhan/"/>
    <updated>2013-07-15T21:49:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/15/lian-zhan</id>
    <content type="html"><![CDATA[<p>栈是限制在表的一端进行插入和删除运算的线性表。通常称插入、删除的这一端为栈顶，另一端称为栈底；当表中没有元素时称为空栈；栈为后进先出的线性表，简称为LIFO表；栈的修改是按后进先出的原则进行；每次删除的总是当前栈中最新的元素（即最后插入的元素），而最先插入的被放在栈的底部，要到最后才能删除。</p>

<h1>链栈结点</h1>

<p>出栈与入栈是栈的最主要操作，当无法预见栈所需大小时，往往需要采用链栈的方式。在链栈中，不需要像单链表一样需要头结点。链栈的结构如下图所示：</p>

<p><img src="http://txgcwm.github.io/images/2013/7/lian-zhan/stacknode.png" alt=" stacknode " /></p>

<p>可将其结构定义为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef char SElemType
</span><span class='line'>
</span><span class='line'>typedef struct StackNode
</span><span class='line'>{
</span><span class='line'>    SElemType data;//根据实际需要定义数据类型
</span><span class='line'>    struct StackNode *next;
</span><span class='line'>}StackNode,*LinkStackPtr;
</span><span class='line'>
</span><span class='line'>typedef struct LinkStack
</span><span class='line'>{
</span><span class='line'>    LinkStackPtr top;//指向栈链顶部
</span><span class='line'>    int count;//用以判断栈是否为空，可初始化为0
</span><span class='line'>}LinkStack;</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h1>进栈</h1>

<p>能够进栈的前提是已成功建立栈空间。进栈函数所需的参数主要是指向栈顶的指针和入栈的内容，因此可定义为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int Push(LinkStack *pS, SElemType e);</span></code></pre></td></tr></table></div></figure>


<p>进栈操作的过程如下图所示:</p>

<p><img src="http://txgcwm.github.io/images/2013/7/lian-zhan/stackpush.png" alt=" stackpush " /></p>

<p>Step1：开辟内存，将需要入栈的元素压入栈；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
</span><span class='line'>s-&gt;data = e;</span></code></pre></td></tr></table></div></figure>


<p>Step2：更改指针；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>s-&gt;next = pS-&gt;top; //新结点的next指向原来栈顶
</span><span class='line'>pS-&gt;top = s; //链栈新的top指针指向新建立的结点</span></code></pre></td></tr></table></div></figure>


<p>Step3：更改栈状态（累计入栈元素个数）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pS-&gt;count++;</span></code></pre></td></tr></table></div></figure>


<h1>出栈</h1>

<p>出栈之前需要判断当前栈的状态，如果栈元素个数为零，则是空栈，无法进行出栈操作。出栈操作函数同样需要两个参数，一是指向链栈的指针，二是弹出的栈元素，因此定义为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int Pop(LinkStackPtr *pS, SElemType *e); //之所以是*e，是为了在函数结束后可以取得该弹出元素</span></code></pre></td></tr></table></div></figure>


<p>出栈操作过程如下图所示：</p>

<p><img src="http://txgcwm.github.io/images/2013/7/lian-zhan/stackpop.png" alt=" stackpop " /></p>

<p>Step1：获取弹出元素；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*e = pS-&gt;top-&gt;data;</span></code></pre></td></tr></table></div></figure>


<p>Step2：top指针指向栈顶；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>p = pS-&gt;top ;
</span><span class='line'>pS-&gt;top = p-&gt;next;//LinkStackPtr p;</span></code></pre></td></tr></table></div></figure>


<p>Step3：释放结点；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>free(p);</span></code></pre></td></tr></table></div></figure>


<p>Step4：更改栈状态。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pS-&gt;count--;</span></code></pre></td></tr></table></div></figure>


<h1>测试程序</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>typedef char SElemType;
</span><span class='line'>
</span><span class='line'>typedef struct StackNode {
</span><span class='line'>    SElemType data;
</span><span class='line'>    struct StackNode *next;
</span><span class='line'>} StackNode, *LinkStackPtr;
</span><span class='line'>
</span><span class='line'>typedef struct LinkStack {
</span><span class='line'>    LinkStackPtr top;
</span><span class='line'>    int count;
</span><span class='line'>} LinkStack;
</span><span class='line'>
</span><span class='line'>void InitialStack(LinkStack * L)
</span><span class='line'>{
</span><span class='line'>    L-&gt;top = NULL;
</span><span class='line'>    L-&gt;count = 0;
</span><span class='line'>    
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int StackEmpty(LinkStack * pS)
</span><span class='line'>{
</span><span class='line'>    return (!pS-&gt;count);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int Push(LinkStack * pS, SElemType e)
</span><span class='line'>{
</span><span class='line'>    LinkStackPtr s = (LinkStackPtr) malloc(sizeof(StackNode));
</span><span class='line'>    if(s == NULL) {
</span><span class='line'>        printf("no enough memory!\n");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>    s-&gt;data = e;
</span><span class='line'>    s-&gt;next = pS-&gt;top;
</span><span class='line'>    pS-&gt;top = s;
</span><span class='line'>    pS-&gt;count++;
</span><span class='line'>    
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int Pop(LinkStack * pS, SElemType * e)
</span><span class='line'>{
</span><span class='line'>    LinkStackPtr p = NULL;
</span><span class='line'>    
</span><span class='line'>    if (StackEmpty(pS)) {
</span><span class='line'>        printf("stack is empty！\n");
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    *e = pS-&gt;top-&gt;data;
</span><span class='line'>    p = pS-&gt;top;
</span><span class='line'>    pS-&gt;top = p-&gt;next;
</span><span class='line'>    free(p);
</span><span class='line'>    pS-&gt;count--;
</span><span class='line'>    
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void PrintStackLink(LinkStack * pS)
</span><span class='line'>{
</span><span class='line'>    int i;
</span><span class='line'>    LinkStackPtr L = NULL;
</span><span class='line'>    
</span><span class='line'>    L = pS-&gt;top;
</span><span class='line'>    if (StackEmpty(pS)) {
</span><span class='line'>        printf("stack is empty！\n");
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    for (i = 0; i &lt; (pS-&gt;count); i++) {
</span><span class='line'>        printf("%c\n", L-&gt;data);
</span><span class='line'>        L = L-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>    char getch;
</span><span class='line'>    char outch;
</span><span class='line'>    LinkStack myStack;
</span><span class='line'>    
</span><span class='line'>    InitialStack(&myStack);
</span><span class='line'>    
</span><span class='line'>    printf("请输入压入栈的数据（char型），输入#结束:\n");
</span><span class='line'>    scanf("%c", &getch);
</span><span class='line'>    while (getch != '#') {
</span><span class='line'>        Push(&myStack, getch);
</span><span class='line'>        scanf("%c", &getch);
</span><span class='line'>    }
</span><span class='line'>    printf("栈链内容为：\n");
</span><span class='line'>    PrintStackLink(&myStack);
</span><span class='line'>
</span><span class='line'>    while (!StackEmpty(&myStack)) {
</span><span class='line'>        Pop(&myStack, &outch);
</span><span class='line'>        printf("弹出内容为：%c\n", outch);
</span><span class='line'>    }
</span><span class='line'>    PrintStackLink(&myStack);
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pkg-config的使用]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/14/pkg-configde-shi-yong/"/>
    <updated>2013-07-14T11:22:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/14/pkg-configde-shi-yong</id>
    <content type="html"><![CDATA[<p>pkg-config是向用户和应用程序提供相应库的路径、版本号等信息的程序。比如使用pkg-config查看gcc的CFLAGS参数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pkg-config --libs --cflags opencv
</span><span class='line'>-I/usr/include/opencv  -lopencv_core -lopencv_imgproc -lopencv_highgui -lopencv_ml 
</span><span class='line'>-lopencv_video -lopencv_features2d -lopencv_calib3d -lopencv_objdetect 
</span><span class='line'>-lopencv_contrib -lopencv_legacy -lopencv_flann</span></code></pre></td></tr></table></div></figure>


<p>以上就是我们用gcc编译连接时CFLAGS的参数。因此当我们需要编译连接某个库时，只需要把上面那行加入gcc的参数里面即可。这也是configure的作用，它会检查你需要的包，产生相应的信息。</p>

<p>pkg-config从包名为xxx.pc这个文件中查找相应的信息。缺省情况下，首先在prefix/lib/pkgconfig/（在linux上其路径为/usr/lib/pkconfig/）中查找相关包（比如opencv）对应的文件（opencv.pc）。若是没有找到，它也会到PKG_CONFIG_PATH这个环境变量所指定的路径下去找。若是还没有找到，它就会报错，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Package opencv was not found in the pkg-config search path.
</span><span class='line'>Perhaps you should add the directory containing `opencv.pc'
</span><span class='line'>to the PKG_CONFIG_PATH environment variable
</span><span class='line'>No package 'opencv' found</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>设置环境变量PKG_CONFIG_PATH方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export PKG_CONFIG_PATH=/cv/lib:$PKG_CONFIG_PATH</span></code></pre></td></tr></table></div></figure>


<p>查看opencv.pc文件的内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat opencv.pc 
</span><span class='line'># Package Information for pkg-config
</span><span class='line'>
</span><span class='line'>prefix=/usr
</span><span class='line'>exec_prefix=${prefix}
</span><span class='line'>libdir=${exec_prefix}/lib
</span><span class='line'>includedir_old=${prefix}/include/opencv
</span><span class='line'>includedir_new=${prefix}/include
</span><span class='line'>
</span><span class='line'>Name: OpenCV
</span><span class='line'>Description: Open Source Computer Vision Library
</span><span class='line'>Version: 2.3.1
</span><span class='line'>Libs: -L${libdir} -lopencv_core -lopencv_imgproc -lopencv_highgui -lopencv_ml 
</span><span class='line'>-lopencv_video -lopencv_features2d -lopencv_calib3d -lopencv_objdetect -lopencv_contrib 
</span><span class='line'>-lopencv_legacy -lopencv_flann
</span><span class='line'>Cflags: -I${includedir_old} -I${includedir_new}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下删除文本文件中的所有空行]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/13/linuxxia-shan-chu-wen-ben-wen-jian-zhong-de-suo-you-kong-xing/"/>
    <updated>2013-07-13T22:20:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/13/linuxxia-shan-chu-wen-ben-wen-jian-zhong-de-suo-you-kong-xing</id>
    <content type="html"><![CDATA[<p>很多情况下文本文件中会出现许多空行，这些都是我们不想要的。大多时候我们会选择手工删除，这样显然太麻烦，况且当文件行数很多的时候，其麻烦程度是不能忍受的。所以需要一个工具，可以达到删除所有空行的目的，并且最好还能一次处理多个文件。以下是Linux下的一个脚本文件，支持一次处理多个文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>TEMP_F="del.lines.$$"
</span><span class='line'>
</span><span class='line'>usage()
</span><span class='line'>{
</span><span class='line'>  echo "Usage: $0 filename [filename...]"
</span><span class='line'>  exit -1
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>if [ $# -eq 0 ] ; then
</span><span class='line'>  usage
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>while [ $# -gt 0 ]
</span><span class='line'>do
</span><span class='line'>  FILE_NAME=$1
</span><span class='line'>
</span><span class='line'>  case $1 in 
</span><span class='line'>      --help)
</span><span class='line'>          usage
</span><span class='line'>      ;;
</span><span class='line'>
</span><span class='line'>      *)
</span><span class='line'>          if [ -f $1 ] ; then
</span><span class='line'>              sed '/^$/d' $FILE_NAME &gt; $TEMP_F
</span><span class='line'>              mv $TEMP_F $FILE_NAME
</span><span class='line'>          else
</span><span class='line'>              echo "$0 can not find this file: $1"
</span><span class='line'>          fi      
</span><span class='line'>      ;;
</span><span class='line'>  esac
</span><span class='line'>
</span><span class='line'>  shift
</span><span class='line'>done</span></code></pre></td></tr></table></div></figure>


<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Base64编码解码算法]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/11/base64bian-ma-jie-ma-suan-fa/"/>
    <updated>2013-07-11T23:09:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/11/base64bian-ma-jie-ma-suan-fa</id>
    <content type="html"><![CDATA[<p>Base64使用ascii码子集的64个字符，即大小写的26个英文字母，0～9，＋，/。编码基于3个字符，每个字符用8位二进制表示，一共24位，再分为4四组，每组6位表示一个Base64值（例如0就是A，27就是b）。Base64值如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
</span><span class='line'>'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
</span><span class='line'>'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
</span><span class='line'>'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
</span><span class='line'>'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
</span><span class='line'>'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
</span><span class='line'>'w', 'x', 'y', 'z', '0', '1', '2', '3',
</span><span class='line'>'4', '5', '6', '7', '8', '9', '+', '/',</span></code></pre></td></tr></table></div></figure>


<p>如果被加密的字符串每3个一组，还剩1或2个字符，使用特殊字符&#8221;=&ldquo;补齐。例如编码只有2个字符“me”，m的ascii是109，e的是101，用二进制表示分别是01101101、01100101，连接起来就是0110110101100101，再按6位分为一组：011011、010110、010100（不足6位补0），ascii分别是27、22、 20，即Base64值为bWU，不足4字用＝补齐，因此bWU＝就me的Base64值。</p>

<!--more-->


<p>在<a href="https://github.com/dwjackson/basenc">这里</a>可以找到一个c语言的base32/base64开源库。以下是goahead中base64编码解码的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static char_t    map64[] = {
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
</span><span class='line'>    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
</span><span class='line'>    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
</span><span class='line'>    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static char_t    alphabet64[] = {
</span><span class='line'>    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
</span><span class='line'>    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
</span><span class='line'>    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
</span><span class='line'>    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
</span><span class='line'>    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
</span><span class='line'>    'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
</span><span class='line'>    'w', 'x', 'y', 'z', '0', '1', '2', '3',
</span><span class='line'>    '4', '5', '6', '7', '8', '9', '+', '/',
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>/*********************************** Code *************************************/
</span><span class='line'>/*
</span><span class='line'> *    Decode a buffer from "string" and into "outbuf"
</span><span class='line'> */
</span><span class='line'>int websDecode64(char_t *outbuf, char_t *string, int outlen)
</span><span class='line'>{
</span><span class='line'>    unsigned long    shiftbuf;
</span><span class='line'>    char_t            *cp, *op;
</span><span class='line'>    int                c, i, j, shift;
</span><span class='line'>
</span><span class='line'>    op = outbuf;
</span><span class='line'>    *op = '\0';
</span><span class='line'>    cp = string;
</span><span class='line'>    while (*cp && *cp != '=') {
</span><span class='line'>        /*
</span><span class='line'>         *        Map 4 (6bit) input bytes and store in a single long (shiftbuf)
</span><span class='line'>         */
</span><span class='line'>        shiftbuf = 0;
</span><span class='line'>        shift = 18;
</span><span class='line'>        for (i = 0; i &lt; 4 && *cp && *cp != '='; i++, cp++) {
</span><span class='line'>            c = map64[*cp & 0xff];
</span><span class='line'>            if (c == -1) {
</span><span class='line'>                error(E_L, E_LOG, T("Bad string: %s at %c index %d"), string,
</span><span class='line'>                      c, i);
</span><span class='line'>                return -1;
</span><span class='line'>            }
</span><span class='line'>            shiftbuf = shiftbuf | (c &lt;&lt; shift);
</span><span class='line'>            shift -= 6;
</span><span class='line'>        }
</span><span class='line'>        /*
</span><span class='line'>         *        Interpret as 3 normal 8 bit bytes (fill in reverse order).
</span><span class='line'>         *        Check for potential buffer overflow before filling.
</span><span class='line'>         */
</span><span class='line'>        --i;
</span><span class='line'>        if ((op + i) &gt;= &outbuf[outlen]) {
</span><span class='line'>            gstrcpy(outbuf, T("String too big"));
</span><span class='line'>            return -1;
</span><span class='line'>        }
</span><span class='line'>        for (j = 0; j &lt; i; j++) {
</span><span class='line'>            *op++ = (char_t) ((shiftbuf &gt;&gt; (8 * (2 - j))) & 0xff);
</span><span class='line'>        }
</span><span class='line'>        *op = '\0';
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/******************************************************************************/
</span><span class='line'>/*
</span><span class='line'> *    Encode a buffer from "string" into "outbuf"
</span><span class='line'> */
</span><span class='line'>void websEncode64(char_t *outbuf, char_t *string, int outlen)
</span><span class='line'>{
</span><span class='line'>    unsigned long    shiftbuf;
</span><span class='line'>    char_t            *cp, *op;
</span><span class='line'>    int                x, i, j, shift;
</span><span class='line'>
</span><span class='line'>    op = outbuf;
</span><span class='line'>    *op = '\0';
</span><span class='line'>    cp = string;
</span><span class='line'>    while (*cp) {
</span><span class='line'>        /*
</span><span class='line'>         *        Take three characters and create a 24 bit number in shiftbuf
</span><span class='line'>         */
</span><span class='line'>        shiftbuf = 0;
</span><span class='line'>        for (j = 2; j &gt;= 0 && *cp; j--, cp++) {
</span><span class='line'>            shiftbuf |= ((*cp & 0xff) &lt;&lt; (j * 8));
</span><span class='line'>        }
</span><span class='line'>        /*
</span><span class='line'>         *        Now convert shiftbuf to 4 base64 letters. The i,j magic calculates
</span><span class='line'>         *        how many letters need to be output.
</span><span class='line'>         */
</span><span class='line'>        shift = 18;
</span><span class='line'>        for (i = ++j; i &lt; 4 && op &lt; &outbuf[outlen] ; i++) {
</span><span class='line'>            x = (shiftbuf &gt;&gt; shift) & 0x3f;
</span><span class='line'>            *op++ = alphabet64[(shiftbuf &gt;&gt; shift) & 0x3f];
</span><span class='line'>            shift -= 6;
</span><span class='line'>        }
</span><span class='line'>        /*
</span><span class='line'>         *        Pad at the end with '='
</span><span class='line'>         */
</span><span class='line'>        while (j-- &gt; 0) {
</span><span class='line'>            *op++ = '=';
</span><span class='line'>        }
</span><span class='line'>        *op = '\0';
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Linux提供了命令行方式的base64编码和解码。</p>

<ul>
<li>将字符串str+换行 编码为base64字符串输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo "str" | base64</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将字符串str编码为base64字符串输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo -n "str" | base64</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从指定的文件file中读取数据，编码为base64字符串输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ base64 file</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从标准输入中读取已经进行base64编码的内容，解码输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ base64 -d </span></code></pre></td></tr></table></div></figure>


<ul>
<li>从标准输入中读取已经进行base64编码的内容，解码输出。加上-i参数，忽略非字母表字符，比如换行符。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ base64 -d -i</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将base64编码的字符串str+换行 解码输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo "str" | base64 -d</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将base64编码的字符串str解码输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo -n "str" | base64 -d</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从指定的文件file中读取base64编码的内容，解码输出。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ base64 -d file </span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[minilzo无损压缩库测试例子（二）]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/10/minilzowu-sun-ya-suo-ku-ce-shi-li-zi-%28er-%29/"/>
    <updated>2013-07-10T23:01:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/10/minilzowu-sun-ya-suo-ku-ce-shi-li-zi-(er-)</id>
    <content type="html"><![CDATA[<p>在minilzo无损压缩库中提供了一个测试例子（文件名为testmini.c），对该示例作一个分析。如果我们要使用该库中的四个基本函数，首先必须包含以下的头文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "minilzo.h"</span></code></pre></td></tr></table></div></figure>


<p>其中，lzo_init()函数包含在以下的头文件中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "lzoconf.h"</span></code></pre></td></tr></table></div></figure>


<p>lzoconf.h已包含在minilzo.h中，所以在写测试例子时只需包含minilzo.h头文件即可。</p>

<p>将原始数据存放在in中且定义其长度为IN_LEN，压缩后的数据存放在out中且定义其长度为OUT_LEN。因为输入块可能是不可压缩的，所以我们必须提供多一点的输出空间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if defined(__LZO_STRICT_16BIT)
</span><span class='line'>#define IN_LEN      (8*1024u)
</span><span class='line'>#elif defined(LZO_ARCH_I086) && !defined(LZO_HAVE_MM_HUGE_ARRAY)
</span><span class='line'>#define IN_LEN      (60*1024u)
</span><span class='line'>#else
</span><span class='line'>#define IN_LEN      (128*1024ul)
</span><span class='line'>#endif
</span><span class='line'>#define OUT_LEN     (IN_LEN + IN_LEN / 16 + 64 + 3)
</span><span class='line'>
</span><span class='line'>static unsigned char __LZO_MMODEL in  [ IN_LEN ];
</span><span class='line'>static unsigned char __LZO_MMODEL out [ OUT_LEN ];</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>压缩需要工作缓冲区，内存分配以‘lzo_align_t’（而不是‘char’）为单元，以确保它对齐。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define HEAP_ALLOC(var,size) \
</span><span class='line'>    lzo_align_t __LZO_MMODEL var [ ((size) + (sizeof(lzo_align_t) - 1)) / \
</span><span class='line'>                                    sizeof(lzo_align_t) ]
</span><span class='line'>
</span><span class='line'>static HEAP_ALLOC(wrkmem, LZO1X_1_MEM_COMPRESS);</span></code></pre></td></tr></table></div></figure>


<p>Step 1: 初始化lzo库。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (lzo_init() != LZO_E_OK)
</span><span class='line'>{
</span><span class='line'>    printf("internal error - lzo_init() failed !!!\n");
</span><span class='line'>    printf("(this usually indicates a compiler bug - try recompiling\n
</span><span class='line'>                without optimizations, and enable '-DLZO_DEBUG' for diagnostics)\n");
</span><span class='line'>    return 3;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Step 2: 准备将要被压缩的输入块，在这个例子程序中我们只是简单的写入“0”。在实际的应用中，应该写入真正需要压缩的数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>in_len = IN_LEN;
</span><span class='line'>lzo_memset(in,0,in_len);</span></code></pre></td></tr></table></div></figure>


<p>Step 3: 使用LZO1X-1将in中的数据压缩到out中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>r = lzo1x_1_compress(in,in_len,out,&out_len,wrkmem);
</span><span class='line'>if (r == LZO_E_OK)
</span><span class='line'>    printf("compressed %lu bytes into %lu bytes\n",
</span><span class='line'>        (unsigned long) in_len, (unsigned long) out_len);
</span><span class='line'>else
</span><span class='line'>{
</span><span class='line'>    /* this should NEVER happen */
</span><span class='line'>    printf("internal error - compression failed: %d\n", r);
</span><span class='line'>    return 2;
</span><span class='line'>}
</span><span class='line'>/* check for an incompressible block */
</span><span class='line'>if (out_len &gt;= in_len)
</span><span class='line'>{
</span><span class='line'>    printf("This block contains incompressible data.\n");
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Step 4: 将out中的数据解压缩到in中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new_len = in_len;
</span><span class='line'>r = lzo1x_decompress(out,out_len,in,&new_len,NULL);
</span><span class='line'>if (r == LZO_E_OK && new_len == in_len)
</span><span class='line'>    printf("decompressed %lu bytes back into %lu bytes\n",
</span><span class='line'>        (unsigned long) out_len, (unsigned long) in_len);
</span><span class='line'>else
</span><span class='line'>{
</span><span class='line'>    /* this should NEVER happen */
</span><span class='line'>    printf("internal error - decompression failed: %d\n", r);
</span><span class='line'>    return 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>minilzo支持多个平台，在编译的时候应该设置编译选项。在Linux系统中，编译该测试例程使用以下指令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ make gcc
</span><span class='line'>gcc  -s -Wall -O2 -fomit-frame-pointer -o testmini testmini.c minilzo.c</span></code></pre></td></tr></table></div></figure>


<p>以下为运行结果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./testmini 
</span><span class='line'>
</span><span class='line'>LZO real-time data compression library (v2.06, Aug 12 2011).
</span><span class='line'>Copyright (C) 1996-2011 Markus Franz Xaver Johannes Oberhumer
</span><span class='line'>All Rights Reserved.
</span><span class='line'>
</span><span class='line'>compressed 131072 bytes into 598 bytes
</span><span class='line'>decompressed 598 bytes back into 131072 bytes
</span><span class='line'>
</span><span class='line'>miniLZO simple compression test passed.</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[minilzo无损压缩库介绍（一）]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/minilzowu-sun-ya-suo-ku-jie-shao-%28%5B%3F%5D-%29/"/>
    <updated>2013-07-07T23:32:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/minilzowu-sun-ya-suo-ku-jie-shao-([?]-)</id>
    <content type="html"><![CDATA[<p>在网络上传输大批量数据的时候，网络的传输速度是固定的（比如100 Mb的以太网实际测量的传输速度大概在10 MB/s左右），而想要在固定时间内传输更多容量的数据，最常见的解决方案是——在传输之前通过一定的算法把数据的容量压缩，然后通过网络传输，对端接收到数据之后再通过相应的算法进行解压还原。如果“压缩的时间 + 压缩后数据的传输时间 + 解压缩的时间 &lt; 未压缩数据的传输时间”，就相当于提高了单位时间内的传输能力，拓宽了网络传输的带宽。</p>

<h1>minilzo库使用介绍</h1>

<p>lzo是一个开源的无损压缩c语言库，其优点是压缩/解压缩比较迅速且占用内存小等特点。具体可查看 <a href="http://www.oberhumer.com/opensource/lzo/">这里</a>，提供了比较全的lzo库和一个minilzo库。minilzo库提供了1个c文件和3个头文件，解压后的目录树如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>minilzo-2.06$ tree
</span><span class='line'>.
</span><span class='line'>├── COPYING
</span><span class='line'>├── lzoconf.h
</span><span class='line'>├── lzodefs.h
</span><span class='line'>├── Makefile
</span><span class='line'>├── minilzo.c
</span><span class='line'>├── minilzo.h
</span><span class='line'>├── README.LZO
</span><span class='line'>└── testmini.c</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>常用的有4个API（在使用的时候包含minilzo.h即可）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* lzo_init() should be the first function you call.
</span><span class='line'> * Check the return code !
</span><span class='line'> *
</span><span class='line'> * lzo_init() is a macro to allow checking that the library and the
</span><span class='line'> * compiler's view of various types are consistent.
</span><span class='line'> */
</span><span class='line'>#define lzo_init() __lzo_init_v2(LZO_VERSION,(int)sizeof(short),(int)sizeof(int),\
</span><span class='line'>    (int)sizeof(long),(int)sizeof(lzo_uint32),(int)sizeof(lzo_uint),\
</span><span class='line'>    (int)lzo_sizeof_dict_t,(int)sizeof(char *),(int)sizeof(lzo_voidp),\
</span><span class='line'>    (int)sizeof(lzo_callback_t))
</span><span class='line'>
</span><span class='line'>/* compression */
</span><span class='line'>LZO_EXTERN(int)
</span><span class='line'>lzo1x_1_compress        ( const lzo_bytep src, lzo_uint  src_len,
</span><span class='line'>                                lzo_bytep dst, lzo_uintp dst_len,
</span><span class='line'>                                lzo_voidp wrkmem );
</span><span class='line'>
</span><span class='line'>/* decompression */
</span><span class='line'>LZO_EXTERN(int)
</span><span class='line'>lzo1x_decompress        ( const lzo_bytep src, lzo_uint  src_len,
</span><span class='line'>                                lzo_bytep dst, lzo_uintp dst_len,
</span><span class='line'>                                lzo_voidp wrkmem /* NOT USED */ );
</span><span class='line'>
</span><span class='line'>/* safe decompression with overrun testing */
</span><span class='line'>LZO_EXTERN(int)
</span><span class='line'>lzo1x_decompress_safe   ( const lzo_bytep src, lzo_uint  src_len,
</span><span class='line'>                                lzo_bytep dst, lzo_uintp dst_len,
</span><span class='line'>                                lzo_voidp wrkmem /* NOT USED */ );</span></code></pre></td></tr></table></div></figure>


<p>minilzo库使用十分简单，在压缩和解压缩之前先调用lzo_init函数进行初始化，返回LZO_E_OK表示初始化成功。压缩数据时调用lzo1x_1_compress函数；解压数据时调用lzo1x_decompress函数或lzo1x_decompress_safe函数，这两个函数的区别是——lzo1x_decompress_safe函数会对解压缩数据的有效性进行验证，验证通过才会进行解压缩操作，而lzo1x_decompress函数则不会这么做，数据不是有效时就会产生“段错误”，建议使用lzo1x_decompress_safe函数。以下是这些函数的详细操作说明：</p>

<ul>
<li>lzo1x_1_compress函数进行压缩数据操作，需要5个参数：压缩的数据、压缩数据的大小、压缩后数据的缓冲区、压缩缓冲区的大小、压缩工作缓冲区。压缩数据成功之后会返回LZO_E_OK。第4个参数传进去的是用来指示存放压缩后数据缓冲区的大小，执行成功之后通过指针返回的结果是压缩后的数据实际使用的缓冲区大小（即压缩后的数据大小）。压缩后需要的数据缓冲区大小的上限是可以根据未压缩数据大小进行计算的，其公式为：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>output_size = input_size + (input_size / 16) + 64 + 3；</span></code></pre></td></tr></table></div></figure>


<p>第5个参数是压缩的时候需要使用的工作缓冲区，缓冲的生成在minilzo库提供的测试例程中有相关的宏定义。</p>

<ul>
<li>lzo1x_decompress和lzo1x_decompress_safe函数进行数据的解压缩操作，需要5个参数：解压缩的数据、解压缩数据的大小、解压缩后数据的存放缓冲区、原始数据（未压缩数据）大小、解压缩工作缓冲区（不需要，可以置为NULL）。执行成功之后返回LZO_E_OK。第4个参数传进去的值是原始的未压缩数据的大小，执行成功之后通过指针返回的是实际解压缩后数据的大小。所以压缩之后的数据在传输的时候需要将原始数据的大小和压缩后数据一起传输，否则对方在解压缩的时候将无法解压。可以定义一个数据结构专门用来传输，这些数据在传输的时候相当于有效载荷：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct{
</span><span class='line'>    unsigned long org_data_size;    /* 原始的未压缩数据大小 */
</span><span class='line'>    unsigned char data[MAX_DATA_SIZE];  /* 压缩之后的数据 */
</span><span class='line'>}COMP_DATA, *P_COMP_DATA;</span></code></pre></td></tr></table></div></figure>


<p></p>

<h1>压缩/解压缩时间的计算</h1>

<p>在压缩/解压缩数据之前，可以通过gettimeofday函数获取当前的系统时间，接着进行相关操作，完成之后再次获取系统时间，对2次获取的时间进行减操作即可得到实际操作所花费的时间。以下是计算操作所需花费时间的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned long interval_ms = 0;       /* 间隔的毫秒数 */
</span><span class='line'>struct timeval stime, etime;
</span><span class='line'>
</span><span class='line'>gettimeofday(&stime, NULL);
</span><span class='line'>
</span><span class='line'>/* TODO:Do compression or decompression */
</span><span class='line'>
</span><span class='line'>gettimeofday(&etime, NULL);
</span><span class='line'>
</span><span class='line'>interval_ms = (etime.tv_sec - stime.tv_sec) * 1000.0 + \
</span><span class='line'>                    （etime.tv_usec - stime.tv_usec）/ 1000.0;</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PF_NETLINK应用实例:NETLINK_KOBJECT_UEVENT的实现]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/pf-netlinkying-yong-shi-li-netlink-kobject-ueventde-shi-xian/"/>
    <updated>2013-07-07T17:43:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/pf-netlinkying-yong-shi-li-netlink-kobject-ueventde-shi-xian</id>
    <content type="html"><![CDATA[<p>udev的文档介绍：</p>

<ol>
<li><p>dynamic replacement for /dev。作为devfs的替代者，传统的devfs不能动态分配major和minor的值，而major和minor非常有限，很快就会用完了。udev能够像DHCP动态分配IP地址一样去动态分配major和minor。</p></li>
<li><p>device naming。提供设备命名持久化的机制。传统设备命名方式不具直观性，像/dev/hda1这样的名字肯定没有boot_disk这样的名字直观。udev能够像DNS解析域名一样去给设备指定一个有意义的名称。</p></li>
<li><p>API to access info about current system devices 。提供了一组易用的API去操作sysfs，避免重复实现同样的代码。</p></li>
</ol>


<!--more-->


<p>用户空间的程序与设备通信的方法，主要有以下几种方式：</p>

<ol>
<li><p>通过ioperm获取操作IO端口的权限，然后用inb/inw/ inl/ outb/outw/outl等函数，避开设备驱动程序，直接去操作IO端口。</p></li>
<li><p>用ioctl函数去操作/dev目录下对应的设备，这是设备驱动程序提供的接口。像键盘、鼠标和触摸屏等输入设备一般都是这样做的。</p></li>
<li><p>用write/read/mmap去操作/dev目录下对应的设备，这也是设备驱动程序提供的接口。像framebuffer等都是这样做的。</p></li>
</ol>


<p>上面的方法在大多数情况下都可以正常工作，但是对于热插拨(hotplug)的设备，比如像U盘就有点困难了，因为你不知道“什么时候设备插上了，什么时候设备拔掉了”。这就是所谓的hotplug问题了。</p>

<p>处理hotplug传统的方法是在内核中执行一个称为hotplug的程序，相关参数通过环境变量传递，再由hotplug通知其它关注hotplug事件的应用程序。这样做不但效率低下，而且也不那么优雅。新的方法是采用NETLINK实现，这是一种特殊类型的socket，专门用于内核空间与用户空间的异步通信。下面的这个例子可以监听来自内核hotplug事件。</p>

<pre><code>#include &lt;linux/netlink.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;


#define UEVENT_BUFFER_SIZE 2048

static int init_hotplug_sock(void)
{
    int ret;
    int s = -1;
    const int buffersize = 1024;
    struct sockaddr_nl snl;

    bzero(&amp;snl, sizeof(struct sockaddr_nl));
    snl.nl_family = AF_NETLINK;
    snl.nl_pid = getpid();
    snl.nl_groups = 1;

    s = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
    if (s == -1) {
        perror("socket");
        return -1;
    }
    setsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;buffersize, sizeof(buffersize));

    ret = bind(s, (struct sockaddr *)&amp;snl, sizeof(struct sockaddr_nl));
    if (ret &lt; 0) {
        perror("bind");
        close(s);
        return -1;
    }

    return s;
}

int main(int argc, char *argv[])
{
    int hotplug_sock = init_hotplug_sock();

    while (1) {    
        char buf[UEVENT_BUFFER_SIZE * 2] = { 0 };

        recv(hotplug_sock, &amp;buf, sizeof(buf), 0);
        printf("%s\n", buf);

        /* USB 设备的插拔会出现字符信息，通过比较不同的信息确定特定设备的插拔，在这添加比较代码 */
    }

    return 0;
}
</code></pre>

<p>编译：</p>

<pre><code>$ gcc -g hotplug.c -o hotplug
</code></pre>

<p>执行：</p>

<pre><code>$ ./hotplug
remove@/devices/pci0000:00/0000:00:1d.7/usb2/2-1/2-1:1.0
remove@/devices/pci0000:00/0000:00:1d.7/usb2/2-1
add@/devices/pci0000:00/0000:00:1d.7/usb2/2-1
add@/devices/pci0000:00/0000:00:1d.7/usb2/2-1/2-1:1.0
</code></pre>

<p>udev的主体部分在udevd.c文件中，它主要监控来自4个文件描述符的事件/消息，并做出处理：</p>

<ol>
<li>来自客户端的控制消息。这通常由udevcontrol命令通过地址为/org/kernel/udev/udevd的本地socket，向udevd发送控制消息。其中消息类型有：</li>
</ol>


<pre><code>UDEVD_CTRL_STOP_EXEC_QUEUE  //停止处理消息队列
UDEVD_CTRL_START_EXEC_QUEUE //开始处理消息队列
UDEVD_CTRL_SET_LOG_LEVEL //设置LOG的级别
UDEVD_CTRL_SET_MAX_CHILDS //设置最大子进程数限制
UDEVD_CTRL_SET_MAX_CHILDS_RUNNING //设置最大运行子进程数限制(遍历proc目录下所有进程，根据session的值判断) 
UDEVD_CTRL_RELOAD_RULES //重新加载配置文件
</code></pre>


<ol>
<li><p>来自内核的hotplug事件。如果有事件来源于hotplug，它读取该事件，创建一个udevd_uevent_msg对象，记录当前的消息序列号，设置消息的状态为EVENT_QUEUED，然后放入running_list和exec_list两个队列中，稍后再进行处理。</p></li>
<li><p>来自signal handler中的事件。signal handler是异步执行的，即使有signal产生，主进程的select并不会唤醒，为了唤醒主进程的select，它建立了一个管道，在signal handler中，向该管道写入长度为1个子节的数据，这样就可以唤醒主进程的select了。</p></li>
<li><p>来自配置文件变化的事件。udev通过文件系统inotify功能，监控其配置文件目录/etc/udev/rules.d，一旦该目录中文件有变化，它就重新加载配置文件。</p></li>
</ol>


<p>其中最主要的事件当然是来自内核的hotplug事件，如何处理这些事件是udev的关键。udev本身并不知道如何处理这些事件，也没有必要知道，因为它只实现机制，而不实现策略。事件的处理是由配置文件决定的，这些配置文件即所谓的rule。</p>

<p>关于rule的编写方法可以参考《writing_udev_rules》，udev_rules.c实现了对规则的解析。在规则中，可以让外部应用程序处理某个事件，这有两种方式：一种是直接执行命令，通常是让modprobe去加载驱动程序，或者让mount去加载分区；另外一种是通过本地socket发送消息给某个应用程序。</p>

<p>在udevd.c的udev_event_process函数中，我们可以看到：如果RUN参数以”socket:”开头则认为是发到socket，否则认为是执行指定的程序。</p>

<p>下面的规则是执行指定程序：</p>

<pre><code>60-pcmcia.rules: RUN+="/sbin/modprobe pcmcia"
</code></pre>

<p>下面的规则是通过socket发送消息：</p>

<pre><code>90-hal.rules:RUN+="socket:/org/freedesktop/hal/udev_event"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[求两个整数的最大公约数]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/qiu-liang-ge-zheng-shu-de-zui-da-gong-yue-shu/"/>
    <updated>2013-07-07T17:10:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/qiu-liang-ge-zheng-shu-de-zui-da-gong-yue-shu</id>
    <content type="html"><![CDATA[<p>辗转相除法又名欧几里德算法（Euclidean algorithm），用于求两个正整数的最大公因子的算法。它是已知最古老的算法，可追溯至公元前300年。它首次出现于欧几里德的《几何原本》中，而在中国则可以追溯至东汉出现的《九章算术》。</p>

<p>设两数为a、b(b&lt;a)，求它们的最大公约数的步骤如下：用b除a，得a＝bq&hellip;r1(0≤r1)。若r1=0，则(a，b)＝b；若r1≠0，则再用r1除b，得b＝r1q&hellip;r2(0≤r2)。若r2＝0，则(a，b)＝r1，若r2≠0，则继续用r2除r1,&hellip;如此下去，直到能整除为止。其最后一个非零余数即为(a，b)。</p>

<!--more-->


<p>辗转相除法是利用以下性质来确定两个正整数a和b的最大公因子的：</p>

<p>1、若r是a÷b的余数,则gcd(a,b) = gcd(b,r)；</p>

<p>2、若b为0，则其最大公因子为a。</p>

<p>另一种置换实现方式：</p>

<p>1、r为a÷b所得余数（0≤r&lt;b）。若r=0，算法结束，b即为答案；</p>

<p>2、若r不为0，则互换：置a←b，b←r，并返回第一步。</p>

<p>递归实现：</p>

<pre><code>int gcd(int a,int b)
{
    if(b == 0)
        return a;
    else
        return gcd(b, a%b);
}
</code></pre>

<p>对递归实现的改进：</p>

<pre><code>int gcd(int a,int b)
{
    return b ? gcd(b, a%b) : a;
}
</code></pre>

<p>置换实现：</p>

<pre><code>int gcd( int a, int b)
{
    int temp;

     while(b) {
        temp = b;
        b = a%b;
        a = temp;      
     }

     return a;
}
</code></pre>

<p>对置换实现的改进：</p>

<pre><code>int gcd(int a, int b)
{
    while(b)
        b = a%b + 0/(a=b);

    return a;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下C语言伪随机数编程]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/linuxxia-cyu-yan-wei-sui-ji-shu-bian-cheng/"/>
    <updated>2013-07-07T12:50:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/linuxxia-cyu-yan-wei-sui-ji-shu-bian-cheng</id>
    <content type="html"><![CDATA[<p>在日常生活中，我们经常会遇到随机数（比如丢骰子，抓阄，抽签等等），那么在程序中如何实现随机数呢？现在很多操作系统内核都会提供相应的api，通过获取一些计算机运行时的原始信息（如内存，电压，物理信号等等，它们的值在一个时间段可以保证是唯一的）来生成随机数。下文介绍如何使用rand、srand来生成伪随机数。</p>

<h1>rand产生伪随机数</h1>

<p>Linux中rand()会返回一随机数值，范围在0至RAND_MAX 间，其中RAND_MAX定义在stdlib.h，其值为2147483647。</p>

<p>以下例子利用rand函数生成随机数。</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define LOOP_TIMES    5

int main(int argc, char *argv[])
{
    int i;

    for(i=0; i&lt; LOOP_TIMES; i++)
        printf("%d ", rand());

    printf("\n");

    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>$ ./rand
1804289383 846930886 1681692777 1714636915 1957747793 
$ ./rand
1804289383 846930886 1681692777 1714636915 1957747793
</code></pre>

<p>从以上的结果可以看出，rand两次产生的随机数是一样的，之所以这样是因为“在调用rand函数产生随机数前没有先利用srand()设好随机数种子”。如果未设随机数种子，rand()在调用时会自动设随机数种子为1。</p>

<!--more-->


<h1>srand设置随机数种子</h1>

<p>要想每次运行得到的随机数不同，我们还要设置随机数种子。既然要设置随机数种子，那我们就使用srand()来设置rand()产生随机数时的随机数种子。参数seed必须是个整数，通常可以利用geypid()或time(NULL)的返回值来当做seed。如果每次seed都设相同值，rand()所产生的随机数值每次就会一样。</p>

<p>以下例子设置随机数种子然后生成随机数。</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

#define LOOP_TIMES    5

int main(int argc, char *argv[])
{
    int i;

    srand((unsigned int) time(NULL));

    for(i=0; i&lt;LOOP_TIMES; i++)
        printf("%d ", rand());

    printf("\n");

    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>$ ./rand
1943306114 679448932 319436844 1922998560 1458181616 
$ ./rand
1789418334 999331839 757991171 363979956 882919632 
</code></pre>

<h1>合理利用随机数</h1>

<p>运行结果是不是不同了，但这么大的数对我们来说也没有多大意义，又怎么利用这些这些随机数呢？我们可对它进行范围化分，这样就可以产生我们想要范围内的数。</p>

<p>产生一定范围随机数的通用表示公式：a + rand() % n，其中的a是起始值，n是整数的范围；</p>

<p>要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;</p>

<p>要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a，另一种表示为a + (int)b * rand() / (RAND_MAX + 1)；</p>

<p>要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;</p>

<p>要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。</p>

<p>以下例子生成［0，26］之间的数，使用了语句“nu = 0 + (int)( 26.0 *rand()/(RAND_MAX + 1.0));”来获取a到b之间的随机整数。</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

#define LOOP_TIMES    5

int main(int argc, char *argv[])
{
    int i, nu;

    srand((unsigned int) time(NULL));

    for(i=0; i&lt; LOOP_TIMES; i++) {
        nu = 0 + (int)( 26.0 *rand()/(RAND_MAX + 1.0));
        printf("%d ", nu);
    }

    printf("\n");

    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>$ ./rand
6 21 20 22 7
$ ./rand
4 12 25 3 13
</code></pre>

<h1>生成随机字符串</h1>

<p>以下例子用来生成一个指定长度的随机字符串。</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

#define BUFFER_LENGTH 257

int main(int argc, char *argv[])
{
    int leng = 128 ;
    int i, nu;
    char buffer[BUFFER_LENGTH];

    printf("Please Input length for the String, Default is 128, The Maxest legth is 256:");
    fgets(buffer, BUFFER_LENGTH, stdin);
    buffer[strlen(buffer)-1] = '\0' ;

    if(buffer[0] != '\0')
        leng = atoi(buffer);

    srand((unsigned int)time(NULL));
    bzero(buffer, BUFFER_LENGTH);

    for (i= 0; i&lt; leng; i++)
        buffer[i] = 'a' + ( 0+ (int)(26.0 *rand()/(RAND_MAX + 1.0)));

    buffer[strlen(buffer)] = '\0';

    printf("The randm String is [ %s ]\n", buffer);
    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>$ ./rand
Please Input length for the String, Default is 128, The Maxest legth is 256:8
The randm String is [ rdekbnxj ]
$ ./rand
Please Input length for the String, Default is 128, The Maxest legth is 256:36
The randm String is [ bvfrbvvhdcuwdoarefcrkytsntltawpbsusu ]
</code></pre>

<p>注意，需要使用bzero(buffer, 257)这条语句将缓存清空，否则生成的随机字符串中可能就会出现乱码的情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下PDF文件的操作与转换]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/linuxxia-pdfwen-jian-de-cao-zuo-yu-zhuan-huan/"/>
    <updated>2013-07-07T11:21:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/linuxxia-pdfwen-jian-de-cao-zuo-yu-zhuan-huan</id>
    <content type="html"><![CDATA[<p>在Linux中常常涉及到多种文档格式（如doc、txt、html、rtf等等），为了方便文件传递，就可能需要在各种格式之间进行转换。下面介绍几个命令行下的工具，用于将pdf文件转换成其它我们需要的文件格式。</p>

<h1>Pdftk</h1>

<p>如果说PDF是电子纸张，那么pdftk就是电子起钉器、打孔机、粘合剂、解密指环和X光镜片。pdftk是一个简单的工具，可以对PDF文档进行各种日常操作，让你简单而自由地操作PDF。它不需要Acrobat，并且可以运行在Linux,Windows,Mac OS X,FreeBSD和Solaris上。在Debian/Ubuntu中你可以通过apt安装pdftk:</p>

<pre><code>$ sudo aptitude install pdftk
</code></pre>

<!--more-->


<p>将两个或更多个PDF合并成一个新文档：</p>

<pre><code>$ pdftk 1.pdf 2.pdf 3.pdf cat output 123.pdf
</code></pre>

<p>或者使用句柄:</p>

<pre><code>$ pdftk A=1.pdf B=2.pdf cat A B output 12.pdf
</code></pre>

<p>或者使用通配符:</p>

<pre><code>$ pdftk *.pdf cat output combined.pdf
</code></pre>

<p>将多个PDF中选定的页面分离出来并形成一个新文档：</p>

<pre><code>$ pdftk A=one.pdf B=two.pdf cat A1-7 B1-5 A8 output combined.pdf
</code></pre>

<p>将PDF的第一页顺时针旋转90度：</p>

<pre><code>$ pdftk in.pdf cat 1E 2-end output out.pdf
</code></pre>

<p>将整个PDF文档的页面旋转180度：</p>

<pre><code>$ pdftk in.pdf cat 1-endS output out.pdf
</code></pre>

<p>用128位强度（默认）对一个PDF进行加密，保留所有权利（默认）：</p>

<pre><code>$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foopass
</code></pre>

<p>同上，唯一例外的是需要密码才能打开这个PDF：</p>

<pre><code>$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foo user_pw baz
</code></pre>

<p>同上，例外的是允许打印(在PDF被打开以后)：</p>

<pre><code>$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foo user_pw baz allow printing
</code></pre>

<p>加密一个PDF：</p>

<pre><code>$ pdftk secured.pdf input_pw foopass output unsecured.pdf
</code></pre>

<p>合并两个文件，其中一个是加密的 (输出是不加密的)：</p>

<pre><code>$ pdftk A=secured.pdf mydoc.pdf input_pw A=foopass cat output combined.pdf
</code></pre>

<p>解压PDF页面流，以便可以在文本编辑器中编辑PDF代码：</p>

<pre><code>$ pdftk mydoc.pdf output mydoc.clear.pdf uncompress
</code></pre>

<p>修复一个PDF被破坏的XREF表和流长度 (如果可能的话)：</p>

<pre><code>$ pdftk broken.pdf output fixed.pdf
</code></pre>

<p>将单个PDF文档拆分成一个个页面，并且将相关数据报告到doc_data.txt：</p>

<pre><code>$ pdftk mydoc.pdf burst
</code></pre>

<p>报告PDF文档的元数据、书签和页面标签：</p>

<pre><code>$ pdftk mydoc.pdf dump_data output report.txt
</code></pre>

<h1>Poppler</h1>

<p>Poppler是一个基于xpdf-3.0代码基础的PDF渲染库。 Poppler-utils软件包包括了pdftops (PDF到PostScript的转换器), pdfinfo (PDF文档信息提取器), pdfimages (PDF图像提取器), pdftohtml (PDF到HTML的转换器), pdftotext (PDF到text的转换器), 以及pdffonts (PDF字体分析器)。Debian/Ubuntu用户可以通过apt安装poppler:</p>

<pre><code>$ sudo aptitude install poppler-utils
</code></pre>

<p>将可移植文档格式(PDF)文件转换成纯文本：</p>

<pre><code>$ pdftotext example.pdf example.txt
</code></pre>

<p>如果文本文件未指定, pdftotext将file.pdf转换成file.txt。如果文本文件是?-’，则文本会被送到标准输出。</p>

<p>转换第3到7页(包括3和7)使用:</p>

<pre><code>$ pdftotext -f 3 -l 7 example.pdf example.txt
</code></pre>

<p>只提取第3页：</p>

<pre><code>$ pdftotext -f 3 -l 3 example.pdf example.txt
</code></pre>

<p>下面的命令可以维持原始的物理布局并按阅读顺序输出文本。如果不想插入页面分隔符你可以设置-nopgbrk选项。如果PDF文件有密码保护，可以设置-opw (拥有者密码)或者-upw (用户密码)选项。</p>

<pre><code>$ pdftotext -layout example.pdf example.txt
</code></pre>

<p>pdftohtml是一个将pdf文档转换成html的程序，它在当前工作目录中产生输出。pdf文件转换成html:</p>

<pre><code>$ pdftohtml file.pdf file.html
</code></pre>

<p>如果你想要看到图形，需要使用-c(也就是“complex”) 选项:</p>

<pre><code>$ pdftohtml -c file.pdf file.html
</code></pre>

<h1>Pdfimages</h1>

<p>Pdfimages从可移植文档格式(PDF)文件中提取图片，保存为可移植像素图(PPM), 可移植位图(PBM), 或者JPEG文件。Pdfimages读取PDF文件，扫描一个或多个页面，并将每一个图像写入一个名为image-root-nnn.xxx的PPM、PBM或者JPEG文件，其中nnn是图像编号，xxx是图像类型(.ppm, .pbm, .jpg)。Pdfimages从PDF文件提取原始图像数据，不做任何额外的变化。任何PDF内容流里的旋转，剪切，颜色反转等动作都被忽略。</p>

<p>从example.pdf提取所有的图像，图像会被保存为PPM格式：</p>

<pre><code>$ pfdimages example.pdf exampleimage
</code></pre>

<p>使用-j选项将图像保存为JPG格式：</p>

<pre><code>$ pfdimages -j example.pdf exampleimage
</code></pre>

<p>使用-f和-l选项制定起始页和结束页。为了扫描第3至7页(包括3和7)使用：</p>

<pre><code>$ pfdimages -f 3 -l 7 example.pdf exampleimage
</code></pre>

<p>只扫描指定的某一页使用:</p>

<pre><code>$ pfdimages -f 3 -l 3 example.pdf exampleimage
</code></pre>

<p>如果PDF文件有密码保护使用-opw和-upw选项:
-opw 拥有者密码
-upw 用户密码</p>

<h1>ImageMagick</h1>

<p>如果要将PDF转换到图像，首先你的机器上必须已经安装ImageMagick。要在Debian/Ubuntu上安装ImageMagick可以运行下面的命令：</p>

<pre><code>$ sudo aptitude install imagemagick
</code></pre>

<p>要将pdf文件转换成图像使用‘convert‘命令:</p>

<pre><code>$ convert doc.pdf doc.jpeg
</code></pre>

<p>转换成tiff</p>

<pre><code>$ convert doc.pdf doc.tiff
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内核中关于isdigit和min（max）的实现]]></title>
    <link href="http://txgcwm.github.io/blog/2013/07/07/nei-he-zhong-guan-yu-isdigithe-min%28max%29de-shi-xian/"/>
    <updated>2013-07-07T10:41:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/07/07/nei-he-zhong-guan-yu-isdigithe-min(max)de-shi-xian</id>
    <content type="html"><![CDATA[<p>isdigit、min、max等函数或宏定义是我们平时最常使用的，但往往没有更多的去思考它们的效率及其副作用。下面让我们来看看，内核是如何实现它们的。</p>

<h1>isdigit</h1>

<p>在标准C中，isdigit函数可以用来判断字符是否为0~9之间的数字。比如：</p>

<pre><code>int a = isdigit('1');
int b = isdigit('a');
int c = isdigit(3);
</code></pre>

<p>可以使用宏定义去实现这个简单的函数，如下所示：</p>

<pre><code>#define isdigit(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
</code></pre>

<!--more-->


<p>Linux内核中isdigit的实现，其代码如下所示：</p>

<pre><code>#define _U 0x01 /* upper */
#define _L 0x02 /* lower */
#define _D 0x04 /* digit */
#define _C 0x08 /* cntrl */
#define _P 0x10 /* punct */
#define _S 0x20 /* white space (space/lf/tab) */
#define _X 0x40 /* hex digit */
#define _SP 0x80 /* hard space (0x20) */

extern unsigned char _ctype[];

#define isdigit(c) ((_ctype+1)[c]&amp;(_D))

unsigned char _ctype[] = {0x00, /* EOF */
 _C,_C,_C,_C,_C,_C,_C,_C, /* 0-7 */
 _C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C, /* 8-15 */
 _C,_C,_C,_C,_C,_C,_C,_C, /* 16-23 */
 _C,_C,_C,_C,_C,_C,_C,_C, /* 24-31 */
 _S|_SP,_P,_P,_P,_P,_P,_P,_P, /* 32-39 */
 _P,_P,_P,_P,_P,_P,_P,_P, /* 40-47 */
 _D,_D,_D,_D,_D,_D,_D,_D, /* 48-55 */
 _D,_D,_P,_P,_P,_P,_P,_P, /* 56-63 */
 _P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U, /* 64-71 */
 _U,_U,_U,_U,_U,_U,_U,_U, /* 72-79 */
 _U,_U,_U,_U,_U,_U,_U,_U, /* 80-87 */
 _U,_U,_U,_P,_P,_P,_P,_P, /* 88-95 */
 _P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L, /* 96-103 */
 _L,_L,_L,_L,_L,_L,_L,_L, /* 104-111 */
 _L,_L,_L,_L,_L,_L,_L,_L, /* 112-119 */
 _L,_L,_L,_P,_P,_P,_P,_C, /* 120-127 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 128-143 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 144-159 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 160-175 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 176-191 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 192-207 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 208-223 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 224-239 */
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; /* 240-255 */
</code></pre>

<p>字符&#8217;0&#8217;~&lsquo;9&#8217;对应的ASCII码为48~57，映射到上面的<em>ctype数组，相应的位置全是</em>D，<em>D&amp;</em>D则为真，其它的字符则判断为false。对不同种类的字符进行了分类，并使用唯一的二进制来进行标识，使用&amp;和|保证了不同类别的字符不会同时满足两种分类的条件。</p>

<h1>min和max</h1>

<p>实现min和max这两个函数，可以有三种形式：1）定义宏；2）定义函数； 3）定义inline函数。以定义宏举例，一般都是以下形式：</p>

<pre><code>#define min(x,y) ((x)&gt;(y)?(y):(x))
#define max(x,y) ((x)&gt;(y)?(x):(y))
</code></pre>

<p>但是上面的写法是有副作用的。比如输入：</p>

<pre><code>minval = min(x++, y);
</code></pre>

<p>替换宏之后，代码变成：</p>

<pre><code>minval = ((x++)&gt;(y)? (y):(x++))
</code></pre>

<p>可以看出，如果x是最小值，那么它加了两次，很明显是不对的。</p>

<p>Linux内核实现min和max宏：</p>

<pre><code>/*
 * min()/max() macros that also do
 * strict type-checking.. See the
 * "unnecessary" pointer comparison.
 */
 #define min(x, y) ({ \
         typeof(x) _min1 = (x); \
         typeof(y) _min2 = (y); \
         (void) (&amp;_min1 == &amp;_min2); \
         _min1 &lt; _min2 ? _min1 : _min2; })

 #define max(x, y) ({ \
         typeof(x) _max1 = (x); \
         typeof(y) _max2 = (y); \
         (void) (&amp;_max1 == &amp;_max2); \
         _max1 &gt; _max2 ? _max1 : _max2; })
</code></pre>

<p>1、typeof(x)的用途：得到x的类型信息，比如typeof(10) 为int， typeof(1.0)为double。</p>

<p>2、({})的用途：一句语句，({ 和 })之间可以有很多表达式，它的值为最后一个表达式的值。</p>

<p>3、(void)(&amp;<em>x == &amp;</em>y);这一句的作用：判断<em>x和</em>y的类型是否一样。如果是不同的类型，编译器会报“warning: comparison of distinct pointer types lacks a cast”的警告信息。</p>

<p>其实，内核的宏定义就是先引入和x及y同样类型的两个临时变量，然后对临时变量进行求最大值或者最小值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[公交小事]]></title>
    <link href="http://txgcwm.github.io/blog/2013/05/19/gong-jiao-xiao-shi/"/>
    <updated>2013-05-19T16:05:00+08:00</updated>
    <id>http://txgcwm.github.io/blog/2013/05/19/gong-jiao-xiao-shi</id>
    <content type="html"><![CDATA[<p><img class="right" src="http://www.gscn.com.cn/upload/image/2009/10/21/1256085698750.jpg" width="300" height="386" title="Place Kitten #3" ></p>

<p>很舒适的坐在公交后面的位置上，拿着手机看完了一篇文章，退出了应用看了一下时间是8：19，不到百米的距离就要到站了。正当我暗自庆幸能够很早到公司的时候，传来一个女人A的声音“你偷我东西”。A推了女人B一把，B也不甘示弱，迅速还击，两个女人拳打脚踢，几个乘客也因激烈的战斗而离开自身的座位。现在我才明白比男人的战争更恐怖的是女人间的战争。</p>

<p>司机见此状况，将车子停在了路的一旁，开始调解。司机问A有没有东西被偷，是否要报警，A和B都同意报警，司机和B都打电话报了警。司机接着又补充道“警察未来之前谁也不准离开”，这个做法全国的公交应该都这样吧，个人不是反对而是赞成。</p>

<p>在这间隙，A诉说着她事件：她站在靠下车门的地方，B站在另一测，另外一个女人C站在她的同一侧，她刚好在B和C的中间，她本能的感觉到有手深入她的手提包在偷她的东西，她怀疑B和C在合谋偷她的东西。接着发生了前面提到的那一幕。A也补充到她上车的时候手提包的拉链是拉紧的。B也解释道没有偷A的东西，同时也不认识C。由于当时是低着头看手机，加上距离比较的远，我并不清楚事情到底是否有偷窃的事情。</p>

<!--more-->


<p>过了一小会儿，警察还是没有来到。很多人就问司机能不能让那两个女人下车，让她们独自等待警察，然后送我们去上班，司机拒绝了这些不合理的请求。在这种情况下，他们就转向了A，让她们自己下去。其他人的声音我听得不是很清楚，我身边的一个女人的话大概是这样的：“东西有没有被偷呢？没有的话就算了。要叫警察的话，你们自己下去等，浪费别人的时间。我们又没有偷你的东西，对我们凶什么凶了，神经病的！”车上80%的人表示的都是类似的声音。面对如此喧嚣的声音，我的前座的一个男人和前座的前座的一个男人都劝大家稍安误噪，要多体谅。</p>

<p>女人A面对这些攻势，有些激动，大声的回应道：“要不是我不让你们走，是司机不让你们走。幸好东西没有被偷，偷了的话你们就高兴了是吧？大家上班不就是为了挣钱嘛，要是东西被偷了还挣钱干嘛。要是你们被偷了会怎样？我已经被偷了两个iphone4s了。”</p>

<p>过了30分钟左右，警察来了。警察看了司机的证件，同时要了B的证件，让她们几个当事人下车。C没有跟着去，A走到C的面前，厉声道“你也一起走”。她们下了车，公交车继续前行。警察没有询问公交车上乘客任何问题，不至于每个人都低着头看手机而没有看到一些事情吧？我认为这是警察做得不足之处。</p>

<p>下车之后，一个哥们说B和C她们肯定是小偷，我不知道他的判断依据是什么，或许每个人都有自己的判断吧。</p>

<p>以上当事人的话语并不完完全全是原话，所写的是表达她们原话的意思。有几点我很不解：一、那时公交车上已不是很挤，人很稀疏的站在车内，加上是监控对准的地方，如果要偷窃的话，她们是不是很傻或者是神偷；二、女人B报了警，或许真的被冤枉，或许技术高超到知道如何挡住摄像头，我不明白；三、我没有听到女人C一句反驳的话语，如果被冤枉的话，一般人的反应不会那么平静，难道是见过大世面的人。</p>

<p>从以往的经历来看，A可能被偷怕了，对这类事情已经过敏了。或许是自己忘记了将拉链拉上，这些我们也无从知晓。警察调出视频查阅后，如果没有发生偷窃的事情，当然是好事，可以还B和C一个清白，那么A可能需要反省一下自己；如果真的有这样的事情发生，那么该惩罚的应该得到相应的惩罚。</p>

<p>发生这种事情，如果我们是事件中的A，我们又会如何处理：没有被偷就算了，还是报警？我们是旁观者，当我们思考着因报警而耽误上班时间的时候，我们是否应当先思考一下这个问题呢。当很多事情与我们无关的时候，我们是否应该如此的漠视呢？当我们是受害者的时候，如果得不到旁观者的支持，我们是否会觉得孤独，这个世界很残忍呢？面对这个繁杂而又浮躁的社会，我们真的应该学会设身处地的思考。</p>

<p>司机师傅的举动，由衷向他表示敬意。</p>

<p>警察的行动速度真的太慢了，不知道当国家面临危险的时候，你们是否只会选择“打扫战场”。处理事情的方式是否也能改进改进，这么多乘客在这里并不只是专门是在等你如此解决问题，我们中的某一个或许就是你的目击证人，不然就辜负了司机师傅的用意了。</p>

<p>这种事情每天都在公交车上上演，大家又是如何看待的？</p>
]]></content>
  </entry>
  
</feed>
